[
    {
        "question": "若有定义:char str[] = {'h','1','2','0','a','b'};const char *p = str; 下列语句正确的是:____",
        "A": "p[2] = 's'",
        "B": "strcpy(str,\"123456\")",
        "C": "strcpy(p,\"abc\")",
        "D": "strcpy(str,\"abc\")",
        "category": 1,
        "id": 0
    },
    {
        "question": "执行下列语句后，s的值是____\n```s = 0;for (int i = 1; i <= 10 ++i)\nif (i % 2 == 0 || i % 3 == 0) continue;\nelse s += i;```",
        "A": "55",
        "B": "49",
        "C": "13",
        "D": "1",
        "category": 1,
        "id": 1
    },
    {
        "question": "若```char x=97;```则变量x包含几个字符____",
        "A": "1个",
        "B": "2个",
        "C": "4个",
        "D": "8个",
        "category": 0,
        "id": 2
    },
    {
        "question": "执行以下语句:\n```int x; char s[100]; cin>>x; cin.get(); cin>>s;```\n当用户输入:2021(回车符)Hello(空格符)Sjtu(回车符)后字符串s中的值为:____",
        "A": "\"Sjtu\"",
        "B": "\"Hello Sjtu\"",
        "C": "\"Hello\"",
        "D": "'H'",
        "category": 1,
        "id": 3
    },
    {
        "question": "下列选项中两个表达式的运算结果相同的是____",
        "A": "3/2和3.0/2.0",
        "B": "3/2和3.0/2",
        "C": "3/2.0和3.0/2.0",
        "D": "3/2.0和3/2",
        "category": 0,
        "id": 4
    },
    {
        "question": "下列数中哪一个是8进制数____",
        "A": "0x1g",
        "B": "010",
        "C": "080",
        "D": "01b",
        "category": 0,
        "id": 5
    },
    {
        "question": "下面的说法中，错误的是____",
        "A": "算法原地工作的含义是指不需要任何额外的辅助空间",
        "B": "在相同规模n下，复杂度为O(n)的算法在时间上总是优于复杂度为O(2n)的算法",
        "C": "所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界",
        "D": "同一个算法，实现语言的级别越高，执行效率越低",
        "category": 0,
        "id": 6
    },
    {
        "question": "若线性表最常用的操作是存取第i个元素及其前驱和后继元素的值，为了提高效率，应采用____的存储方式。",
        "A": "单链表",
        "B": "双向链表",
        "C": "单循环链表",
        "D": "顺序表",
        "category": 0,
        "id": 7
    },
    {
        "question": "下面的说法中，错误的是____。Ⅰ.算法原地工作的含义是指不需要任何额外的辅助空间。Ⅱ.在相同规模n下，复杂度为O(n)的算法在时间上总是优于复杂度为O(2n)的算法。Ⅲ.所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界。Ⅳ.同一个算法，实现语言的级别越高，执行效率越低",
        "A": "Ⅰ",
        "B": "Ⅰ，Ⅱ",
        "C": "Ⅰ，Ⅳ",
        "D": "Ⅲ",
        "category": 0,
        "id": 8
    },
    {
        "question": "设线性表有n个元素，严格说来，以下操作中，____在顺序表上实现要比在链表上实现的效率高。Ⅰ.输出第i(1≤i≤n)个元素值。Ⅱ.交换第3个元素与第4个元素的值。Ⅲ.顺序输出这n个元素的值",
        "A": "Ⅰ",
        "B": "Ⅰ、Ⅲ",
        "C": "Ⅰ、Ⅱ",
        "D": "Ⅱ、Ⅲ",
        "category": 2,
        "id": 9
    },
    {
        "question": "下列关于线性表说法中，正确的是____。Ⅰ.顺序存储方式只能用于存储线性结构。Ⅱ.取线性表的第i个元素的时间与i的大小有关。Ⅲ.静态链表需要分配较大的连续空间，插入和删除不需要移动元素。Ⅳ.在一个长度为n的有序单链表中插入一个新结点并仍保持有序的时间复杂度为O(n)。Ⅴ.若用单链表来表示队列，则应该选用带尾指针的循环链表",
        "A": "Ⅰ、Ⅱ",
        "B": "Ⅰ、Ⅲ、Ⅳ、Ⅴ",
        "C": "Ⅳ、Ⅴ",
        "D": "Ⅲ、Ⅳ、Ⅴ",
        "category": 0,
        "id": 10
    },
    {
        "question": "给定有n个元素的一维数组，建立一个有序单链表的最低时间复杂度是____",
        "A": "O(1)",
        "B": "O(n)",
        "C": "O(n^2)",
        "D": "O(nlog2n)",
        "category": 1,
        "id": 11
    },
    {
        "question": "设链表不带头结点且所有操作均在表头进行，则下列最不适合作为链栈的是____",
        "A": "只有表头结点指针，没有表尾指针的双向循环链表",
        "B": "只有表尾结点指针，没有表头指针的双向循环链表",
        "C": "只有表头结点指针，没有表尾指针的单向循环链表",
        "D": "只有表尾结点指针，没有表头指针的单向循环链表",
        "category": 0,
        "id": 12
    },
    {
        "question": "用S表示进栈操作，用X表示出栈操作，若元素的进栈顺序是1234，为了得到1342的出栈顺序，相应的S和X的操作序列为____",
        "A": "SXSXSSXX",
        "B": "SSSXXSXX",
        "C": "SXSSXXSX",
        "D": "SXSSXSXX",
        "category": 1,
        "id": 13
    },
    {
        "question": "已知循环队列的存储空间为数组 A[21]，front 指向队头元素的前一个位置，rear 指向队尾元素，假设当前 front 和 rear 的值分别为8和3，则该队列的长度为____",
        "A": "5",
        "B": "6",
        "C": "16",
        "D": "17",
        "category": 1,
        "id": 14
    },
    {
        "question": "最适合用作链队的链表是____",
        "A": "带队首指针和队尾指针的循环单链表",
        "B": "带队首指针和队尾指针的非循环单链表",
        "C": "只带队首指针的非循环单链表",
        "D": "只带队首指针的循环单链表",
        "category": 0,
        "id": 15
    },
    {
        "question": "某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素a，b，c，d，e依次入此队列后再进行出队操作，则不可能得到的出队序列是____",
        "A": "b，a，c，d，e",
        "B": "d，b，a，c，e",
        "C": "d，b，c，a，e",
        "D": "e，c，b，a，d",
        "category": 1,
        "id": 16
    },
    {
        "question": "串’ababaaababaa’的next数组值为____",
        "A": "01234567899",
        "B": "012121111212",
        "C": "011234223456",
        "D": "0123012322345",
        "category": 1,
        "id": 17
    },
    {
        "question": "串 ‘ababaaababaa’的 next 数组为____",
        "A": "-1，0，1，2，3，4，5，6，7，8，8，8",
        "B": "-1，0，1，0，1，0，0，0，0，1，0，1",
        "C": "-1，0，0，1，2，3，1，1，2，3，4，5",
        "D": "-1，0，1，2，-1，0，1，2，1，1，2，3",
        "category": 1,
        "id": 18
    },
    {
        "question": "串’ababaaababaa'的nextval数组为____",
        "A": "0，1，0，1，1，2，0，1，0，1，0，2",
        "B": "0，1，0，1，1，4，1，1，0，1，0，2",
        "C": "0，1，0，1，0，4，2，1，0，1，0，4",
        "D": "0，1，1，1，0，2，1，1，0，1，0，4",
        "category": 1,
        "id": 19
    },
    {
        "question": "设主串T='abaabaabcabaabc'，模式串S=’abaabc'，采用KMP算法进行模式匹配，到匹配成功时为止，在匹配过程中进行的单个字符间的比较次数是____",
        "A": "9",
        "B": "10",
        "C": "12",
        "D": "15",
        "category": 1,
        "id": 20
    },
    {
        "question": "对于一棵具有 n 个结点、度为4的树来说，____",
        "A": "树的高度至多是n-3",
        "B": "树的高度至多是n-4",
        "C": "第i层上至多有 4(i-1)个结点",
        "D": "至少在某一层上正好有4个结点",
        "category": 1,
        "id": 21
    },
    {
        "question": "在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10 个度为1的结点，则树T的叶结点个数是____",
        "A": "41",
        "B": "82",
        "C": "113",
        "D": "122",
        "category": 1,
        "id": 22
    },
    {
        "question": "下说法中，正确的是____",
        "A": "在完全二叉树中，叶子结点的双亲的左兄弟 (若存在)一定不是叶子结点",
        "B": "任何一棵二叉树，叶子结点个数为度为2的结点数减 1，即 n0=n2-1",
        "C": "完全二叉树不适合顺序存储结构，只有满二叉树适合顺序存储结构",
        "D": "结点按完全二叉树层序编号的二叉树中，第i个结点的左孩子的编号为2i",
        "category": 0,
        "id": 23
    },
    {
        "question": "一个具有 1025 个结点的二叉树的高h为____",
        "A": "11",
        "B": "10",
        "C": "11~1025",
        "D": "10~1024",
        "category": 1,
        "id": 24
    },
    {
        "question": "一棵有 124 个叶子结点的完全二叉树，最多有____个结点。",
        "A": "247",
        "B": "248",
        "C": "249",
        "D": "250",
        "category": 1,
        "id": 25
    },
    {
        "question": "一个有 28 条边的非连通无向图至少有____个顶点。",
        "A": "7",
        "B": "8",
        "C": "9",
        "D": "10",
        "category": 1,
        "id": 26
    },
    {
        "question": "对于一个有 n 个顶点的图:若是连通无向图，其边的个数至少为____;若是强连通有向图，其边的个数至少为____",
        "A": "n-1，n",
        "B": "n-1，n(n-1)",
        "C": "n，n",
        "D": "n，n(n-1)",
        "category": 1,
        "id": 27
    },
    {
        "question": "若无向图 G =(V，E)中含有7个顶点，要保证图 G在任何情况下都是连通的，则需要的边数最少是____",
        "A": "6",
        "B": "15",
        "C": "16",
        "D": "21",
        "category": 1,
        "id": 28
    },
    {
        "question": "已知无向图 G含有 16条边，其中度为4的顶点个数为3，度为3 的顶点个数为4，其他顶点的度均小于3。图 G所含的顶点个数至少是____",
        "A": "10",
        "B": "11",
        "C": "13",
        "D": "15",
        "category": 1,
        "id": 29
    },
    {
        "question": "已知一个长度为 16 的顺序表L，其元素按关键字有序排列，若采用折半查找法查找一个L中不存在的元素，则关键字的比较次数最多是____",
        "A": "4",
        "B": "5",
        "C": "6",
        "D": "7",
        "category": 1,
        "id": 30
    },
    {
        "question": "分别以下列序列构造二叉排序树，与用其他3个序列所构造的结果不同的是____",
        "A": "(100，80，90，60，120，110，130)",
        "B": "(100，120，110，130，80，60，90)",
        "C": "(100，60，80，90，120，110，130)",
        "D": "(100，80，60，90，120，130，110)",
        "category": 1,
        "id": 31
    },
    {
        "question": "在含有 n个结点的二叉排序树中查找某个关键字的结点时，最多进行____次比较",
        "A": "n/2",
        "B": "log2n",
        "C": "log2n+1",
        "D": "n",
        "category": 1,
        "id": 32
    },
    {
        "question": "对下列关键字序列，不可能构成某二叉排序树中一条查找路径的是____",
        "A": "95，22，91，24，94，71",
        "B": "92，20，91，34，88，35",
        "C": "21，89，77，29，36，38",
        "D": "12，25，71，68，33，34",
        "category": 1,
        "id": 33
    },
    {
        "question": "现有一棵无重复关键字的平衡二叉树(AVL)，对其进行中序遍历可得到一个降序序列。下列关于该平衡二叉树的叙述中，正确的是____",
        "A": "根结点的度一定为2",
        "B": "树中最小元素一定是叶结点",
        "C": "最后插入的元素一定是叶结点",
        "D": "树中最大元素一定是无左子树",
        "category": 1,
        "id": 34
    },
    {
        "question": "已知a=1，b=2，c=3，则表达是++a||-b&&++c的值为____",
        "A": "0",
        "B": "1",
        "C": "2",
        "D": "3",
        "category": 2,
        "id": 35
    },
    {
        "question": "下列表达式选项中，____是正确的。",
        "A": "++(a++)",
        "B": "a++b",
        "C": "a+++b",
        "D": "a++++b",
        "category": 0,
        "id": 36
    },
    {
        "question": "在循环语句中使用break语句的作用是____",
        "A": "结束本次循环",
        "B": "结束该层循环",
        "C": "结束所有循环",
        "D": "结束程序执行",
        "category": 0,
        "id": 37
    },
    {
        "question": "对if后的括号中的表达式，要求i不为0的时候表达式为真，该表达式表示正确的为_____",
        "A": "i",
        "B": "!i",
        "C": "i<>0",
        "D": "i=0",
        "category": 0,
        "id": 38
    },
    {
        "question": "下列循环语句的执行次数是____。while(!1) cout<<”ok!”;",
        "A": "0次",
        "B": "1次",
        "C": "2次",
        "D": "无数次",
        "category": 2,
        "id": 39
    },
    {
        "question": "在C++中对数组下标说法正确的是____",
        "A": "初始化数组的值的个数可以多于定义的数组元素的个数，多出部分将被忽略。",
        "B": "初始化数组的值的个数可以少于定义的数组元素的个数。",
        "C": "初始化数组的值的个数必须等于定义的数组元素的个数。",
        "D": "初始化数组的值可以通过跳过逗号的方式来省略。如int a[3]={1, ,2};",
        "category": 0,
        "id": 40
    },
    {
        "question": "数组定义为:int a[2][2]={1,2,3,4};则a[1][0]%3为____",
        "A": "0",
        "B": "1",
        "C": "2",
        "D": "4",
        "category": 1,
        "id": 41
    },
    {
        "question": "数组定义为:```int a[][2]={5,6,1,2,3,8};```则能用于计算数组下标的是____",
        "A": "sizeofA:/sizeof(int)",
        "B": "sizeof(a[])/sizeof(3)",
        "C": "sizeof(a[][2])/sizeof(int)",
        "D": "sizeofA:/sizeof(a[2][1])",
        "category": 1,
        "id": 42
    },
    {
        "question": "下列叙述中正确的是____",
        "A": "C++语言程序中，main()函数必须在其它函数之前，函数内可以嵌套定义函数。",
        "B": "C++语言程序中，main()函数的位置没有限制，函数内不可以嵌套定义函数。",
        "C": "C++语言程序中，main()函数必须在其它函数之前，函数内不可以嵌套定义函数。",
        "D": "C++语言程序中，main()函数必须在其它函数之后，函数内可以嵌套调用函数。",
        "category": 0,
        "id": 43
    },
    {
        "question": "下列对return语句叙述错误的是____",
        "A": "在函数定义中可能有return语句，也可能没有return语句。",
        "B": "在函数定义中可以有多条return语句。",
        "C": "在函数定义中每条return语句可能返回多个值。",
        "D": "如果函数类型不是void型，则函数定义中必须有return语句。",
        "category": 0,
        "id": 44
    },
    {
        "question": "C++语言中函数返回值的类型是由____决定的。",
        "A": "return语句中的表达式类型",
        "B": "调用该函数的主调函数类型",
        "C": "定义函数时所指定的函数类型",
        "D": "以上说法都不正确",
        "category": 0,
        "id": 45
    },
    {
        "question": "C++中，关于参数默认值的描述正确的是____",
        "A": "只能在函数定义时设置参数默认值",
        "B": "设置参数默认值时，应当从右向左设置",
        "C": "设置参数默认值时，应当全部设置",
        "D": "设置参数默认值后，调用函数不能再对参数赋值",
        "category": 0,
        "id": 46
    },
    {
        "question": "使用重载函数编程序的目的是____",
        "A": "使用相同的函数名调用功能相似但参数不同的函数",
        "B": "共享程序代码",
        "C": "提高程序的运行速度",
        "D": "节省存储空间",
        "category": 0,
        "id": 47
    },
    {
        "question": "系统在调用重载函数时，下列不能作为确定调用哪个重载函数的依据的选项是____",
        "A": "函数名",
        "B": "参数个数",
        "C": "函数类型",
        "D": "参数类型",
        "category": 0,
        "id": 48
    },
    {
        "question": "数组作为函数的形参，把数组名作为函数的实参时，传递给函数的是____",
        "A": "数组中各元素的值",
        "B": "数组中元素的个数",
        "C": "数组中第0个元素的值",
        "D": "该数组的首地址",
        "category": 0,
        "id": 49
    },
    {
        "question": "要使变量i成为int型变量x的别名，正确的定义语句是____",
        "A": "int &i=x;",
        "B": "int i=&x;",
        "C": "int &i=&x;",
        "D": "int i=x;",
        "category": 2,
        "id": 50
    },
    {
        "question": "在下列指针表达式中，与下标访问a[i][j]不等效的是____",
        "A": "*(a+i+j)",
        "B": "(*(a+i))[j]",
        "C": "*(*(a+i)+j)",
        "D": "*(a[i]+j)",
        "category": 2,
        "id": 51
    },
    {
        "question": "已定义字符串```char str[5]```，则下列表达式中不能表示str[1]的地址的是____",
        "A": "str+1",
        "B": "str++",
        "C": "&str[0]+1",
        "D": "&str[1]",
        "category": 2,
        "id": 52
    },
    {
        "question": "已知:```int a[]={1,2,3,4,5,6},*p=a,x；```下面语句中x的值为5的是____",
        "A": "p+=3;x=*(p++);",
        "B": "p+=5;x=*p++;",
        "C": "p+=4;x=*++p;",
        "D": "p+=4; x=*p++",
        "category": 2,
        "id": 53
    },
    {
        "question": "若有说明:int i,j=6,*p;p=&i；则与i=j等价的语句是____",
        "A": "i=*p;",
        "B": "*p=*&j;",
        "C": "i=&j;",
        "D": "i=**p;",
        "category": 2,
        "id": 54
    },
    {
        "question": "设p1和p2是指向同一个int型一维数组的指针变量，k为int型变量，则不能正确执行的语句是____",
        "A": "k=*p1+*p2;",
        "B": "p2=k;",
        "C": "p1=p2;",
        "D": "k=*p1*(*p2);",
        "category": 2,
        "id": 55
    },
    {
        "question": "执行以下程序段后，m的值为____。\n ```int a[2][3]={{1,2,3},{4,5,6}};int m,*p=&a[0][0];m=(*p)*(*(p+2))*(*(p+4));```",
        "A": "15",
        "B": "14",
        "C": "13",
        "D": "12",
        "category": 2,
        "id": 56
    },
    {
        "question": "设有如下定义，下面关于ptr正确叙述是____。\n ```int  (*ptr)();``` ",
        "A": "ptr是指向一维数组的指针变量。",
        "B": "ptr是指向int 型数据的指针变量。",
        "C": "ptr是指向函数的指针，该函数返回一个int型数据。",
        "D": "ptr是一个函数名，该函数的返回值是指向int型数据的指针。",
        "category": 2,
        "id": 57
    },
    {
        "question": "下列选项中，不是合法的整型常量的是____",
        "A": "288",
        "B": "288L",
        "C": "0288",
        "D": "0x288",
        "category": 1,
        "id": 58
    },
    {
        "question": "循环语句``` for ( k = 5; k = 0; --k);```的循环次数是____",
        "A": "0",
        "B": "5",
        "C": "6",
        "D": "无限次",
        "category": 2,
        "id": 59
    },
    {
        "question": "如有函数```f(A x,  A *y,  int size,  A &z)```，并有定义```A  b[2]```，调用```f(b[1], b, 2, b[0])```时，A的构造函数的调用次数是____",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "category": 1,
        "id": 60
    },
    {
        "question": "若有定义:```char *p = “h12\\0ab”, str[] = “h12\\0ab”; ```则sizeof(p)、sizeof(str)和strlen(p)的值是____",
        "A": "4、4、3",
        "B": "7、7、7",
        "C": "4、8、7",
        "D": "4、7、3",
        "category": 2,
        "id": 61
    },
    {
        "question": "以下选项中不合法的运算符重载函数名是____",
        "A": "operator! ",
        "B": "operator()",
        "C": "operator@",
        "D": "operator!=",
        "category": 2,
        "id": 62
    },
    {
        "question": "如果m=1，n=1，执行了表达式 (m --) || (n *= m)后m和n的值分别是____",
        "A": "1，0",
        "B": "1，1",
        "C": "0，0",
        "D": "0，1",
        "category": 2,
        "id": 63
    },
    {
        "question": "类A正确的拷贝构造函数原型是____",
        "A": "A(A &other)",
        "B": "A(const A &other)",
        "C": "A(A other)",
        "D": "void A(A &other)",
        "category": 2,
        "id": 64
    },
    {
        "question": "以下选项中不合法的字符常量是____",
        "A": "'d'",
        "B": "'t'",
        "C": "'\\123'",
        "D": "'\\'",
        "category": 0,
        "id": 65
    },
    {
        "question": "C++的整型常量0101的十进制值是____",
        "A": "5",
        "B": "101",
        "C": "65",
        "D": "4097",
        "category": 0,
        "id": 66
    },
    {
        "question": "语句cout << \"abc0\\0def\"的输出结果是____",
        "A": "abc0\\0def\\",
        "B": "abc0\\0def",
        "C": "abc",
        "D": "abc0",
        "category": 1,
        "id": 67
    },
    {
        "question": "如有函数f(const A &x, A &y)，并有定义A b(2)，调用f(4, b)时，A的构造函数的调用次数是____",
        "A": "非法调用，编译出错",
        "B": "0",
        "C": "1",
        "D": "2",
        "category": 1,
        "id": 68
    },
    {
        "question": "执行下列语句时，输出的行数是:____\nint s = 1;while (s < 10) {s *= 2;if (s % 4 != 0) continue;cout << s << endl;}",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "category": 2,
        "id": 69
    },
    {
        "question": "若有定义int *p = NULL; 语句cout << p << ' ' << *p;的结果是____",
        "A": "p的地址NULL",
        "B": "p的地址0",
        "C": "0 0",
        "D": "运行出错",
        "category": 2,
        "id": 70
    },
    {
        "question": "若有定义:char str[] = {'h', '1', '2', '\\0', 'a', 'b'}; 则sizeof(str)、strlen(str)的值是____",
        "A": "7、3",
        "B": "7、7",
        "C": "6、3",
        "D": "6、6",
        "category": 2,
        "id": 71
    },
    {
        "question": "以下哪个操作符既可以重载成成员函数，也可以重载成类的友元函数____",
        "A": "<<",
        "B": "+=",
        "C": "=",
        "D": "()",
        "category": 0,
        "id": 72
    },
    {
        "question": "设有定义int x; char ch; 下列不能够输出ch 的ASCII码的语句是____",
        "A": "cout << (int)ch;",
        "B": "cout << int(ch);",
        "C": "cout << ch;",
        "D": "cout << (x = ch);",
        "category": 2,
        "id": 73
    },
    {
        "question": "若有如下定义，则对数组元素的成员引用不正确的是____。\nstruct Student{int id; char *name; Student(int len = 10) {name = new char[len];} };Student stu [2],*p; p=stu;",
        "A": "p[1].id",
        "B": "p->id",
        "C": "(*p).name",
        "D": "*p.name",
        "category": 2,
        "id": 74
    },
    {
        "question": "如将类X的*运算符重载为友元函数，实现类X的两个对象相乘，并返回相乘后的结果，则该函数的声明语句为____",
        "A": "X operator*(const X & a , const X & b);",
        "B": "X operator*(const X & a) const;",
        "C": "X & operator*(const X & a , const X & b);",
        "D": "X & operator*( const X & a) const;",
        "category": 2,
        "id": 75
    },
    {
        "question": "判断字符类型的变量ch的内容为数字字符的表达式是____",
        "A": "'0'<= ch <= '9'",
        "B": "(ch >= '0') && (ch <= '9')",
        "C": "(ch >='0') || (ch <= '9')",
        "D": "(ch >= 0) && ( ch <= 9)",
        "category": 2,
        "id": 76
    },
    {
        "question": "若有定义:char *s；接着立即执行下列哪个语句运行时不会出现错误____",
        "A": "s ={\"SJTU\"};",
        "B": "s =\"SJTU\";",
        "C": "strcpy(s, \"SJTU\");",
        "D": "s[0] = 'S';",
        "category": 2,
        "id": 77
    },
    {
        "question": "关于函数的定义，下面哪个说法是错误的____",
        "A": "一个程序中不能出现同名函数",
        "B": "void类型的函数也可以使用return语句",
        "C": "函数调用时的实际参数个数可以少于形式参数个数",
        "D": "return后面的表达值的类型一定是函数的返回类型",
        "category": 0,
        "id": 78
    },
    {
        "question": "关于类的静态成员函数，下面说法错误的是____",
        "A": "只能访问静态成员",
        "B": "没有this指针",
        "C": "只能通过\"类名::函数名\"访问",
        "D": "函数定义必须写在类中",
        "category": 0,
        "id": 79
    },
    {
        "question": "一个源文件想要定义一个本源文件专用的、不允许其他源文件共享的全局变量，则需要在本文件定义该全局变量前加限定词。____",
        "A": "auto",
        "B": "extern",
        "C": "static",
        "D": "register",
        "category": 0,
        "id": 80
    },
    {
        "question": "下面定义中，非法的是____",
        "A": "const int a = 10, *p = &a;",
        "B": "int b; const int &a = b;",
        "C": "const int a = 10 , &b = a;",
        "D": "const int a = 10; int *p = &a;",
        "category": 2,
        "id": 81
    },
    {
        "question": "当使用ifstream流定义一个流对象并打开一个磁盘文件时，文件的隐含打开方式为____",
        "A": "ios::in",
        "B": "ios::out",
        "C": "ios::in|ios::out",
        "D": "ios::binary",
        "category": 0,
        "id": 82
    },
    {
        "question": "类B从类A继承，并有定义:A *pa; B *pb;下面不正确的用法是____",
        "A": "pa = pb;",
        "B": "pb = pa;",
        "C": "pa = (A *) pb;",
        "D": "pb = (B *) pa;",
        "category": 2,
        "id": 83
    },
    {
        "question": "有类模板template <class T, int L) class foo; 及class A; int con = 10; 下面定义中正确的是____",
        "A": "foo<int, con> obj;",
        "B": "foo<A, con> obj;",
        "C": "foo<int, 5> obj;",
        "D": "foo<con, 5> obj;",
        "category": 2,
        "id": 84
    },
    {
        "question": "以下不是面向对象特性的是____",
        "A": "多态",
        "B": "继承",
        "C": "泛型",
        "D": "递归",
        "category": 0,
        "id": 85
    },
    {
        "question": "某计算机系统中整数用8位补码表示，则10010100 + 00101111结果值的十进制表示是____",
        "A": "195",
        "B": "-67",
        "C": "-61",
        "D": "67",
        "category": 1,
        "id": 86
    },
    {
        "question": "如果字母A的内码是65，语句cout << 'A' + 1; 的正确输出是____",
        "A": "'A' + 1",
        "B": "66",
        "C": "066",
        "D": "B",
        "category": 1,
        "id": 87
    },
    {
        "question": "如有函数f(A &x, const A &y)，并有定义A b(2)，调用f(4, b)时，A的构造函数的调用次数是____",
        "A": "非法调用，编译出错",
        "B": "0",
        "C": "1",
        "D": "2",
        "category": 1,
        "id": 88
    },
    {
        "question": "执行下列语句时，输出的行数是____\nint s = 1;while (s < 5) {if (++s = 4 ) break;cout << s << endl;}",
        "A": "0",
        "B": "1",
        "C": "3",
        "D": "4",
        "category": 2,
        "id": 89
    },
    {
        "question": "下列语句段{A * p1 = new A; auto_ptr<A> p2( new A); shared_ptr<A> p3( new A), p4 = p3; }, A的析构函数执行的次数是____",
        "A": "0",
        "B": "1",
        "C": "2",
        "D": "3",
        "category": 2,
        "id": 90
    },
    {
        "question": "在程序中，对A类对象a需要执行1 + a，并且A类有一个需要一个整型参数的构造函数，下列选项中不可行的方案是____",
        "A": "在A类中定义一个向整型 转换的类型转换函数",
        "B": "在A类中添加一个向实型转换的类型转换函数",
        "C": "在A类中增加一个重载+的成员函数",
        "D": "在A类中增加一个重载+的友元函数",
        "category": 0,
        "id": 91
    },
    {
        "question": "设有class A {……}；class B: public A {……};，并有定义: A *p = new B;，下列语句中合法的是____",
        "A": "B *q = p;",
        "B": "B b = *p;",
        "C": "B &b = *p;",
        "D": "A &a = *p;",
        "category": 2,
        "id": 92
    },
    {
        "question": "若有如下定义:const char *str[4] = {\"aaa\",\"bbb\",\"ccc\",\"ddd\"},则不能正确输出4个字符串的语句是____",
        "A": "for (int i = 0; i <4; ++ i) cout << str[i] << endl;",
        "B": "for (int i = 0; i <4; ++ i) cout << *(str + i) << endl;",
        "C": "for (const char **p = str; p < str + 4; ++ p) cout << p << endl;",
        "D": "for (const char **p = str; p < str + 4; ++ p) cout << *p << endl;",
        "category": 2,
        "id": 93
    },
    {
        "question": "下面X类的运算符重载函数中，原型错误的是____",
        "A": "X &operator=(const X & a);",
        "B": "X &operator=( X && a);",
        "C": "X & operator+=( const X & a);",
        "D": "X & operator+=( X & a);",
        "category": 2,
        "id": 94
    },
    {
        "question": "不能正确判断字符类型的变量ch的内容为数字字符的表达式是____",
        "A": "((ch >= '0') + (ch <= '9')) == 2",
        "B": "(ch >= '0') && (ch <= '9')",
        "C": "!((ch <'0') || (ch > '9'))",
        "D": "!((ch <='0') || (ch > ='9'))",
        "category": 2,
        "id": 95
    },
    {
        "question": "若有定义:char str1[5]；const char *p = \"abc\";下列不正确的语句是____",
        "A": "p = \"def\";",
        "B": "strcpy(p, str1)",
        "C": "p = str1;",
        "D": "strcpy(str1,p);",
        "category": 2,
        "id": 96
    },
    {
        "question": "若有函数void f( A r1, const A &r2, A &r3)，并有A x1(2), x2(4); 则调用函数f(x1, 5, x2)时，A的构造函数(包括拷贝构造函数)调用次数是____",
        "A": "0",
        "B": "1",
        "C": "2",
        "D": "3",
        "category": 1,
        "id": 97
    },
    {
        "question": "关于类的常量数据成员，下面说法错误的是____",
        "A": "必须在对象构造时赋初值",
        "B": "除构造函数外，任何成员函数都不能修改常量数据成员的值",
        "C": "非const的成员函数不能访问常量数据成员",
        "D": "不同的对象有不同的常量数据成员值",
        "category": 0,
        "id": 98
    },
    {
        "question": "如果希望函数中的局部变量在函数执行结束后依然存在，则需要在此变量定义前加限定词____",
        "A": "auto",
        "B": "extern",
        "C": "static",
        "D": "register",
        "category": 0,
        "id": 99
    },
    {
        "question": "若有函数f(int *a, const int &b, int &c)以及定义int m;和const int n = 9;，以下合法的函数调用是____",
        "A": "f((&m, 5, 5)",
        "B": "f(&m, 5, m)",
        "C": "f(&n, n , n)",
        "D": "f(m,m,n);",
        "category": 2,
        "id": 100
    },
    {
        "question": "下面文件流对象中，不能读文件的是____",
        "A": "fstream obj(\"ff\");",
        "B": "fstream obj(\"\"ff\", ios::binary)",
        "C": "fstream obj(\"ff\", ios::in | ios::out)",
        "D": "fstream obj(\"ff\", ios::in | ios::app)",
        "category": 2,
        "id": 101
    },
    {
        "question": "若有定义:class A {public: virtual void display(); }; class B:public A { public: virtual void display();}; 以及定义:B b; 下面无法调用派生类的display函数的语句是____",
        "A": "A *p = &b; p->display();",
        "B": "b.diaplay()",
        "C": "A a = b; a.display()",
        "D": "A &a = b; a.display();",
        "category": 2,
        "id": 102
    },
    {
        "question": "假设A是一个类名，下面的异常捕获中，错误的是____",
        "A": "catch (…);",
        "B": "catch(int);",
        "C": "catch (A x);",
        "D": "catch (int 5);",
        "category": 2,
        "id": 103
    },
    {
        "question": "下面陈述中错误的是____",
        "A": "多态性为软件系统的扩展提供便利",
        "B": "继承是代码重用的一种手段，也是运行时多态性的实现基础",
        "C": "派生类不可能是抽象类",
        "D": "友元函数是允许访问对象私有成员的全局函数",
        "category": 0,
        "id": 104
    },
    {
        "question": "整型常量011对应的十进制数是____",
        "A": "3",
        "B": "9",
        "C": "11",
        "D": "17",
        "category": 1,
        "id": 105
    },
    {
        "question": "某计算机系统中int用2字节表示，若有定义int a = -1，则cout << hex <<a;的输出是____",
        "A": "-1",
        "B": "–0x1",
        "C": "FFFF",
        "D": "65535",
        "category": 1,
        "id": 106
    },
    {
        "question": "若有定义:int a = 5; decltype(a+0.5) b; 则b的类型和初值是____",
        "A": "int 5",
        "B": "double 5.5",
        "C": "int 随机值",
        "D": "double 随机值",
        "category": 2,
        "id": 107
    },
    {
        "question": "若有定义:int a[] = {1,2,3,4,5}, len = 2;执行表达式a[len++]=0后，数组a和len的值分别是____",
        "A": "1，2，0，4，5和2",
        "B": "1，2，0，3，5和3",
        "C": "1，2，3，0，5和3",
        "D": "1，0，2，3，5和3",
        "category": 2,
        "id": 108
    },
    {
        "question": "若有定义:char ch;以下不符合C++语言语法的表达式是____",
        "A": "ch = 100",
        "B": "ch = 'a' + 6",
        "C": "ch = '''",
        "D": "ch = '\\'",
        "category": 2,
        "id": 109
    },
    {
        "question": "如果m= 1，n= 0，则执行表达式(m *= 2) || (n = m++)后m和n的值是____",
        "A": "2 0",
        "B": "2 2",
        "C": "3 2",
        "D": "3 3",
        "category": 2,
        "id": 110
    },
    {
        "question": "执行下面循环后s的值是____\n s =0;for (k = 1; k <= 100; ++k)if (k % 5) continue; else ++s;",
        "A": "100",
        "B": "90",
        "C": "80",
        "D": "20",
        "category": 2,
        "id": 111
    },
    {
        "question": "如果字母a的内码是97，不能输出abcd的语句是____",
        "A": "for (auto ch = 'a'; ch <='d'; ++ch) cout <<ch;",
        "B": "for (auto ch : {'a','b','c','d'} ) cout <<ch;",
        "C": "for (char ch = 97; ch <=100; ++ch) cout <<ch;",
        "D": "for (auto ch = 97; ch <=100; ++ch) cout <<ch;",
        "category": 2,
        "id": 112
    },
    {
        "question": "若有定义char *s = \"abcde\"，下面非法的操作是____",
        "A": "cout << *s;",
        "B": "cout <<s[2];",
        "C": "++s",
        "D": "++(*s)",
        "category": 2,
        "id": 113
    },
    {
        "question": "若有定义const int a = 5;下面操作非法的是____",
        "A": "int *pa = &a;",
        "B": "const int *pa = &a;",
        "C": "auto b = a;",
        "D": "decltype(a+3) b;",
        "category": 2,
        "id": 114
    },
    {
        "question": "若有定义:char str[] = {'h', '1', '2', '\\0', 'a', 'b'}; 表达式sizeof(str)的值是____",
        "A": "3",
        "B": "4",
        "C": "6",
        "D": "7",
        "category": 2,
        "id": 115
    },
    {
        "question": "如果类A有带有一个整型参数的构造函数和一个向实型转换的类型转换函数，并且有一个重载+的成员函数，则执行表达式1 + a的结果是____",
        "A": "一个A类对象",
        "B": "一个整型数",
        "C": "一个实型数",
        "D": "编译出错",
        "category": 1,
        "id": 116
    },
    {
        "question": "若有函数void f(int a, int &d, char b = 'a',int *c = nullptr)，且有定义int n;合法的调用是____",
        "A": "f(n, 2,'b',&n);",
        "B": "f(n,n,'\t',&n);",
        "C": "f(2, 3);",
        "D": "f(2, n,&n);",
        "category": 2,
        "id": 117
    },
    {
        "question": "有函数void f( constA &r1, A r2, A &r3,A* pa),并有A x1(2), x2(4); 则调用函数f(x1, 5, x2, &x1)时，A的构造函数(包括拷贝构造函数)调用次数是____",
        "A": "0",
        "B": "1",
        "C": "2",
        "D": "3",
        "category": 1,
        "id": 118
    },
    {
        "question": "关于公有的静态数据成员，以下说法错误的是____",
        "A": "是所有该类对象共享的数据",
        "B": "可以通过\"类名::静态数据成员名\"访问",
        "C": "对象空间中不包括静态数据成员",
        "D": "只能被静态成员函数访问",
        "category": 0,
        "id": 119
    },
    {
        "question": "关于const A类的对象，下面说法错误的是____",
        "A": "必须在定义时赋初值",
        "B": "只能调用A类的const成员函数",
        "C": "可以作为形式参数\"A x\"的实际参数",
        "D": "可以作为形式参数\"A &x\"的实际参数",
        "category": 0,
        "id": 120
    },
    {
        "question": "如果一个全局变量只能被本源文件访问，则需要在此变量定义前加限定词____",
        "A": "auto",
        "B": "extern",
        "C": "static",
        "D": "register",
        "category": 0,
        "id": 121
    },
    {
        "question": "若有定义:classA {public: virtual void display(); }; class B:public A { public: virtual void display();}; 以及定义:A *pa = new B, a = (*pa);则A:display()和pa->display()分别调用的是____",
        "A": "A类的display() A类的display()",
        "B": "B类的display() B类的display()",
        "C": "A类的display() B类的display()",
        "D": "B类的display() A类的display();",
        "category": 2,
        "id": 122
    },
    {
        "question": "A类的移动构造函数原型是____",
        "A": "A( A other);",
        "B": "A( const A & other);",
        "C": "A( A &&other);",
        "D": "A( A &other);",
        "category": 0,
        "id": 123
    },
    {
        "question": "下有如下定义语句:int a[] = {1,2,3,4,5};,则对语句int *p=a;正确的描述是____",
        "A": "语句int *p = a;定义不正确",
        "B": "语句int *p=a;初始化变量p，使其指向数组对象a的第一个元素",
        "C": "语句int *p=a; 是把数组a的所有元素值赋给变量p",
        "D": "语句int *p=a; 是把a[0]的值赋给变量p",
        "category": 2,
        "id": 124
    },
    {
        "question": "一棵结点数大于等于3的红黑树，以下描述正确的是____",
        "A": "根结点的度一定是2",
        "B": "最后插入的元素一定是叶结点",
        "C": "最小元素一定无左孩子",
        "D": "最后插入的元素一定是红结点",
        "category": 0,
        "id": 125
    },
    {
        "question": "下面排序算法中，时间性能与数据初始排列状态无关的算法是____",
        "A": "直接插入排序",
        "B": "堆排序",
        "C": "冒泡排序",
        "D": "归并排序",
        "category": 0,
        "id": 126
    },
    {
        "question": "下列中缀表达式中能够用一个容量为4的运算符栈转换成后缀表达式的是____",
        "A": "( 1 + 2)* ( 6 / 2 -1)",
        "B": "1+2 * 3 ^ (5+2) / 4 +6",
        "C": "1+ 2 * (3 -8 / 2) *3",
        "D": "(2* 3) ^ 2 ^ 3 / 4",
        "category": 2,
        "id": 127
    },
    {
        "question": "若入栈序列为SJTU，则下列哪个序列可能是其出栈序列？____",
        "A": "SJTU",
        "B": "UJTS",
        "C": "STJU",
        "D": "JTSU",
        "category": 1,
        "id": 128
    },
    {
        "question": "下图中合法的拓扑序列是____",
        "A": "ABCDEFG",
        "B": "ABDCFEG",
        "C": "ABCEFDG",
        "D": "ABDECFG",
        "category": 1,
        "id": 129
    },
    {
        "question": "要使一棵非空二叉树的前序序列与中序序列相同，其所有非叶结点须满足的条件是____",
        "A": "只有左子树",
        "B": "只有右子树",
        "C": "结点的度均为12",
        "D": "结点的度均为2",
        "category": 1,
        "id": 130
    },
    {
        "question": "设有如下图所示的火车车轨，入口到出口之间有3条轨道，列车的行进方向均为从左至右，列车可驶入任意一条轨道。现有编号为1～9的9节列车，进站次序是乱序(如:5、1、3、4、8、9、2、6、7表示最先进站的是5，然后依次是1、3、4、……，最后是7 )。若期望驶出的次序依次为1～9，下列进站序列中能完成重组的是____",
        "A": "1、3、2、4、5、6、8、7、9",
        "B": "5、2、8、6、1、7、9、4、3",
        "C": "5、2、8、6、1、7、9、4、3",
        "D": "9、2、1、5、8、4、3、6、7",
        "category": 1,
        "id": 131
    },
    {
        "question": "某棵表达式树的前序遍历序列是:* + / 3 2 8 - 7 1，中序遍历序列是:3 / 2 + 8 * 7 - 1，如下描述正确的是____",
        "A": "对应的中缀表达式是 3 / 2 + 8 * 7 - 1",
        "B": "对应的中缀表达式是 ( 3 / 2 + 8 * 7 - 1 )",
        "C": "对应的后缀表达式是 * + / 3 2 8 - 7 1",
        "D": "对应的后缀表达式是 3 2 / 8 + 7 1 - *",
        "category": 2,
        "id": 132
    },
    {
        "question": "已知二叉树的前序遍历序列为ABCD，后序遍历序列为CDBA，则不可能的中序遍历序列是____",
        "A": "CBDA",
        "B": "ACBD",
        "C": "ACBD",
        "D": "ADCB",
        "category": 1,
        "id": 133
    },
    {
        "question": "在一个带头尾结点的双链表中，删除指针p指向的结点的合法语句是____",
        "A": "p->prev->next = p->next; p->next->prev = p->prev; delete p;",
        "B": "q = p; delete p; q->prev->next = q->next; q->next->prev = q->prev;",
        "C": "q1 = delete p; p->prev; q2 = p->next; q1->next = q2; q2->prev = q1;",
        "D": "q1 = p->prev; q2 = q1->next; delete p; q1->next = q2; q2->prev = q1;",
        "category": 2,
        "id": 134
    },
    {
        "question": "如果数据的原始排列非常接近排序后的状态，可以选择____",
        "A": "直接插入排序",
        "B": "直接选择排序",
        "C": "猴子排序",
        "D": "快速排序",
        "category": 0,
        "id": 135
    },
    {
        "question": "对5个元素进行编码，不可能是哈夫曼编码的是____",
        "A": "000、0010、1100、1010、1111",
        "B": "00、01、100、101、11",
        "C": "00、01、100、101、11",
        "D": "0、10、1100、1101、111",
        "category": 1,
        "id": 136
    },
    {
        "question": "在双链表类中增加一个迭代器。迭代器的数据成员是指向双链表的结点的指针cur。在迭代器itr指向的位置上插入一个元素x。插入后迭代器指向新插入的结点。结点类node的构造函数原型是node(node *prev, int x, node *next); 假设所有的数据成员都是公有的，下面选项中合法的是 (构造函数)____",
        "A": "itr,cur = new node(itr.cur->prev, x, itr.cur->next);itr.cur->prev->next = itr.cur->ext->prev = itr.cur;",
        "B": "itr.cue->prev->next = itr.cur->prev = new node(itr.cur->prev, x, itr.cur->next);itr.cur = itr.cur->prev;",
        "C": "itr.cue->prev->next = itr.cur->prev = new node(itr.cur->prev, x, itr.cur-);itr.cur = itr.cur->prev;",
        "D": "itr.cue->prev = itr.cur->prev->next = new node(itr.cur->prev, x, itr.cur-);itr.cur = itr.cur->prev;",
        "category": 2,
        "id": 137
    },
    {
        "question": "将数据1、2、3、4、5、6依次进入一个FIFO的队列，在插入过程中可能有一些出队操作，最终所有元素都要出队。下列选项中可能的出队次序是____",
        "A": "6、5、4、3、2、1",
        "B": "1、2、3、4、5、6",
        "C": "2、1、3、5、4、6",
        "D": "3、2、1、6、5、4",
        "category": 1,
        "id": 138
    },
    {
        "question": "将优先级为3、6、5、1、7、0、9的元素依次进入一个优先级队列，数值越小优先级越高，在入队过程中可能有一些出队操作，最后所有元素都要出队。下列选项中不可能的出队次序是____",
        "A": "3、5、6、0、1、7、9",
        "B": "3、1、6、5、0、7、9",
        "C": "0、1、3、5、6、7、9",
        "D": "3、0、1、5、6、7、9",
        "category": 1,
        "id": 139
    },
    {
        "question": "对元素3、1、6、0、5、7、9进行一趟排序后的结果是0、1、6、3、5、7、9，则选用的排序算法可能是____",
        "A": "冒泡排序",
        "B": "直接插入排序",
        "C": "插入排序",
        "D": "希尔排序中的3-排序",
        "category": 0,
        "id": 140
    },
    {
        "question": "若有a:b:c:d:e依次进入一个栈中，期间可以有出栈。如果第一个出栈的元素是c，第二个出栈的元素不可能是____",
        "A": "a",
        "B": "b",
        "C": "d",
        "D": "e",
        "category": 1,
        "id": 141
    },
    {
        "question": "在如下邻接矩阵中\n| ∞ | 5 | 1 | ∞ | ∞ | ∞ |/n| 5 | ∞ | ∞ | 1 | ∞ | ∞ |/n| 1 | ∞ | ∞ | 4 | 2 | ∞ |/n| ∞ | 1 | 4 | ∞ | 2 | 2 |/n| ∞ | ∞ | 2 | 2 | ∞ | 2 |/n| ∞ | ∞ | ∞ | 2 | 2 | ∞ |/n最小生成树是:____",
        "A": "(0,1)(1,3)(2,4)(3,4)(4,5)",
        "B": "(0,2)(1,3)(2,4)(3,4)(4,2)",
        "C": "(0,2)(1,3)(2,4)(3,4)(3,5)",
        "D": "(0,2)(2,3)(2,4)(3,4)(4,5)",
        "category": 1,
        "id": 142
    },
    {
        "question": "若将关键字 1，2，3，4，5，6，7 依次插入到初始为空的AVL树 T 中，则 T 中平衡因子为 0 的非叶子结点的个数是____",
        "A": "0",
        "B": "1",
        "C": "2",
        "D": "3",
        "category": 1,
        "id": 143
    },
    {
        "question": "下列程序段的时间复杂度是____\ncount = 0;for (k = 1; k <= n; k *= 2)for (j = 1; j <= n; j = j+1)count++;",
        "A": "O(log2n)",
        "B": "O(n)",
        "C": "O(nlog2n)",
        "D": "O(n^2)",
        "category": 2,
        "id": 144
    },
    {
        "question": "设有1000000个待排序的数字，如果需要用最快的方法选出其中最小的10个，则用下列哪个方法可以达到此目的____",
        "A": "快速排序",
        "B": "堆排序",
        "C": "归并排序",
        "D": "希尔排序",
        "category": 0,
        "id": 145
    },
    {
        "question": "若元素A:B:C:D:e、f依次进栈，允许进栈、退栈操作交替进行。但最多只允许连续执行两次退栈，则不可能得到的出栈序列是____",
        "A": "dcebfa",
        "B": "cbdaef",
        "C": "cbdafe",
        "D": "adcfeb",
        "category": 1,
        "id": 146
    },
    {
        "question": "在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是____",
        "A": "81",
        "B": "82",
        "C": "122",
        "D": "123",
        "category": 1,
        "id": 147
    },
    {
        "question": "对于下列关键字序列，不可能构成某二叉查找树中一条查找路径的序列是____",
        "A": "21，89，77，29，36，38",
        "B": "92，20，91，34，88，35",
        "C": "95，22，91，24，94，71",
        "D": "12，25，71，68，33，34",
        "category": 1,
        "id": 148
    },
    {
        "question": "若一棵二叉树的前序遍历序列为a，e，b，d，c，后序遍历序列为b，c，d，e，a，则根结点的孩子结点____",
        "A": "只有e",
        "B": "有e、b",
        "C": "有e、c",
        "D": "无法确定",
        "category": 1,
        "id": 149
    },
    {
        "question": "设哈夫曼编码的长度不超过4，若已对两个字符编码为1和01，则最多还可以对个字符编码____",
        "A": "2",
        "B": "3",
        "C": "4",
        "D": "5",
        "category": 1,
        "id": 150
    },
    {
        "question": "若用邻接矩阵存储有向图，矩阵中主对角线以下的元素均为零，则关于该图拓扑序列的结论是____",
        "A": "存在，且唯一",
        "B": "不存在",
        "C": "存在，可能不唯一",
        "D": "无法确定是否存在",
        "category": 0,
        "id": 151
    },
    {
        "question": "下列关于最小生成树的说法中，正确的是____。I. 最小生成树树的代价唯一;II. 权值最小的边一定会出现在所有的最小生成树中;III. Prim算法从不同顶点开始得到的最小生成树一定相同;IV. Prim算法和Kruskal算法得到的最小生成树总不相同",
        "A": "仅I",
        "B": "仅II",
        "C": "仅I、III",
        "D": "仅II、IV",
        "category": 0,
        "id": 152
    },
    {
        "question": "在内部排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一趟排序。对一组数据(2，12，16，88，5，10)进行排序，若前三趟排序结果如下。第一趟:2，12，16，5，10，88;第二趟:2，12，5，10，16，88;第三趟:2，5，10，12，16，88。则采用的排序方法是____",
        "A": "堆排序",
        "B": "起泡排序",
        "C": "基数排序",
        "D": "直接插入排序",
        "category": 0,
        "id": 153
    },
    {
        "question": "不带头尾结点的双循环链表中结点node的结构为(prev，data，next)，head是指向双循环链表中某个结点的指针。链表为空时，head的值为NULL。在初始为空的双循环链表中插入一个值为d的结点的操作是____",
        "A": "head->data = d; head->next=head->prev = NULL;",
        "B": "head->data = d; head->next=head->prev = head;",
        "C": "head = new node; head->data = d; head->next=head->prev = NULL;",
        "D": "head = new node; head->data = d; head->next=head->prev = head;",
        "category": 2,
        "id": 154
    },
    {
        "question": "设二叉查找树前序遍历序列为(15、5、0、3、10、30、18、16、40、35、50、45)，这棵树是否为AVL树以及这棵树的高度为____(只有一个根节点的树高度为1)",
        "A": "是，4",
        "B": "是，5",
        "C": "否，4",
        "D": "否，5",
        "category": 1,
        "id": 155
    },
    {
        "question": "对一组权值为{1、2、3、4、5、6、7、8}的元素构建一棵哈夫曼树，树的高度是____",
        "A": "4",
        "B": "5",
        "C": "6",
        "D": "7",
        "category": 1,
        "id": 156
    },
    {
        "question": "已知一个最小化堆的层次遍历为(1、4、10、5、6、111、13、9、8)，在此堆中插入元素3，插入后3的层次为(根节点是第一层)____",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "category": 1,
        "id": 157
    },
    {
        "question": "在二叉树结点的前序序列、中序序列和后序序列中，所有叶子结点的先后顺序____",
        "A": "完全相同",
        "B": "前序和中序相同，而与后序不同",
        "C": "都不相同",
        "D": "中序和后序相同，而与前序不同",
        "category": 0,
        "id": 158
    },
    {
        "question": "一组整数1到10依次进入一个栈，如果栈的规模为5，则不可能出栈的序列为____",
        "A": "1，2，3，4，5，6，7，8，9，10",
        "B": "5，4，6，7，3，2，9，8，10，1",
        "C": "4，5，3，6，10，9，8，7，2，1",
        "D": "4，3，6，5，8，7，10，9，2，1",
        "category": 1,
        "id": 159
    },
    {
        "question": "利用快速排序对数据{5，6，3，4，9，10，1，2，7，8}进行排序。划分时用第一个元素作为标准元素。经过一趟划分后，数组元素的次序为____",
        "A": "1，2，3，4，5，6，7，8，9，10",
        "B": "2，1，3，4，5，10，9，6，7，8",
        "C": "1，2，3，4，5，9，10，6，7，8",
        "D": "3，4，1，2，5，6，9，10，7，8",
        "category": 1,
        "id": 160
    },
    {
        "question": "利用孩子兄弟链存储树，则根结点的右指针是____",
        "A": "指向最左孩子",
        "B": "指向最右孩子",
        "C": "空",
        "D": "不确定",
        "category": 1,
        "id": 161
    },
    {
        "question": "在结点结构为(prev，data，next)的双向循环链表中，在p指针所指向的结点前插入一个指针q所指向的新结点，其修改指针的操作是____",
        "A": "p->prev = q; q->next = p; p->prev->next = q; q->prev = q;",
        "B": "p->prev = q; p->prev->next = q; q->next = p; q->prev = p->prev;",
        "C": "q->prev = p->prev; q->next = p; p->prev = q; p->prev = q;",
        "D": "q->next = p; q->prev = p->prev; p->prev->next = q; p->prev = q;",
        "category": 2,
        "id": 162
    },
    {
        "question": "设一组初始记录关键字序列为(0，5，10，15，20，25，30，35，40，45，50，55，60，65，70)，则利用二分法查找关键字60需要比较的关键字个数为____",
        "A": "1",
        "B": "2",
        "C": "3",
        "D": "4",
        "category": 1,
        "id": 163
    },
    {
        "question": "一组纪录的关键字序列为(22，66，30，70，60，87，24)，利用堆排序将其按递增次序排序，通过buildHeap建立的初始堆为____",
        "A": "(22，60，24，70，66，87，30)",
        "B": "(87，70，30，66，60，22，24)",
        "C": "(22，24，30，60，66，70，87)",
        "D": "(87，70，66，60，30，24，22)",
        "category": 1,
        "id": 164
    },
    {
        "question": "某二叉树的先序序列和后序序列正好相反，则该二叉树一定是怎么样的二叉树____",
        "A": "空或只有一个结点",
        "B": "叶子结点数至多为1",
        "C": "任一结点无左儿子",
        "D": "任一结点无右儿子",
        "category": 1,
        "id": 165
    },
    {
        "question": "下列选项给出的是从根分别到达两个叶节点路径上的权值序列，能属于同一棵哈夫曼树的是____",
        "A": "24，10，5和24，10，7",
        "B": "24，10，5和24，12，7",
        "C": "24，10，10和24，14，11",
        "D": "24，10，5和24，14，6",
        "category": 1,
        "id": 166
    },
    {
        "question": "如元素进栈次序是1、2、3、4、5、6，则不可能的出栈次序是____",
        "A": "1、2、3、4、5、6",
        "B": "6、5、4、3、2、1",
        "C": "1、2、4、3、6、5",
        "D": "1、4、2、3、5、6、",
        "category": 1,
        "id": 167
    },
    {
        "question": "二叉查找树中不可能出现查找的序列是____",
        "A": "10、20、30、25",
        "B": "10、20、30、19",
        "C": "10、20、30、40",
        "D": "10、5、7、9",
        "category": 1,
        "id": 168
    },
    {
        "question": "在循环队列中，如果数组规模是size，front指向队头元素前一个单元，rear指向队尾元素，则队列长度是____",
        "A": "rear - front",
        "B": "(rear-front) % size",
        "C": "(rear-front + size)%size",
        "D": "(rear-front + 1 + size)%size",
        "category": 2,
        "id": 169
    },
    {
        "question": "考虑如下数组： 59，19，50，17，12，15，2，5，7，11，6，14，99。将其转变为最⼤堆⾄少需要多少次交换？",
        "A": "4",
        "B": "5",
        "C": "3",
        "D": "6",
        "category": 1,
        "id": 170
    },
    {
        "question": "关于⽤队头位置固定的顺序队列，以下说法正确的是____",
        "A": "只能⼊队不能出队",
        "B": "⼊队⼀定引起⼤量数据移动",
        "C": "出队操作的复杂度为O(1)",
        "D": "出队会引起⼤量数据移动",
        "category": 0,
        "id": 171
    },
    {
        "question": "在含有n个结点的⼆叉查找树中查找某个关键字的结点时，最多进⾏____次⽐较",
        "A": "log(2n)+1",
        "B": "log(n)/log(2)",
        "C": "n",
        "D": "n/2",
        "category": 1,
        "id": 172
    },
    {
        "question": "当⽤⼤⼩为N的数组存储循环队列，front指向的单元不存储数据元素，则该队列的最⼤⻓度为____",
        "A": "n+1",
        "B": "n-1",
        "C": "n-2",
        "D": "n",
        "category": 1,
        "id": 173
    },
    {
        "question": "含有20个结点的平衡⼆叉树的最⼤深度为____",
        "A": "5",
        "B": "6",
        "C": "7",
        "D": "4",
        "category": 1,
        "id": 174
    },
    {
        "question": "以下说法正确的是____",
        "A": "循环队列中，令front指向的单元不存储队列元素，判断队满的条件为(rear+1)%MaxSize==front",
        "B": "全对",
        "C": "全错",
        "D": "栈的操作为先进后出",
        "category": 0,
        "id": 175
    },
    {
        "question": "以下说法正确的是____",
        "A": "全对",
        "B": "进⾏出栈运算前应判断栈是否空",
        "C": "全错",
        "D": "栈的操作为先进后出",
        "category": 0,
        "id": 176
    },
    {
        "question": "以下说法正确的是____",
        "A": "全对",
        "B": "全错",
        "C": "栈是⼀种存储结构",
        "D": "栈的操作为先进后出",
        "category": 0,
        "id": 177
    },
    {
        "question": "⼀个栈的⼊栈顺序是1，2，3，4，则不可能的出栈序列是____？",
        "A": "4 3 1 2",
        "B": "1 4 3 2",
        "C": "1 2 4 3",
        "D": "2 1 4 3",
        "category": 1,
        "id": 178
    },
    {
        "question": "通过_____⽅法可以判断出⼀个有向图是否有环。",
        "A": "求节点的度",
        "B": "全错",
        "C": "求关键路径",
        "D": "拓扑排序",
        "category": 0,
        "id": 179
    },
    {
        "question": "通过_____⽅法可以判断出⼀个有向图是否有环。",
        "A": "求节点的度",
        "B": "深度优先遍历",
        "C": "求关键路径",
        "D": "全错",
        "category": 0,
        "id": 180
    },
    {
        "question": "对于⼀个有向图，若⼀个顶点的⼊度为K1，出度为K2，则对应邻接表中该顶点单链表中的结点数为____",
        "A": "K1+K2",
        "B": "K2",
        "C": "fabs(K1-K2)",
        "D": "K1",
        "category": 1,
        "id": 181
    },
    {
        "question": "给定如下基于数组的最⼤化堆： {75，72，59，63，48，15，43，61}，以下哪⼀个数组可以正确表示其删除两次根元素后的结果？",
        "A": "63，59，61，43，48，15",
        "B": "63，59，48，15，43，61",
        "C": "63，61，59，43，48，15",
        "D": "63，61，59，48，43，15",
        "category": 1,
        "id": 182
    },
    {
        "question": "已知有序表{3，7，12，21，54，57，65，76，87，90，92，94}，⽤⼆分查找在表中查找90，第3次⽐较的记录是____",
        "A": "76",
        "B": "87",
        "C": "90",
        "D": "92",
        "category": 1,
        "id": 183
    },
    {
        "question": "下⾯叙述中错误的是哪些选项？",
        "A": "全错",
        "B": "基数排序是⼀种稳定的排序⽅法",
        "C": "哈夫曼树是带权路径⻓度最短的树，路径上权值较⼤的结点离根较近",
        "D": "当从⼀个最⼩堆中删除⼀个元素时，需要把堆尾元素填补到堆顶位置，然后再按条件把它逐层向上调整到合适位置",
        "category": 0,
        "id": 184
    },
    {
        "question": "下⾯叙述中错误的是哪些选项？",
        "A": "拓扑排序是指结点值必须有序的排序",
        "B": "基数排序是⼀种稳定的排序⽅法",
        "C": "哈夫曼树是带权路径⻓度最短的树，路径上权值较⼤的结点离根较近",
        "D": "全错",
        "category": 0,
        "id": 185
    },
    {
        "question": "时间复杂度不受数据初始状态影响⽽恒为O(nlogn)的是____",
        "A": "冒泡排序",
        "B": "堆排序",
        "C": "希尔排序",
        "D": "快速排序",
        "category": 0,
        "id": 186
    },
    {
        "question": "有 1000 个⽆序的整数，希望使⽤最快的⽅式找出前 50 个最⼤的，最佳的选择是____",
        "A": "基数排序",
        "B": "冒泡排序",
        "C": "堆排序",
        "D": "快速排序",
        "category": 0,
        "id": 187
    },
    {
        "question": "在⼆叉查找树中进⾏查找的效率与____有关",
        "A": "被查找结点的度",
        "B": "⼆叉查找树的深度",
        "C": "⼆叉查找树的结点的个数",
        "D": "⼆叉查找树的存储结构",
        "category": 0,
        "id": 188
    },
    {
        "question": "下列关于遍历的描述，正确的是____",
        "A": "全错",
        "B": "由⼆叉树某种遍历⽅式产⽣的结果是⼀个线性序列",
        "C": "给定⼆叉树的某种遍历结果不能唯⼀确定这棵树，但由⼆叉树的两种遍历结果可以推导出这棵⼆叉树",
        "D": "由树的前序遍历和后序遍历，可以唯⼀确定这棵树",
        "category": 0,
        "id": 189
    },
    {
        "question": "下列关于遍历的描述，正确的是____",
        "A": "遍历既有递归算法，⼜有⾮递归算法",
        "B": "全错",
        "C": "给定⼆叉树的某种遍历结果不能唯⼀确定这棵树，但由⼆叉树的两种遍历结果可以推导出这棵⼆叉树",
        "D": "由树的前序遍历和后序遍历，可以唯⼀确定这棵树",
        "category": 0,
        "id": 190
    },
    {
        "question": "对线性表进⾏⼆分查找时，要求线性表必须____",
        "A": "以顺序⽅式存储，且结点按关键字有序存储",
        "B": "以顺序⽅式存储",
        "C": "以链接⽅式存储，且结点按关键字有序存储",
        "D": "以链接⽅式存储",
        "category": 0,
        "id": 191
    },
    {
        "question": "以下关于图的叙述中，正确的是____",
        "A": "强连通有向图的任何顶点到其他所有顶点都有弧",
        "B": "图的任意顶点的⼊度等于出度",
        "C": "有向图的边集的⼦集和顶点集的⼦集可构成原有向图的⼦图",
        "D": "有向完全图⼀定是强连通有向图",
        "category": 0,
        "id": 192
    },
    {
        "question": "已知两个⻓度为m和n的双链表，在使⽤现有链表结点空间的前提下，将⻓为n的链表合并到⻓为m的链表的后⾯，所需的时间复杂度是____",
        "A": "O(m+n)",
        "B": "O(m)",
        "C": "O(1)",
        "D": "O(n)",
        "category": 1,
        "id": 193
    },
    {
        "question": "下列关于散列表的说法中，正确的有____。I. 采⽤除留余数法时，数组的⻓度最好是素数。II. 散列查找中不需要任何关键字的⽐较。III. 散列表在查找成功时平均查找⻓度与表⻓有关IV. 若在散列表中删除⼀个元素，不能简单地将该元素删除。",
        "A": "I和IV",
        "B": "和III",
        "C": "IV",
        "D": "II和III",
        "category": 1,
        "id": 194
    },
    {
        "question": "后缀表达式9 2 3 * +10 2 / - 的值为____",
        "A": "23",
        "B": "17",
        "C": "10",
        "D": "20",
        "category": 1,
        "id": 195
    },
    {
        "question": "向⼀个有100个元素的顺序表中插⼊⼀个元素并保持原来顺序不变，在插⼊位置等概率分布的情况下，平均需要移动多少元素？",
        "A": "50",
        "B": "50.5",
        "C": "49.5",
        "D": "1",
        "category": 1,
        "id": 196
    },
    {
        "question": "下列关于⽆向连通图特性的叙述中，正确的是____。I. 所有顶点的度之和为偶数。II. 边数⼤于顶点个数减1。III. ⾄少有⼀个顶点的度为1",
        "A": "只有II",
        "B": "I和II",
        "C": "只有I",
        "D": "I和III",
        "category": 0,
        "id": 197
    },
    {
        "question": "下列关于B树和B+树的叙述中，错误的是____",
        "A": "B树和B+树都可以⽤于⽂件索引结构",
        "B": "B树和B+树都是平衡的多叉树",
        "C": "B树和B+树都能有效地⽀持随机查找",
        "D": "B树和B+树都能有效地⽀持顺序查找",
        "category": 0,
        "id": 198
    },
    {
        "question": "下列说法正确的是____",
        "A": "数据的逻辑结构唯⼀确定了其存储结构",
        "B": "数据的逻辑结构独⽴于其存储结构",
        "C": "数据结构仅由其逻辑结构和存储结构决定",
        "D": "全错",
        "category": 0,
        "id": 199
    },
    {
        "question": "将 7，8，9，2，3，5，6，4 顺序插⼊⼀棵初始为空的AVL树。下列句⼦中哪句是错的____",
        "A": "有2个结点的平衡因⼦为-1",
        "B": "2和5是兄弟",
        "C": "3是4的⽗结点",
        "D": "7 是根结点",
        "category": 0,
        "id": 200
    },
    {
        "question": "由度为2的哈夫曼树推⼴到度为3的哈夫曼树，A、 B、 C、 D、 E、 F、 G的权值分别是3、 12、 7、 4、2、 8、 11，则字符A在哈夫曼树的第____层（设根结点在第1层）。",
        "A": "3",
        "B": "2",
        "C": "4",
        "D": "5",
        "category": 1,
        "id": 201
    },
    {
        "question": "若从⽆向图的任意顶点出发进⾏⼀次深度优先搜索即可访问所有顶点，则该图⼀定是____",
        "A": "强连通图",
        "B": "有回路",
        "C": "⼀棵树",
        "D": "连通图",
        "category": 1,
        "id": 202
    },
    {
        "question": "⼀个算法的时间复杂度为(n^3+n^2*(log(n)/log(2))+8n)/n^2，⽤⼤O表示法为____",
        "A": "O(logn)",
        "B": "O(n^3)",
        "C": "O(n+logn+8/n)",
        "D": "O(n)",
        "category": 2,
        "id": 203
    },
    {
        "question": "按____遍历⼆叉查找树得到的是⼀个有序序列",
        "A": "前序",
        "B": "层次序",
        "C": "中序",
        "D": "后序",
        "category": 0,
        "id": 204
    },
    {
        "question": "在表⻓为N的顺序表中，删除结点最多需要移动的元素数据个数是____",
        "A": "N-1",
        "B": "N/2",
        "C": "N",
        "D": "1",
        "category": 1,
        "id": 205
    },
    {
        "question": "下列叙述中不正确的是____",
        "A": "堆排序的时间复杂度为O(nlogn)",
        "B": "堆排序的空间复杂度为O(1)",
        "C": "堆排序是⼀种稳定的排序算法",
        "D": "整个构建堆的时间复杂度为O(n)",
        "category": 0,
        "id": 206
    },
    {
        "question": "若哈夫曼编码的⻓度不超过4，并且已知其中两个字符的编码为0和100，则最多还可以编码____个字符。",
        "A": "7",
        "B": "3",
        "C": "5",
        "D": "6",
        "category": 1,
        "id": 207
    },
    {
        "question": "已知⼀棵⼆叉树的叶⼦结点在前序遍历中的相对次序是ABCDEF，则这些结点在后序遍历中的相对次序是____",
        "A": "ABCFED",
        "B": "⽆法确定",
        "C": "FEDCBA",
        "D": "ABCDEF",
        "category": 1,
        "id": 208
    },
    {
        "question": "栈的插⼊和删除操作在____",
        "A": "栈顶",
        "B": "栈中",
        "C": "栈底",
        "D": "任意位置",
        "category": 0,
        "id": 209
    },
    {
        "question": "设栈S 和队列Q 的初始状态为空，元素e1，e2，e3，e4，e5和e6依次通过栈S，⼀个元素出栈后即进队列Q，若6 个元素出队的序列是e2，e4，e3，e6，e5，e1则栈S的容量⾄少应该是____",
        "A": "5",
        "B": "3",
        "C": "2",
        "D": "4",
        "category": 1,
        "id": 210
    },
    {
        "question": "给定初始待排序列{ 15，9，7，8，20，-1，4 }。如果希尔排序第⼀趟结束后得到序列为{ 15，-1，4，8，20，9，7 }，则该趟增量为____",
        "A": "2",
        "B": "4",
        "C": "3",
        "D": "1",
        "category": 1,
        "id": 211
    },
    {
        "question": "在⼀棵⾮空⼆叉树的中序遍历序列中，某个结点的相邻结点不可能是____",
        "A": "它右⼦树上的最左结点",
        "B": "它左⼦树上的最右结点",
        "C": "它的兄弟结点",
        "D": "它的⽗结点",
        "category": 0,
        "id": 212
    },
    {
        "question": "设森林F对应的⼆叉树为B，它有m+1个结点，B的根为p，p的右⼦树结点个数为n，森林F中第⼀棵树的结点个数是多少？",
        "A": "m-n",
        "B": "条件不⾜，⽆法确定",
        "C": "m-n+1",
        "D": "n+1",
        "category": 1,
        "id": 213
    },
    {
        "question": "双链表相对单链表的优点有____",
        "A": "全错",
        "B": "可以直接获得链表中指定结点的直接前驱",
        "C": "具有更优的空间复杂度",
        "D": "可以直接获得链表中指定结点的直接后继",
        "category": 0,
        "id": 214
    },
    {
        "question": "双链表相对单链表的优点有____",
        "A": "更快的从终端结点开始逆序访问到起始结点",
        "B": "全错",
        "C": "具有更优的空间复杂度",
        "D": "可以直接获得链表中指定结点的直接后继",
        "category": 0,
        "id": 215
    },
    {
        "question": "⾮空循环链表head的尾结点tail满⾜以下条件____",
        "A": "tail==NULL;",
        "B": "tail->next==head;",
        "C": "tail->next==NULL;",
        "D": "head->next==tail;",
        "category": 2,
        "id": 216
    },
    {
        "question": "下列哪种树的中序遍历序列是有序的？____",
        "A": "AVL树",
        "B": "二叉树",
        "C": "堆",
        "D": "哈夫曼树",
        "category": 0,
        "id": 217
    },
    {
        "question": "下列哪种树的中序遍历序列是有序的？____",
        "A": "全错",
        "B": "⼆叉查找树",
        "C": "堆",
        "D": "哈夫曼树",
        "category": 0,
        "id": 218
    },
    {
        "question": "以下代码的算法复杂度是____？\ncount=0;for(k=1; k<=n; k*=2)for(j=1; j<=n; j++)count++;",
        "A": "O(n^2)",
        "B": "O(nlogn)",
        "C": "O(n^3)",
        "D": "O(log(n)/LOG(2))",
        "category": 2,
        "id": 219
    },
    {
        "question": "在常⽤的描述⼆叉查找树的存储结构中，关键字值最⼤的结点____",
        "A": "左指针⼀定为空",
        "B": "右指针⼀定为空",
        "C": "左右指针均不为空",
        "D": "左右指针均为空",
        "category": 0,
        "id": 220
    },
    {
        "question": "当采⽤分块查找时，数据的组织⽅式要求____",
        "A": "数据分为若⼲块，每块内数据有序，且块间也必须有序",
        "B": "数据分为若⼲块，每块中的数据个数必须相同",
        "C": "数据分为若⼲块，每块内数据有序，但块间不必有序",
        "D": "数据分为若⼲块，每块内数据不必有序，但块间必须有序",
        "category": 0,
        "id": 221
    },
    {
        "question": "给定⼀个⾜够⼤的空栈，有4个元素的进栈次序为A、 B、 C、 D，则以CD开头的栈序列的个数为____",
        "A": "1",
        "B": "3",
        "C": "2",
        "D": "4",
        "category": 1,
        "id": 222
    },
    {
        "question": "考虑⼀个最⼩堆，其所有结点的元素排序后恰好为{1，2，...，1024}。记根结点的深度为1，则整数9在堆中的最⼤深度可能是多少？",
        "A": "9",
        "B": "10",
        "C": "4",
        "D": "2",
        "category": 1,
        "id": 223
    },
    {
        "question": "某⼆叉树的前序遍历序列是ABDCEF，中序遍历序列是BDAECF，则该⼆叉树对应的森林包括____棵树。",
        "A": "3",
        "B": "2",
        "C": "4",
        "D": "1",
        "category": 1,
        "id": 224
    },
    {
        "question": "下⾯四种排序中____是稳定的",
        "A": "冒泡排序",
        "B": "全错",
        "C": "快速排序",
        "D": "归并排序",
        "category": 0,
        "id": 225
    },
    {
        "question": "下⾯四种排序中____是稳定的",
        "A": "全错",
        "B": "希尔排序",
        "C": "快速排序",
        "D": "归并排序",
        "category": 0,
        "id": 226
    },
    {
        "question": "从空树开始，依次插⼊元素52，26，14，32，71，60，93，58，24和41后构成了⼀棵⼆叉查找树。在该树查找60要进⾏的⽐较次数是____",
        "A": "4",
        "B": "5",
        "C": "3",
        "D": "6",
        "category": 1,
        "id": 227
    },
    {
        "question": "下列关于m阶B树的说法中，错误的是____",
        "A": "所有叶结点都在同⼀层次上",
        "B": "⾮叶节点⾄少有m/2（m为偶数）或（m+1） /2（m为奇数）棵⼦树",
        "C": "根结点中的数据是有序的",
        "D": "根结点⾄多有m棵⼦树",
        "category": 1,
        "id": 228
    },
    {
        "question": "若⼀个算法的时间复杂度为O(n)，其中n的含义是____",
        "A": "问题规模",
        "B": "循环层数",
        "C": "语句条数",
        "D": "函数数量",
        "category": 0,
        "id": 229
    },
    {
        "question": "若已知⼀队列⽤单链表表示，该单链表的当前状态（含3个元素）是： 1->2->3，其中x->y表示x的下⼀节点是y。此时，如果将元素4⼊队，然后队列出队，则单链表的状态是____",
        "A": "2->3->4",
        "B": "答案不唯⼀",
        "C": "1->2->3",
        "D": "4->2->1",
        "category": 1,
        "id": 230
    },
    {
        "question": "以下关于双向链表的描述错误的是____",
        "A": "双向链表便于插⼊和删除",
        "B": "双向链表指针可以前后两个⽅向移动",
        "C": "双向链表和单向链表占⽤同样的存储空间",
        "D": "双向链表不必占⽤连续的存储空间",
        "category": 0,
        "id": 231
    },
    {
        "question": "前序遍历序列为1、 2、 3的不同⼆叉树个数为____",
        "A": "5",
        "B": "3",
        "C": "4",
        "D": "6",
        "category": 1,
        "id": 232
    },
    {
        "question": "下述编码中哪⼀个不是前缀码____",
        "A": "（0，10，110，111）",
        "B": "（0，1，00，11）",
        "C": "（00，01，10，11）",
        "D": "（1，01，000，001",
        "category": 0,
        "id": 233
    },
    {
        "question": "图的⼴度优先⽣成树的树⾼⽐深度优先⽣成树的树⾼____",
        "A": "⼩",
        "B": "⼩或相等",
        "C": "⼤",
        "D": "⼤或相等",
        "category": 0,
        "id": 234
    },
    {
        "question": "在含有n个顶点和e条边的⽆向图的邻接矩阵中，零元素的个数为____",
        "A": "2e",
        "B": "n^2-e",
        "C": "n^2-2e",
        "D": "e",
        "category": 1,
        "id": 235
    },
    {
        "question": "⼀棵深度为k的AVL树，其每个分⽀结点的平衡因⼦均为0，则该平衡⼆叉树共有____个结点",
        "A": "2^(k-1)-1",
        "B": "2^k-1",
        "C": "2^k",
        "D": "2^(k-1)+1",
        "category": 1,
        "id": 236
    },
    {
        "question": "下列说法中正确的是_____。",
        "A": "从源点到终点的最短路径是唯⼀的。",
        "B": "对有向图G，如果以任⼀顶点出发进⾏⼀次深度优先或⼴度优先搜索能访问到每个顶点，则该图⼀定是完全图。",
        "C": "拓扑排序是按 AOE ⽹中每个结点事件的最早发⽣时间对结点进⾏排序。",
        "D": "⼀个有向图的拓扑序列中若顶点a在顶点b之前，则图中必有⼀条弧<a,b>。",
        "category": 0,
        "id": 237
    },
    {
        "question": "设在磁盘上存放有375000个记录，做5路平衡归并排序，内存⼯作区能容纳600个记录，为把所有记录排好序，需要做____趟平衡归并。",
        "A": "3",
        "B": "4",
        "C": "5",
        "D": "6",
        "category": 1,
        "id": 238
    },
    {
        "question": "AVL树是⼀种平衡的⼆叉查找树，树中任⼀结点具有下列哪⼀特性____",
        "A": "左、右⼦树的⾼度均相同",
        "B": "左、右⼦树⾼度差的绝对值不超过1",
        "C": "左⼦树的⾼度均⼤于右⼦树的⾼度",
        "D": "左⼦树的⾼度均⼩于右⼦树的⾼度",
        "category": 0,
        "id": 239
    },
    {
        "question": "⼀棵⼆叉树有n个结点，在该树的⼆叉链表存储表示中，空指针字段的个数是____",
        "A": "n-1",
        "B": "n+1",
        "C": "n",
        "D": "2n",
        "category": 1,
        "id": 240
    },
    {
        "question": "下⾯四种排序中____的空间复杂度最⾼",
        "A": "堆排序",
        "B": "归并排序",
        "C": "冒泡排序",
        "D": "插⼊排序",
        "category": 0,
        "id": 241
    },
    {
        "question": "在存储数据的时候，不仅要存储各元素的值，还要存储____",
        "A": "数据元素的类型",
        "B": "数据的操作⽅法",
        "C": "数据元素之间的关系",
        "D": "全错",
        "category": 0,
        "id": 242
    },
    {
        "question": "B+树不同于B树的特点之⼀是____",
        "A": "结点中含有关键字",
        "B": "根结点⾄少有两个分⽀",
        "C": "所有叶结点都在同⼀层上",
        "D": "能⽀持顺序查找",
        "category": 0,
        "id": 243
    },
    {
        "question": "将5个数据进⾏排序，最多需要⽐较____次",
        "A": "5",
        "B": "10",
        "C": "20",
        "D": "25",
        "category": 1,
        "id": 244
    },
    {
        "question": "⼀趟排序结束后不⼀定能够选出⼀个元素放在其最终位置上的是____",
        "A": "堆排序",
        "B": "冒泡排序",
        "C": "希尔排序",
        "D": "快速排序",
        "category": 0,
        "id": 245
    },
    {
        "question": "对n个不同的数进⾏从⼩到⼤的排序，冒泡排序在下列哪种情况⽐较的次数最多____",
        "A": "从⼤到⼩排好的",
        "B": "从⼩到⼤排好的",
        "C": "元素⽆序",
        "D": "元素基本有序",
        "category": 0,
        "id": 246
    },
    {
        "question": "下列关于图遍历的说法不正确的是____。",
        "A": "全错",
        "B": "若从⼀个⽆向图中任⼀顶点出发，进⾏了⼀次深度优先遍历，就可以访问图中所有的顶点，则该图⼀定是连通的。",
        "C": "图的⼴度优先遍历是⼀个递归过程。",
        "D": "图的深度优先搜索中⼀般要采⽤队列来暂存刚访问过的顶点。",
        "category": 0,
        "id": 247
    },
    {
        "question": "下列关于图遍历的说法不正确的是____。",
        "A": "⼀个图的⼴度优先搜索树是唯⼀的。",
        "B": "若从⼀个⽆向图中任⼀顶点出发，进⾏了⼀次深度优先遍历，就可以访问图中所有的顶点，则该图⼀定是连通的。",
        "C": "全错",
        "D": "图的深度优先搜索中⼀般要采⽤队列来暂存刚访问过的顶点。",
        "category": 0,
        "id": 248
    },
    {
        "question": "设⼀组初始记录关键字序列为(345，53，67，9，62)，则⽤基数排序需要进⾏____趟的分配和回收才能使得初始关键字序列变成有序序列",
        "A": "1",
        "B": "4",
        "C": "3",
        "D": "2",
        "category": 1,
        "id": 249
    }
]