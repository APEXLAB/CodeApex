[
    {
        "id": 2195,
        "problem_description": "康托是一名数学家，他证明了一个重要的定理，需要使用一张表：\n1/1        1/2        1/3        1/4        1/5        ...\n2/1        2/2        2/3        2/4        2/5        ...\n3/1        3/2        3/3        3/4        3/5        ...\n4/1        4/2        4/3        4/4        4/5        ...\n5/1        5/2        5/3        5/4        5/5        ...\n...        ...        ...        ...        ...        ...\n这个表的规律是：从上到下：每一行的分子依次增大；从左到右：每一列的分母依次增大。康托以一种不重复、不遗漏的方式，将表上所有数字列举了出来。方法如下：从左上角的1/1出发， Z 字形扫描，其中：第一项是1/1，第二项是1/2，第三项是2/1，第四项是3/1，第五项是2/2，第六项是1/3，接下来几项分别是：1/4, 2/3, 3/2, 4/1, 5/1, 4/2, ...给定一个分数 $a/b$，请计算该分数在康托表中排名第几。",
        "function_declaration": "int calculate_ans(int a, int b)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tint a, b;\n\tcin >> a >> b;\n\t// calling start\n\tint result = calculate_ans(a, b);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"2 4\", \"output\": \"14\"}, {\"input\": \"1 4\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1748,
        "problem_description": "给定一张无向图，起点为1，请你找出所有可能到达的点。输入两个整数n，m (1 ≤ n ≤ 10^5 , 1 ≤ m ≤ 5*10^5)，分别表示地图上的点数和边数。接下来m对整数表示每条无向边连接的两个点。返回从小到大排列的能够到达的点的编号（不包括起点1）。",
        "function_declaration": "vector<int> findReachablePoints(int n, int m, vector<pair<int, int>>& edges)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n, m;\n    cin>>n>>m;\n    \n    vector<pair<int, int>> edges;\n    for(int i=0; i<m; i++){\n        int u, v;\n        cin>>u>>v;\n        edges.push_back({u, v});\n    }\n    \n    // calling start\n    vector<int> result = findReachablePoints(n, m, edges);\n    // calling end\n    \n    for(auto point : result){\n        cout<<point<<\" \";\n    }\n}",
        "example": "[{\"input\": \"5 4\\n1 2\\n1 3\\n2 3\\n4 5\", \"output\": \"2 3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1789,
        "problem_description": "将某一个输入的位数不确定的正整数按照标准的三位分节格式输出，例如，当用户输入82668634时，程序应该输出82,668,634。",
        "function_declaration": "int formatNumber(int n, char a[])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    char a[20];\n    cin >> n;\n    //calling start\n    int i = formatNumber(n, a);\n    //calling end\n    do {\n        i--;\n        cout << a[i];\n    } while (i > 0);\n    cout << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"82668634\", \"output\": \"82,668,634\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1739,
        "problem_description": "现有一个整数序列，请从其中选出一半的数字，使他们的和最大但不超过所有数字和的3/4。返回一个整数表示按题目条件选取数字的和。",
        "function_declaration": "int calculateHalfSum(vector<int> nums)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> nums(n);\n    for(int i = 0; i < n; i++){\n        cin>>nums[i];\n    }\n    // calling start\n    int result = calculateHalfSum(nums);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"4\\n1 2 3 4\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1496,
        "problem_description": "输入两个大整数a和b，计算a - b的结果，其中数据保证0 < b < a < 10^500。",
        "function_declaration": "string subtract(string a, string b)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    string a, b;\n    cin>>a>>b;\n    // calling start\n    string result = subtract(a, b);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"10000 9990\", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1588,
        "problem_description": "给定一个长度为N（N<=1000）的数列，去除序列中值为X的数字后，按照输入顺序输出，每个整数之间用一个空格隔开。",
        "function_declaration": "void printNumsExceptX(int n, int nums[], int x)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, x;\n    int nums[1001];\n    \n    cin >> n;\n    \n    for (int i=0; i<n; i++)\n        cin >> nums[i];\n    \n    cin >> x;\n    \n    // calling start\n    printNumsExceptX(n, nums, x);\n    // calling end\n    \n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 2 3 2 3\\n2\", \"output\": \"1 3 3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1820,
        "problem_description": "输入n(n≤10^6)个不超过10^9的单调不减的（就是后面的数字不小于前面的数字）非负整数a_1, a_2, ..., a_n，然后进行m(m≤10^5)次询问。对于每次询问，给出一个整数q(q≤10^9)，要求输出序列中第一个大于该数的位置下标。如果没有这样的位置，请输出-1。",
        "function_declaration": "vector<int> findFirstGreaterPositions(int n, int m, const vector<int>& sequence, const vector<int>& queries)\n",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> sequence(n);\n    for (int i = 0; i < n; i++) {\n        cin >> sequence[i];\n    }\n\n    vector<int> queries(m);\n    for (int i = 0; i < m; i++) {\n        cin >> queries[i];\n    }\n\n    //calling start\n    vector<int> results = findFirstGreaterPositions(n, m, sequence, queries);\n    //calling end\n\n    for (int i = 0; i < m; i++) {\n        cout << results[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"11 3\\n1 3 3 3 5 7 9 11 13 15 15\\n1 3 20\", \"output\": \"2 5 -1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1717,
        "problem_description": "输出自然数1到n所有不重复的排列，即n的全排列，要求所产生的任一数字序列中不允许出现重复的数字。输入n (1<=n<=9)。输出由 1~n 组成的所有不重复的数字序列，每行一个序列。",
        "function_declaration": "void generateUniquePermutations(int n)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to generate all unique permutations of 1 to n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    //calling start\n    generateUniquePermutations(n);\n    //calling end\n    \n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"123\\n132\\n213\\n231\\n312\\n321\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2218,
        "problem_description": "输入一串字符，请判断它是否可以成为一个浮点数的合法表示。浮点数的表示需要满足以下格式：可以有-或+，也可以没有，但最多只有一个，且必须出现在第一个字符；可以有小数点，也可以没有小数点，但最多只有一个小数点；整数部分可以省略、小数部分也可以省略、但不能同时省略。",
        "function_declaration": "bool isValidFloat(const string& s) ",
        "code_context": "#include <iostream>\n#include <string>\nusing namespace std;\n\n//function start\n//function end\n\nint main() {\n    string input;\n    cin >> input;\n    //calling start\n    bool isValid = isValidFloat(input);\n    //calling end\n    if (isValid) {\n        cout << \"Valid\" << endl;\n    } else {\n        cout << \"Invalid\" << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"+3.1415926\", \"output\": \"Valid\"}, {\"input\": \"1.0e10\", \"output\": \"Invalid\"}, {\"input\": \"-25.\", \"output\": \"Valid\"}, {\"input\": \".\", \"output\": \"Invalid\"}, {\"input\": \"-.\", \"output\": \"Invalid\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1682,
        "problem_description": "输入一个自然数，输出它的倒序数。",
        "function_declaration": "void reverse_number(int n, string &result)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin >> n;\n    // calling start\n    string result = \"\";\n    reverse_number(n, result);\n    cout << result;\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"1234\", \"output\": \"4321\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2286,
        "problem_description": "在金融市场上，经常需要统计一只股票的最大回撤。最大回撤是指投资者在某天买入，在之后的某天卖出，可能造成的最大亏损，它可以反应一只股票在历史上的最坏表现。给定一个整数序列 $a_1,a_2,a_3,...,a_n$，每个 $a_i$ 表示同一只股票的在某一天的价格，请计算这只股票的最大回撤。即寻找两个下标满足 $1≤i≤j≤n$，且 $a_i-a_j$ 最大。",
        "function_declaration": "int maxDrawdown(vector<int>& prices)",
        "code_context": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the maximum drawdown of a stock\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> prices(n);\n    for (int i = 0; i < n; i++) {\n        cin >> prices[i];\n    }\n\n    // Calculate the maximum drawdown of the stock\n    //calling start\n    int result = maxDrawdown(prices);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n2 3 7 6 1 \", \"output\": \"6\"}, {\"input\": \"5\\n1 2 3 4 5\", \"output\": \"0\"}, {\"input\": \"5\\n1 10 100 10 -100\", \"output\": \"200\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2196,
        "problem_description": "小爱想用*打出一个大写的K。例如 $n=3$ 时，输出\n**  ***\n** **\n***\n***\n** *\n**  **\n**   ***\n给定一个整数 $n$ 表示字形的大小。请输出一个由星号组成的，对应大小的 K 字形图案。该字形由 $2n+1$ 行组成，第一笔竖线固定占两列，第二笔折线会根据参数 $n$ 适当调整粗细，具体请参考样例。",
        "function_declaration": "void printPattern(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n    // calling start\n    printPattern(n);\n    // calling end\n}",
        "example": "[{\"input\": \"5\", \"output\": \"**     *****\\n**    ****\\n**   ***\\n**  **\\n** *\\n***\\n** *\\n**  **\\n**   ***\\n**    ****\\n**     *****\"}, {\"input\": \"7\", \"output\": \"**       *******\\n**      ******\\n**     *****\\n**    ****\\n**   ***\\n**  **\\n** *\\n***\\n** *\\n**  **\\n**   ***\\n**    ****\\n**     *****\\n**      ******\\n**       *******\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2163,
        "problem_description": "疫情期间，口罩成了必需品。小爱是从某个 周三 开始戴口罩的，她每天都需要消耗1枚口罩。在每个周一，社区会赠送7枚口罩，在每个周二，学校会赠送7枚口罩。在疫情出现之前，小爱有10只口罩，直到有一天，疫情结束了，小爱不用再带戴口罩了，此时她还剩下$n$只口罩。请问她一共带了多少天的口罩呢？",
        "function_declaration": "int calculateDays(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\t// calling start\n\tint result = calculateDays(n);\n\t// calling end\n\t\n\tcout << result;\n}",
        "example": "[{\"input\": \"17\", \"output\": \"7\"}, {\"input\": \"23\", \"output\": \"15\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2240,
        "problem_description": "幻方是一种很神奇的 $N\\times N$ 矩阵：它由数字 $1,2,3,\\cdots \\cdots ,N \\times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。当 $N$ 为奇数时，我们可以通过下方法构建一个幻方：首先将 $1$ 写在第一行的中间。之后，按如下方式从小到大依次填写每个数 $K (K=2,3,\\cdots,N \\times N)$ ：1. 若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列；2. 若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行；3. 若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方；4. 若 $(K-1)$ 既不在第一行，也不在最后一列，如果 $(K-1)$ 的右上方还未填数，则将 $K$ 填在 $(K-1)$ 的右上方，否则将 $K$ 填在 $(K-1)$ 的正下方。现给定 $N$ ，请按上述方法构造 $N \\times N$ 的幻方，输出共 $N$ 行，每行 $N$ 个整数，即按上述方法构造出的 $N \\times N$ 的幻方，相邻两个整数之间用单空格隔开。",
        "function_declaration": "void generateMagicSquare(int N)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int N;\n    cin >> N;\n    //calling start\n    generateMagicSquare(N);\n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"8 1 6\\n3 5 7\\n4 9 2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1964,
        "problem_description": "给定 4 个正整数 a,b,c,d，计算表达式 (a*b*c)%d 的值，其中%为取模运算。",
        "function_declaration": "int calculate_remainder(int a, int b, int c, int d)",
        "code_context": "#include<cstdio>\n\n// function start\n\n// function end\n\nint main(){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    // calling start\n    int result = calculate_remainder(a, b, c, d);\n    // calling end\n    printf(\"%d\", result);\n}",
        "example": "[{\"input\": \"2 3 4 5\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2340,
        "problem_description": "在翻阅字典的时候，我们往往不能一次性翻到我们想要的单词。这个时候，我们会将当前单词与我们要查阅的单词，进行比较。如果我们要查阅的单词的字母顺序，在当前单词的后面，那么我们会往后翻。反之同理。直到我们找到我们要查阅的单词。事实上，对于任何排好序的结构，我们都可以采用类似地方法进行元素查找。例如，对于一个排好序的数组，若我们想知道某个元素所在的下标，我们可以先查询其最中间那个元素，通过其来判断是要往前还是往后找，缩小搜索范围，从而高效地找到该元素。现在，给定了一个排好序的数组。再给你一个整数，请按照上述方法，借助函数，求助该整数在数组中的下标。输入第一行一个正整数 n，表示数列的长度。第二行 n 个正整数，表示一个排序过的数列。第三行一个正整数 q。保证所有输入整数不超过 1000。输出q 在数列中的下标 (认为第一个元素下标为 1)。",
        "function_declaration": "int binarySearch(const vector<int>& sortedArray, int q) ",
        "code_context": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform binary search and find the index of q in the array\n// Returns -1 if q is not found in the array\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> sortedArray(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> sortedArray[i];\n    }\n\n    int q;\n    cin >> q;\n\n    //calling start\n    int index = binarySearch(sortedArray, q);\n    //calling end\n\n    cout << index << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n1 14 51 41 91 1810\\n91\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2080,
        "problem_description": "写一个程序用于处理分数a/b化为小数后，小数点后第n位的数字是多少。",
        "function_declaration": "int calculateRemainder(int a, int b, int n)",
        "code_context": "#include<iostream>\nusing namespace std;\nint a,b,n;\n\n// function start\n\n// function end\n\nint main()\n{\n    cin >> a >> b >> n;\n    // calling start\n    int result = calculateRemainder(a, b, n);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"1 2 1\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1972,
        "problem_description": "这是一个简单的判断闰年的题目。（不需要研究儒略历）你只需要判断给定的年份在公元纪年法下是不是闰年就可以啦。",
        "function_declaration": "bool isLeapYear(int n)",
        "code_context": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    // calling start\n    bool result = isLeapYear(n);\n    // calling end\n    if (result) cout<<\"yes\" << endl;\n    else cout << \"no\" << endl;\n}",
        "example": "[{\"input\": \"2020\", \"output\": \"yes\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2139,
        "problem_description": "给定 n 个非负整数，输出最大的数。小A觉得这道题过于简单，于是决定增加一点难度。小A会进行 m 次修改操作，每次给定两个正整数 l,r，表示将第 l 个到第 r 个数全部加一。最后，你需要输出小A做完所有修改操作后，n 个数中最大的数。输入共 m+2 行，第一行两个正整数 n,m，第二行 n 个非负整数。接下来 m 行，每行两个正整数 l,r（$l \\le r$）。对于 40% 的数据，$n,m \\le 1000$；对于 100% 的数据，$n,m \\le 200000$，输入的所有数均不大于200000。输出一个数，表示答案。输出一个数，表示答案。",
        "function_declaration": "int findMaxAfterModifications(int n, int m, vector<int>& nums)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to find the maximum number after modifications\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    // Call the function to find the maximum number after modifications\n    //calling start\n    int result = findMaxAfterModifications(n, m, nums);\n    //calling end\n\n    // Output the result\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"10 3\\n1 8 3 4 8 0 7 1 9 3\\n1 6\\n5 8\\n10 10\", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2313,
        "problem_description": "给定一个数轴上的 $n$ 个闭区间，第 $i$ 个闭区间的两端点为 $[a_i,b_i]$，它们的并集可以表示为若干不相交的闭区间，请按照左端点从小到大的顺序输出这些区间的并集。",
        "function_declaration": "pair<int, int> process_intervals(pair<int, int> a[], int n)",
        "code_context": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n//function start\n\n\n//function end\n\nint main()\n{\n    int n;\n    cin >> n;\n    using interval = pair<int, int>;\n    interval a[100000];\n    for (int i = 0; i < n; ++i)\n        cin >> a[i].first >> a[i].second;\n    //calling start\n    process_intervals(a, n);\n    //calling end\n}",
        "example": "[{\"input\": \"3\\n10 12\\n1 3\\n2 5\", \"output\": \"1 5\\n10 12\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2322,
        "problem_description": "给定一个长度为 $k$ 的数列 $x_1,x_2,...,x_k$ 作为一个起始值，然后从第 $k+1$ 项开始，无限地延展这个序列，延展后数列 $x_i$ 的定义如下：$$x_i=x_{i-1}⊕x_{i-2}⊕...⊕x_{i-k}$$，这其中 ⊕ 是将两个数字二进制编码后进行异或操作的意思。给定 $q$ 个询问，每个询问都带有一组参数 $l$,$r$，请计算并输出$$x_l⊕x_{l+1}⊕...⊕x_r$$的值。",
        "function_declaration": "int computeXOR(vector<int>& nums, int l, int r)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to compute the XOR of elements in the range [l, r]\n//function start\n\n//function end\n\nint main() {\n    int k;\n    cin >> k;\n\n    vector<int> nums(k);\n    for (int i = 0; i < k; i++) {\n        cin >> nums[i];\n    }\n\n    int q;\n    cin >> q;\n\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        cin >> l >> r;\n\n        // Calling the function to compute the XOR of elements in the range [l, r]\n        //calling start\n        int result = computeXOR(nums, l - 1, r - 1);\n        //calling end\n\n        cout << result << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"4\\n1 3 5 7\\n3\\n2 2\\n2 5\\n1 5\", \"output\": \"3\\n1\\n0\"}, {\"input\": \"5\\n3 3 4 3 2\\n4\\n1 2\\n1 3\\n5 6\\n7 9\", \"output\": \"0\\n4\\n7\\n4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1776,
        "problem_description": "有些人很迷信数字，比如认为带 4 的数不吉利。某抽奖活动的奖券号码是 5 位数 (10000-99999)，要求其中不要出现带“4”的号码，主办方想让你计算一下，如果发行号码 n 到 m 之间的奖券，在任何两张奖券都不重复的情况下，可以发行多少张？",
        "function_declaration": "int countNumbersWithoutFour(int n, int m)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n, m = 0;\n    cin >> n >> m;\n    // calling start\n    int result = countNumbersWithoutFour(n, m);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"10000 99999\", \"output\": \"52488\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1841,
        "problem_description": "集合的前N个元素：编一个程序，按递增次序生成集合M的最小的N个数，M的定义如下：数1属于M；如果X属于M，则Y=2x+1和Z=3x+1也属于M；此外再没有别的数属于M。",
        "function_declaration": "set<int> generateSet(int N)",
        "code_context": "#include <iostream>\n#include <set>\n#include <queue>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int N;\n    cin >> N;\n\n    //calling start\n    set<int> M = generateSet(N);\n    //calling end\n\n    for (auto num : M) {\n        cout << num << \" \";\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"10\", \"output\": \"1 3 4 7 9 10 13 15 19 21\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2039,
        "problem_description": "小万、小橙、小王三个同学在玩游戏。地上画了一行格子，一开始他们各自站在一个格子上。格子从左到右依次编号为1,2,3,……他们按照小万、小橙、小王、小万……的顺序依次行动。轮到一个人行动时，他会跑到另外两个人的正中间的格子上。因为地上是一格一格的，所以规则中，“正中间“指的是另外两人的格子编号的和除以二后向下取整。当某次跳跃完成后，有两个人要站在同一个格子上，则游戏结束。小橙想知道他们三个人一共需要跳跃多少次。a,b,c 依次表示小万、小橙、小王所在的格子的编号",
        "function_declaration": "int calculateTurns(int a, int b, int c)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint a = 0, b = 0, c = 0;\n\tcin >> a >> b >> c;\n\t// calling start\n\tint count = calculateTurns(a, b, c);\n\t// calling end\n\tcout << count << endl;\n\treturn 0;\n}",
        "example": "[{\"input\": \"1 3 10\\n\", \"output\": \"4\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2244,
        "problem_description": "输入两个整数，输出乘积。",
        "function_declaration": "long long multiply(long long a, long long b)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    long long a,b;\n    cin>>a>>b;\n    // calling start\n    long long result = multiply(a, b);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"2 3\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1757,
        "problem_description": "我们要使用“YES”字符串，构造字符串矩形。输入1，构造出的字符串矩形的每一行有1个“YES”；输入2，构造出的字符串矩形的每一行有2个“YES”…请你根据输入的数字，构造出“YES”字符串矩形，且字符串矩形的行数和列数（字符个数）是相等的。输入一个正整数N（N<=20），表示一共有N组数据，接着是包含N个数据的数组，每个数据是一个正整数M（M<=50），表示一行内有M个“YES”相连。输出指定的字符串矩形。",
        "function_declaration": "void printYesRectangle(int N, int arr[])",
        "code_context": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// Function to print the \"YES\" string rectangle\n//function start\n\n//function end\n\nint main() {\n    int N;\n    cin >> N;\n\n    int arr[N];\n    for (int i = 0; i < N; ++i) {\n        cin >> arr[i];\n    }\n\n    // Calling the function to print the string rectangle\n    //calling start\n    printYesRectangle(N, arr);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"2\\n1\\n2\", \"output\": \"YES\\nYES\\nYES\\nYESYES\\nYESYES\\nYESYES\\nYESYES\\nYESYES\\nYESYES\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1892,
        "problem_description": "请用while循环输出3次biu。",
        "function_declaration": "void printBiu(int num)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int num = 3;        \n  // calling start\n  printBiu(num);\n  // calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"biu\\nbiu\\nbiu\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2078,
        "problem_description": "Dark 教授听说你学过了字符串，决定考你一道相关的题目。她现在给你一串字符串，请你将其反转过来输出。",
        "function_declaration": "void reversePrint(char* name, int len)",
        "code_context": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    char name[200 + 1]; // 注意，有一位留给 '\\0'\n    cin >> name;\n    // calling start\n    reversePrint(name);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"Hello!\", \"output\": \"!olleH\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1899,
        "problem_description": "水仙花数是指一个3位数，它的每一位数的立方之和等于这个数本身。例如153，1X1X1+5X5X5+3X3X3=1+125+27=153，则153是水仙花数。请你找出100～999中所有的水仙花数。思路：因为水仙花数是3位数，因此，我们知道水仙花数的范围一定是在100~999之间，把所有的三位数都列举出来，for(int i=100;i<=999;i++)，然后一个一个地判断 i 有没有满足各位三次方之和等于本身的数，符合条件的就把它打印出来。注意：因为每个三位的整数都要判断一遍个位、十位、百位是否满足条件，所以将gw、sw、bw的计算放在循环体中。int gw, sw, bw;\nfor (i从100～999){\n    算出i的个位;\n    算出i的十位;\n    算出i的百位;\n    if (个位*个位*个位 + 十位*十位*十位 + 百位*百位*百位 == i)\n       输出i;\n}",
        "function_declaration": "bool isArmstrong(int i)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    // calling start\n    for(int i = 100; i <= 999; i++){\n        if (isArmstrong(i))\n            cout << i << \" \";\n    }\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \" \", \"output\": \"153 370 371 407\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2246,
        "problem_description": "回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数，例如121、9889。如果一个数是回文数，并且又是质数，我们就称其为回文质数。给定一个正整数 n，找到不小于 n 的最小回文质数。",
        "function_declaration": "long long findPalindromePrime(long long n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    long long n;\n    cin>>n;\n    // calling start\n    long long result = findPalindromePrime(n);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"9\", \"output\": \"11\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2294,
        "problem_description": "给定 $n$ 个整数 $a_1,a_2,...,a_n$，它们组成了一个圆环。请在这个圆环上，找出一段连续的区间，使得这段区间的数字之和达到最大，返回最大的子区间之和，输出最大的子区间之和。空集和圆环本身都可以算圆环的子区间。由于是圆环，$a_n$ 和 $a_1$ 也被视作是相邻的。",
        "function_declaration": "long long maxCircularSum(int nums[], int n)",
        "code_context": "#include<iostream>\nusing namespace std;\nint a[100001];\n//function start\n\n\n//function end\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n    }\n\n    //calling start\n    long long  result = maxCircularSum(a, n);\n    //calling end\n    cout << result << endl;\n\n}",
        "example": "[{\"input\": \"5\\n3 1 -4 1 5 \", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2308,
        "problem_description": "$n$ 个人去一个景点，一般情况下每个人都需要买票，但如果一个人的体重小于等于另一个人的体重的一半，那么这两个人可以合买一张票。已知 $n$ 个人的体重，他们至少需要买多少张票呢。",
        "function_declaration": "int calculate_ans(int a[], int n)",
        "code_context": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    int a[1000000];\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    // calling start\n    int ans = calculate_ans(a, n);\n    // calling end\n    cout << ans;\n}",
        "example": "[{\"input\": \"6\\n2 5 6 7 8 10\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1486,
        "problem_description": "某国法律规定，只要一个由 N×M 个小方块组成的旗帜符合如下规则，就是合法的国旗。（毛熊：阿嚏——）1. 从最上方若干行（至少一行）的格子全部是白色的；2. 接下来若干行（至少一行）的格子全部是蓝色的；3. 剩下的行（至少一行）全部是红色的；现有一个棋盘状的布，分成了 N 行 M 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成该国国旗，方法是在一些格子上涂颜料，盖住之前的颜色。小a很懒，希望涂最少的格子，使这块布成为一个合法的国旗。输入是第一行是两个整数 N,M。接下来 N 行是一个矩阵，矩阵的每一个小方块是W（白），B（蓝），R（红）中的一个。输出一个整数，表示至少需要涂多少块。",
        "function_declaration": "int calculateMinPaint(int N, int M, vector<vector<char>>& matrix)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int N, M;\n    cin>>N>>M;\n    vector<vector<char>> matrix(N, vector<char>(M));\n    for(int i=0; i<N; i++){\n        for(int j=0; j<M; j++){\n            cin>>matrix[i][j];\n        }\n    }\n    // calling start\n    int result = calculateMinPaint(N, M, matrix);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"4 5\\nWRWRW\\nBWRWB\\nWRWRW\\nRWBWR\", \"output\": \"11\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1648,
        "problem_description": "考古学家发现了一座千年古墓，墓碑上有神秘的字符。经过仔细研究，发现原来这是开启古墓入口的方法。墓碑上有两行字符串a和b，其中第一个串的长度为偶数，现在要求把第二个串插入到第一个串的正中央，如此便能开启墓碑进入墓中。",
        "function_declaration": "string mergeString(string a, string b)",
        "code_context": "#include <iostream>\n#include <string>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        string a, b;\n        cin >> a >> b;\n        // calling start\n        string result = mergeString(a, b);\n        // calling end\n        cout << result << endl;\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"2\\nCSJI\\nBI\\nAB\\nCMCLU\", \"output\": \"CSBIJI\\nACMCLUB\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1995,
        "problem_description": "众所周知，一个整数处以7的小数，不是有限小数就是循环小数。求n/7的循环节",
        "function_declaration": "int calculateRemainder(int n)",
        "code_context": "#include<cstdio>\n\n// function start\n\n// function end\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\t\n\t// calling start\n\tint result = calculateRemainder(n);\n\t// calling end\n\t\n\tprintf(\"%d\\n\", result);\n\treturn 0;\n}",
        "example": "[{\"input\": \"1\", \"output\": \"142857\"}, {\"input\": \"7\", \"output\": \"0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1727,
        "problem_description": "给出一种物质的分子式（不带括号），求分子量。 本题中的分子式只包含4种原子，分别为C、H、O、N， 原子量分别为12.01、1.008、16.00、14.01（g/mol）。 例如：C6H5OH的分子量为94.108g/mol。",
        "function_declaration": "double calculateSum(char* s, int len)",
        "code_context": "#include <bits/stdc++.h>\n#define maxn 85\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    char s[maxn];\n    scanf(\"%s\",s);\n    int len = strlen(s);\n    // calling start\n    double sum = calculateSum(s, len);\n    // calling end\n    printf(\"%.3f\",sum);\n    return 0;\n}",
        "example": "[{\"input\": \"C6H5OH\", \"output\": \"94.108\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1770,
        "problem_description": "现有若干正整数，请你求出其中第K大的整数。",
        "function_declaration": "void sortAndPrintKth(int a[], int n, int k)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[1010];\n\n// function start\n\n// function end\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    // calling start\n    sortAndPrintKth(a, n, k);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"5 3\\n1 3 6 5 8\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2300,
        "problem_description": "给定一个由 $n$ 个整数组成的数列 $a_1,a_2,...,a_n$，请为这个数列找到一个平衡点，使得平衡点左侧与右侧的力矩尽量接近。若平衡点为 $a_k$，则左侧力矩定义为数列中下标小于 $k$ 的各个元素到 $a_k$ 的距离乘以这些元素大小的总和。同理，右侧力矩定义为数列中下标大于 $k$ 的每个元素到 $a_k$ 的距离乘以这些元素大小的总和。例如 $n=6$，若选 $a_4$ 为平衡，左力矩计算公式为：$$L=a_1 ×(4-1)+a_2×(4-2)+a_3×(4-3)$$右力矩计算公式为：$$R=a_5×(5-4)+a_6×(6-4)$$请找到一个最佳平衡点，并输出选择该点为平衡点时，左右力矩之差绝对值的最小值。",
        "function_declaration": "int findMinAbsoluteDifference(vector<int>& nums)",
        "code_context": "#include<iostream>\nusing namespace std;\nconst int maxn = 300000;\nint a[maxn];\nlong long L[maxn], R[maxn];\n\n//function start\n\n//function end\n\nint main()\n{\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n    //calling start\n    long long result = findMinAbsoluteDiff(n);\n    //calling end\n    cout << result << endl;\n}",
        "example": "[{\"input\": \"4\\n1 2 3 4\", \"output\": \"0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1565,
        "problem_description": "输入三个单词组成的句子，将这三个单词反向输出，例如输入you love i，则输出i love you，每个单词长度不大于100（请用字符数组实现）",
        "function_declaration": "void reversePrint(char words[3][101])",
        "code_context": "# include <iostream>\n# include <cstring>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    char words[3][101];\n    for (int i=0; i<3; i++)\n        scanf(\"%s\", words[i]);\n    \n    // calling start\n    reversePrint(words);\n    // calling end\n    \n    return 0;\n}",
        "example": "[{\"input\": \"you love i\", \"output\": \"i love you\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1746,
        "problem_description": "给定一张无向图，和若干次询问，每次询问确认某两个点直接是否有直接连通路径且不经过其他点。输入三个整数n m q (1 ≤ n ≤ 10^5 , 1 ≤ m ≤ 5*10^5 , 1 ≤ q ≤ 100)，分别表示这张图的点数量，路径数量和查询次数。M对整数，表示每条路连接的两个地点。q对整数，表示询问的两个地点。输出若干行，每行一个字母，Y表示有符合条件的道路，N表示没有。",
        "function_declaration": "void hasDirectPath(int n, int m, int q, vector<pair<int, int>>& paths, vector<pair<int, int>>& queries) ",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n, m, q;\n    cin >> n >> m >> q;\n    \n    vector<pair<int, int>> paths(m);\n    for (int i = 0; i < m; i++) {\n        cin >> paths[i].first >> paths[i].second;\n    }\n    \n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        cin >> queries[i].first >> queries[i].second;\n    }\n    \n    // calling start\n    hasDirectPath(n, m, q, paths, queries);\n    // calling end\n}",
        "example": "[{\"input\": \"4 5 2\\n1 2\\n1 3\\n2 3\\n1 4\\n2 4\\n1 2\\n3 4\", \"output\": \"Y\\nN\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1949,
        "problem_description": "输入0～99之内的任意一个整数n，输出n每一位上的数字，用空格分开。",
        "function_declaration": "void printDigits(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n  \tint n;\n  \tcin >> n;  \n\n    // calling start\n    printDigits(n);\n    // calling end\n\n  \treturn 0;\n}",
        "example": "[{\"input\": \"13\", \"output\": \"1 3\"}, {\"input\": \"8\", \"output\": \"8\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2081,
        "problem_description": "辗转相除法，又称欧几里得算法，是求取最大公约数的一种算法。辗转相除法首次出现于欧几里得的《几何原本》中的第Ⅶ卷，书中的命题i和命题ii所描述的就是辗转相除法。辗转相除法的基本思想是：用较大的数除以较小的数，再用除数除以出现的余数（第一余数），再用第一余数除以出现的余数（第二余数），如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。例如，求1071和462的最大公约数过程如下：1071÷462=2…147 462÷147=3…21 147÷21=7…0所以，1071和462的最大公约数是21。现在请你用辗转相除法求两个数的最大公约数。",
        "function_declaration": "long long calculateGCD(long long a, long long b)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tlong long a, b;\n\tcin >> a >> b;\n\t// calling start\n\tlong long result = calculateGCD(a, b);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"114 514\", \"output\": \"2\"}, {\"input\": \"1919 810\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2070,
        "problem_description": "小万同学邀请小橙同学一起听音乐。一首音乐可以用n个乐符来表示，每个乐符可以用一个数字来表示。小橙喜欢变化的音乐。小万同学想知道一首歌曲中，有多少个音符与上一个音符不相同。",
        "function_declaration": "int countDistinct(int n, int arr[])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n = 0;\n    cin >> n;\n    int arr[n];\n    for(int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    // calling start\n    int result = countDistinct(n, arr);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n1 1 2\\n\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2212,
        "problem_description": "2020年4月11日，英国数学家 约翰·霍顿·康威（John Horton Conway）因为新型冠状病毒肺炎不幸逝世。他在群论、数论、代数、几何拓扑、理论物理、组合博弈论和几何等领域，都做出了重大贡献。他的离去是人类文明的损失。他最著名的发明就是生命游戏（Conway’s Game of Life）。生命游戏定义了一种细胞自动机。该自动机由一个网格组成，每个方格代表一个细胞，细胞有两种状态：生（黑色表示）或死（白色表示）。每个细胞在下个时刻的生死取决于当前时刻相邻的八个细胞的状态，具体规则如下：如果某个原本存活的细胞，周围恰好有2个 或3个活的细胞，那么在下个时刻，它会保持存活；如果某个原本存活的细胞，周围活的细胞小于2个或多于3个，那么它在下个时刻，会因孤独或拥挤而死亡；如果某个原本死亡的细胞，周围恰好有3个活的细胞，那么在下个时刻，它会变成活的细胞。利用这些简单的规则，生命游戏将从一个时刻迭代到下一个时刻，呈现不同的演化形态。第一种是稳定状态，细胞自动机从诞生起，布局稳定，没有任何变化。如下图所示第二种是振荡状态，细胞自动机反复在几种状态间振荡变化，如下图所示第三种是消亡状态，细胞自动机逐渐萎缩，如下图所示细胞自动机还有更多有趣的状态，比如繁衍或者移动，此处就不展开了。给定一个规模为$n×m$的细胞自动机，请判定它是否处于稳定状态，输入的第一行为两个整数 $n$ 和 $m$；接下来有 $n×m$ 个字符，表示每个细胞是否存活：数据范围1≤n,m≤100。",
        "function_declaration": "bool checkLife(char a[100][100], int n, int m)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tchar a[100][100];\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) \n\t  for (int j = 0; j < m; ++j)\n\t     cin >> a[i][j];\n\t// calling start\n\tbool flag = checkLife(a, n, m);\n\t// calling end\n\tif (flag)  \n\t  cout << \"Still life\";\n\telse\n\t  cout << \"Other\";  \n}",
        "example": "[{\"input\": \"4 4\\n....\\n.**.\\n.**.\\n....\", \"output\": \"Still life\"}, {\"input\": \"3 4\\n.**.\\n*..*\\n.**.\", \"output\": \"Still life\"}, {\"input\": \"2 3\\n...\\n.*.\", \"output\": \"Other\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1698,
        "problem_description": "楼梯有N阶，上楼可以一步上一阶，也可以一步上二阶。 编一个程序，计算共有多少种不同的走法。",
        "function_declaration": "long long fibonacci(int n)",
        "code_context": "#include <bits/stdc++.h>\n#define N 60\nusing namespace std; \nlong long a[N]; \nint n; \n\n// function start\n\n// function end\n\nint main() { \n    cin >> n; \n    if (n == 0) {\n        cout << \"0\";\n        return 0;\n    }\n  \n    // calling start\n    long long result = fibonacci(n);\n    // calling end\n    cout << result;\n    return 0; \n}",
        "example": "[{\"input\": \"4\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1906,
        "problem_description": "先编写一个打印a行b列的星号矩形的函数rectangleStar，再通过调用2次rectangleStar函数，先打印出一个3行4列的星号矩形、再打印出一个2行5列的星号矩形。运行结果如下所示：****\n****\n****\n*****\n*****\n编写一个rectangleStar函数，它的功能是打印a行b列的星号矩形：（1）void：表示空的。（2）函数名：rectangleStar表示“星号矩形”。（3）参数：int类型的变量a、b。（3）函数体：打印a行b列的星号矩形。注意：若有多个参数，在声明参数间用逗号隔开。",
        "function_declaration": "void rectangleStar(int a, int b)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main () { \n    //calling start\n    rectangleStar(3, 4);\n    //calling end\n    //calling start\n    rectangleStar(2, 5);\n    //calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"****\\n****\\n****\\n*****\\n*****\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2284,
        "problem_description": "在一个二维坐标系上，悬浮着 $n$ 只静止不动的气球，第 $i$ 个气球的坐标为 $(x_i,h_i)$，$x_i$ 表示它的横坐标，$h_i$ 表示它的高度。保证在同一个坐标上，最多只有一只气球。小爱打算用最少的弓箭射穿所有的气球，每只弓箭射出时，需要确定一个高度，当弓箭没有遇到气球时，它会一直保持同样的高度沿 $x$ 轴正方向运动，如果弓箭碰到了气球，气球就会被射穿，弓箭的高度会减少1，然后继续沿水平方向运动，直到遇到下一个气球。请问，小爱最少需要射出多少只箭，才能将所有的气球全部射穿?",
        "function_declaration": "int countArrows(int n, pair<int, int> ball[])",
        "code_context": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 100000;\npair<int, int> ball[maxn];\nint arrow[maxn * 2 + 1];\n\n//function start\n\n//function end\n\nint main() {\n int n;\n cin >> n;\n for (int i = 0; i < n; ++i) {\n   cin >> ball[i].first >> ball[i].second;\n    }\n    //calling start\n    int result = countArrows(n, ball);\n    //calling end\n    cout << result; \n}",
        "example": "[{\"input\": \"5\\n1 2 \\n3 5 \\n4 4 \\n5 3\\n2 1 \", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1758,
        "problem_description": "现在有一些加密过后的英文句子，其中的每一个单词的字符都前后颠倒了。请你将这些单词复原后输出整个句子。",
        "function_declaration": "void reverseWords(char* a, int len)",
        "code_context": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nchar a[1050];\n\n// function start\n\n// function end\n\nint main(){\n    int N;\n    cin >> N;\n    getchar();\n    while(N--){\n        gets(a);\n        int len = strlen(a);\n        // calling start\n        reverseWords(a, len);\n        // calling end\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"3\\ntahW a !yad\\nevaH a ecin !yad\\nI ekil .gnidoc\", \"output\": \"What a day!\\nHave a nice day!\\nI like coding.\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2298,
        "problem_description": "如果一个正整数的所有素因子均不超过 5，则它被称为正规数（Regular Number）。例如 60 是一个正规数，因为 $60=2^2*3*5$，1000 也是一个正规数，因为 $1000=2^3 *5^3$。前十五个正规数为：$$1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24$$。给定一个 $n$，请输出第 $n$ 个正规数。",
        "function_declaration": "long long findNthRegularNumber(int n) ",
        "code_context": "#include <iostream>\n\nusing namespace std;\n\n// Function to find the nth regular number\n//function start\n\n\n//function end\n\n#include<iostream>\nusing namespace std;\nlong long q[2000];\nint main() {\n    int n;\n    cin >> n;\n    //calling start\n    long long result = findNthRegularNumber(n);\n    //calling end\n    cout << result << endl;\n    \n}",
        "example": "[{\"input\": \"15\", \"output\": \"24\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2167,
        "problem_description": "小爱前去接种疫苗，注射完第一剂后，医生告诉她过14天后再来注射第二剂。给定接种第一剂疫苗的日期（以年-月-日表示），输入以y-m-d的形式表示，其中$y$表示年份、$m$表示月份、$d$表示天数，请输出注射第二剂的日期，以y-m-d的形式表示。",
        "function_declaration": "string calculateDate(int y, int m, int d)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint y, m, d;\n\tchar c;\n\tcin >> y >> c >> m >> c >> d;\n\t// calling start\n\tstring result = calculateDate(y, m, d);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"2021-3-12\", \"output\": \"2021-3-26\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1646,
        "problem_description": "老菲林经营着一家公司，这家公司里每位员工都有一个编号，有些干员外出执行任务，现在并不在公司本部，老菲林现在先要查询一些员工现在是否在公司本部，但是干员太多了，老菲林记不清楚，请你设计一个程序帮她查询一下。为了保证查询的准确性，技术部的希尔可露告诉你，老菲林想要询问的干员编号，在模大质数19260817的剩余系下，是不会重复的。输入两个整数n m，分别表示当前在公司的干员数量和老菲林的查询次数。输入n (1 ≤ n ≤ 10^5)个整数，表示当前在公司的干员编号。输入m (1 ≤ m ≤ 10^5)个整数，表示当前老菲林查询的干员编号。注意：干员的编号有可能超过int的存储范围。返回m个整数，对应查询的结果。若该干员在本部，则输出yes；反之，则输出no。",
        "function_declaration": "void checkEmployeeLocation(int m)",
        "code_context": "#include <iostream>\n\n#define mo 19260817\n\nusing namespace std;\n\nlong long vis[mo];\n//function start\n\n\n//function end\nint main() {\n    int n, m;\n    long long t;\n    cin >> n >> m;\n    while (n--) {\n        cin >> t;\n        vis[t % mo] = t;\n    }\n    //calling start\n    checkEmployeeLocation(m);\n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \"3 2\\n1 2 3\\n1 10\", \"output\": \"yes\\nno\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1947,
        "problem_description": "已知线段的两个端点的坐标 A(X1,Y1)，B(X2 ,Y2) ，求线段 AB 的长度。",
        "function_declaration": "float calculate_distance(float x1, float y1, float x2, float y2)",
        "code_context": "#include<cstdio>\n#include<cmath>\n\n// function start\n\n// function end\n\nint main(){\n    float x1,y1,x2,y2;\n    scanf(\"%f%f%f%f\",&x1,&y1,&x2,&y2);\n    // calling start\n    float result = calculate_distance(x1, y1, x2, y2);\n    // calling end\n    printf(\"%.3f\", result);\n}",
        "example": "[{\"input\": \"1 1\\n2 2\", \"output\": \"1.414\"}, {\"input\": \"3 4\\n0 0\", \"output\": \"5.000\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2204,
        "problem_description": "给定一个正整数 $n$，若 $n$ 在十进制下的各位数字之和小于$10$，则这个和是 $n$ 的数根。否则，继续求这个和在十进制下的各位数字之和，直到结果小于$10$为止，定义最后的结果为 $n$ 的数根。例如，$999$ 的数根为 $9$，因为 $9+9+9=27$，继续分解得 $2+7=9$。给定 $n$，请输出它的数根。注意，有一部分 $n$ 非常大。",
        "function_declaration": "int calculateRoot(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\n    long long n,root;\n    cin>>n;\n    // calling start\n    root = calculateRoot(n);\n    // calling end\n    cout <<root<< \"\\n\";\n}",
        "example": "[{\"input\": \"99999999999\", \"output\": \"9\"}, {\"input\": \"314159265358979323846264338328\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1794,
        "problem_description": "编写一个函数, 用于将一个字符串转换为整型数值。其原型为:int myatoi(char *string);其中参数string为待转换的字符串(其中包括正、负号和数字)，返回值为转换结果。",
        "function_declaration": "int myatoi(char *string)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    char str[50];\n    // calling start\n    cin >> str;\n    cout << myatoi(str) << endl;\n    // calling end\n    system(\"pause\");\n    return 0;\n}",
        "example": "[{\"input\": \"-123\", \"output\": \"-123\"}, {\"input\": \"+123\", \"output\": \"123\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1691,
        "problem_description": "山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。阿晓需要在有限的时间T内，采集尽可能高价值的草药。每株草药只能采一次。请你帮她算一算在时间限制内能采到的价值总和最高是多少。两个整数T N，分别表示限制的时间和草药的数量，其中1 ≤ T ≤ 1000，1 ≤ N ≤ 100。接下来N行，每行两个整数vi wi，分别表示该草药所需的时间和它的价值，其中1 ≤ vi wi ≤ 100。",
        "function_declaration": "int calculateMaxValue(int n, int t, int v[], int w[])",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f[1010];\n\n// function start\n\n// function end\n\nint main(){\n    int n, t;\n    cin >> n >> t;\n    int v[t+1], w[t+1];\n    for (int k = 1; k <= t; k++) {\n        cin >> v[k] >> w[k];\n    }\n    // calling start\n    int result = calculateMaxValue(n, t, v, w);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"70 3\\n71 100\\n68 1\\n1 2\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1778,
        "problem_description": "已知一个数字三角形。请找出从顶到底的某处的一条路径，使该路径所经过的数字总和最大。每次移动只能移动至紧邻的正下方数字处，或是紧邻的右下方数字。最终只需要求出最大的总和。",
        "function_declaration": "int calculateMaxSum(int n, int a[110][110])",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, ans, a[110][110];\n\n// function start\n\n// function end\n\nint main(){\n    cin >> n;\n    for (int i = 1; i <= n; i++) \n        for (int j = 1; j <= i; j++)\n            cin >> a[i][j];\n    // calling start\n    ans = calculateMaxSum(n, a);\n    // calling end\n    cout << ans << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n7\\n3 8\\n8 1 0\\n2 7 4 4\\n4 5 2 6 5\", \"output\": \"30\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2197,
        "problem_description": "以年-月-日的形式给定一个日期，计算给定的日期是当年第几天。注意闰年二月有 29 天。",
        "function_declaration": "int calculateDayOfYear(int year, int month, int day)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n\tint year, month, day;\n\tchar c;\n\tcin >> year >> c >> month >> c >> day;\n\n\t// calling start\n\tint result = calculateDayOfYear(year, month, day);\n\t// calling end\n\n\tcout << result; \n}",
        "example": "[{\"input\": \"2021-12-31\", \"output\": \"365\"}, {\"input\": \"2022-01-01\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1917,
        "problem_description": "有很多合成类的游戏都有如下的玩法：玩家会得到很多数字，每个数字都是 2 的幂，玩家可以挑选两个一样大的数字，将它们合成一个新的数字，新数字为原数字的两倍大小。如果这种合成操作可以不断地进行，给定小爱在最初获得的数字集合，请帮她算一下能够获得的最大数字。2 的幂是指只有 2 作为素因子的正整数。如 4、256 等等。但 60 不是，因为它有素因子 3。对于 30% 的数据，1 ≤n≤ 100，1 ≤ $a_i$  ≤ 128；?     对于 60% 的数据，1 ≤n≤ 2000，1 ≤ $a_i$ ≤ $2^20$；?     对于 100% 的数据，1 ≤n≤ 1,000,000，1 ≤ $a_i$ ≤$2^40$；",
        "function_declaration": "int calculate_ans(int n, int a[])",
        "code_context": "#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nint n, ans, a[100];\n\n// function start\n\n// function end\n\nint main() {\n    cin >> n;\n    // calling start\n    ans = calculate_ans(n, a);\n    // calling end\n    cout << (1LL << ans) << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n4 1 2 1 1\", \"output\": \"8\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1618,
        "problem_description": "一幅长宽分别为$n$个像素和$m$个像素的灰度图像可以表示为一个$n\\times m$大小的矩阵A。其中每个元素$A{ij}$（$0\\leq i<n, 0\\leq j<m$）是一个$[0,L)$范围内的整数，表示对应位置像素的灰度值。具体来说，一个8比特的灰度图像中每个像素的灰度范围是$[0,128)$。一副灰度图像的灰度统计直方图（以下简称“直方图”）可以表示为一个长度为$L$的数组$h$，其中$h[x]（0\\leq x<L）$表示该图像中灰度值为$x$的像素个数。显然，$h[0]$到h$[L?1]$的总和应等于图像中的像素总数$n*m$。已知一副图像的灰度矩阵$A$，试计算其灰度直方图$h[0],h[1],...,h[L-1]$。 输入为输入共$n+1$行。输入的第一行包含三个用空格分隔的正整数$n$、$m$和$L$，含义如前文所述。第二到第$n+1$行输入矩阵$A$。第$i+2(0\\leq i<n)$行包含用空格分隔的$m$个整数，依次为$A_{i0},A_{i1},...,A_{i(m-1)}$。全部的测试数据满足$0<n,m\\leq 500$且$4\\leq L\\leq 256$。 输出为输出仅一行，包含用空格分隔的$L$个整数$h[0],h[1],...,h[L-1]$，表示输入图像的灰度直方图。",
        "function_declaration": "vector<int> calculateHistogram(int n, int m, int L, vector<vector<int>>& A)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n, m, L;\n    cin>>n>>m>>L;\n    vector<vector<int>> A(n, vector<int>(m));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            cin>>A[i][j];\n        }\n    }\n    // calling start\n    vector<int> result = calculateHistogram(n, m, L, A);\n    // calling end\n    for(int i=0; i<L; i++){\n        cout<<result[i]<<\" \";\n    }\n}",
        "example": "[{\"input\": \"4 4 16\\n0 1 2 3\\n4 5 6 7\\n8 9 10 11\\n12 13 14 15\", \"output\": \"1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\"}, {\"input\": \"7 11 8\\n0 7 0 0 0 7 0 0 7 7 0\\n7 0 7 0 7 0 7 0 7 0 7\\n7 0 0 0 7 0 0 0 7 0 7\\n7 0 0 0 0 7 0 0 7 7 0\\n7 0 0 0 0 0 7 0 7 0 0\\n7 0 7 0 7 0 7 0 7 0 0\\n0 7 0 0 0 7 0 0 7 0 0\", \"output\": \"48 0 0 0 0 0 0 29\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2072,
        "problem_description": "质数，或者素数，指的是一个除了 1 和它自身外，不能被其他比自身小自然数整除的数。例如，7 不可以被 2,3,4,5,6 整除，因此是质数。而 15 则可以被 5 整除，因此不是质数。现在，给你一个正整数，判断它是不是质数。",
        "function_declaration": "bool isPrime(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    int n;\n    cin >> n;\n    // calling start\n    bool flag = isPrime(n);\n    // calling end\n   if(flag == true) cout << \"Yes\";\n    else cout << \"No\";\n    return 0;\n}",
        "example": "[{\"input\": \"37\", \"output\": \"Yes\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2025,
        "problem_description": "DarkSharpless 经常会遇到要读入参数的题目，这种题会根据不同的操作类型读入不同个数的参数，现在请你帮帮他处理一下读入参数。输入首先是一个数 op ，代表操作类型。若 op = 1，则将会有一个参数 x 。若 op = 2，则将会有两个参数 x，y。若 op = 1，请输出 \"The parameter for operation 1 is \" 后再加上 x 。（不含引号）若 op = 2，请输出 “The parameters for operation 2 are ” 后再加上 x 和 y （用空格分开，不含引号）。",
        "function_declaration": "void operation(int op, int x, int y)",
        "code_context": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n = 0, op = 0;\n    cin >> n;\n    while (n--) {\n        int x = 0, y = 0;\n        cin >> op;\n        // calling start\n        if (op == 1) {\n            cin >> x ;\n            operation(op, x, 0);\n        }\n        else {\n            cin >> x >> y;\n            operation(op, x, y);\n        }\n        // calling end\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"2\\n1 1\\n2 3 3\", \"output\": \"The parameter for operation 1 is 1\\nThe parameters for operation 2 are 3 3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1721,
        "problem_description": "有2个字符串，都是由大小写字母和空格组成的，请判断他们在忽略大小写、忽略空格后是否相等。",
        "function_declaration": "bool isAnagram(char* s1, char* s2)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N=256;\nchar s1[N],s2[N],a[N],b[N];\nint l1,l2;\n\n//function start\n\n//function end\n\nint main(){\n    gets(s1); \n    gets(s2);\n    //calling start\n    if(isAnagram(s1, s2))\n        printf(\"YES\\n\");\n    else\n        printf(\"NO\\n\"); \n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \"a A bb BB ccc CCC  \\nAa BBbb CCCccc\", \"output\": \"YES\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1705,
        "problem_description": "有n只鸡和m只兔同在一个笼子里，请问从上面数有多少个头，从下面数，有多少只脚。",
        "function_declaration": "pair<int, int> calculate(int n, int m)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    // calling start\n    pair<int, int> result = calculate(n, m);\n    // calling end\n    cout << result.first << \" \" << result.second << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"2 3\", \"output\": \"5 16\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2156,
        "problem_description": "有一个数学谜题是这样的：已知$1234=1$，$5678=3$，$6089=5$，请问$2571=$？解决这个问题的诀窍在于——把每个数字看成一个图形，其中封闭洞穴的数量就是答案。给定一个四位数，请你输出它的洞数量。提示：1、2、3、5、7没有洞，0、4、6、9一个洞，8两个洞。",
        "function_declaration": "int countHoles(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n\tint n;\n\tcin >> n;\n    // calling start\n    int result = countHoles(n);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"1234\", \"output\": \"1\"}, {\"input\": \"5678\", \"output\": \"3\"}, {\"input\": \"1023\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2209,
        "problem_description": "给定两个字符串 $s$ 与 $p$，请判定 $p$ 是否是 $s$ 的循环节。所谓循环节就是将 $p$ 复制若干遍拼接在一起后，恰好等于 $s$。",
        "function_declaration": "bool isSubsequence(string s, string p)",
        "code_context": "#include<iostream>\n#include<string>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  string s, p;\n  cin >> s >> p;\n  \n  // calling start\n  bool result = isSubsequence(s, p);\n  // calling end\n  \n  if(result)\n    cout << \"Yes\";\n  else\n    cout << \"No\";\n}",
        "example": "[{\"input\": \"xyxy\\nxy\", \"output\": \"Yes\"}, {\"input\": \"abbba\\nabbba\", \"output\": \"Yes\"}, {\"input\": \"ccccc\\ncc\", \"output\": \"No\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1649,
        "problem_description": "已知一张图有n (2 <= n <= 1000)个点，m (1 <= m <= 10^6)条边，点的编号为1 ~ n，现在给出每条边连接的两侧端点，图存在nxt中，nxt[1][2]=true表示点1和点2之间有边，请你列出每个点都与哪些点有直接连通的边，输出共n行，每行若干个整数，第i行表示与点i相直接连接的点。若有多个，则由小到大输出，不包含点i自己；若没有点与其直接相连，则在该行输出none。",
        "function_declaration": "void printConnections(bool *nxt,int n)",
        "code_context": "#include <iostream>\n\n#define N 1010\n\nusing namespace std; \n\nbool nxt[N][N];\n\n// function start\n\n// function end\n\nint main() {\n    int n, m, a, b;\n    cin >> n >> m;\n    while (m--) {\n        cin >> a >> b;\n        nxt[a][b] = true;\n        nxt[b][a] = true;\n    }\n    // calling start\n    printConnections(nxt,n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"5 5\\n1 2\\n2 3\\n1 3\\n2 1\\n1 4\", \"output\": \"2 3 4\\n1 3\\n1 2\\n1\\nnone\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1780,
        "problem_description": "请你利用字符串，读入两个整数字符串，返回这两个整数和它们的位数。",
        "function_declaration": "int calculate_length(char* str)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar a[1010], b[1010];\n\n//function start\n\n//function end\n\nint main() {\n    int a_len, b_len;\n    memset(a, 0, sizeof(a)); \n    memset(b, 0, sizeof(b));\n    \n    scanf(\"%s\", a);\n    scanf(\"%s\", b);\n    //calling start\n    a_len = calculate_length(a); //求出第一个字符串的长度\n    b_len = calculate_length(b); //求出第二个字符串的长度\n    //calling end\n   \n    printf(\"%s\\n\", a);\n    printf(\"%s\\n\", b);\n    printf(\"%d\\n\", a_len);\n    printf(\"%d\\n\", b_len);\n    return 0;\n}",
        "example": "[{\"input\": \"123456789123456789\\n9876543219876543210\", \"output\": \"123456789123456789 \\n9876543219876543210\\n18 \\n19\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1826,
        "problem_description": "扫雷是Windows自带的游戏。游戏的目标是尽快找到雷区中的所有地雷，而不许踩到地雷。如果方块上的是地雷，将输掉游戏。如果方块上出现数字，则表示在其周围的八个方块中共有多少颗地雷。你的任务是在已知地雷出现位置的情况下，得到各个方块中的数据。每组数据的第一行有两个数字，m, n (0 < m, n< 100)表示游戏中雷区的范围为m×n。接下来m行每行有n个字符。*表示有地雷，.表示无地雷。对于每组输入数据，输出结果，各方块数字间不留空格。地雷位置用*表示。",
        "function_declaration": "void printMinefieldData(int m, int n, const vector<vector<char>>& minefield)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int m, n;\n    while (cin >> m >> n && m != 0 && n != 0) {\n        vector<vector<char>> minefield(m, vector<char>(n));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                cin >> minefield[i][j];\n            }\n        }\n\n        //calling start\n        printMinefieldData(m, n, minefield);\n        //calling end\n\n        cout << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"2 3 \\n***\\n...\\n4 4\\n*...\\n....\\n.*..\\n....\\n0 0\", \"output\": \"***\\n232\\n\\n*100\\n2210\\n1*10\\n1110\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2188,
        "problem_description": "小A和小B吹牛说自己有一台超级计算机，小B不信，要求小A完成下面的计算来证明。小A找到你求助。给定 n 个整数 f1,f2,...,fn。n 可能很大，因此 n 个整数不会直接在输入中提供，而是按照以下方式生成：输入只给定 f1。然后 f2 = f1*a+b。以此类推，之后每一个数都等于前一个数乘 a 再加 b 的结果。计算 f1,f2,...,fn 的乘积对 1000003 取模的结果。",
        "function_declaration": "long long mainLogic(long long n, long long f1, long long a, long long b)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nlong long mod=1000003;\nint vis[1000010],s[1000010];\n\n// function start\n\n// function end\n\nint main(){\n\tlong long n,f1,a,b;\n\tcin>>n>>f1>>a>>b;\t\n\n\t// calling start\n\tlong long result = mainLogic(n, f1, a, b);\n\t// calling end\n\n\tcout<<result;\n}",
        "example": "[{\"input\": \"3000000 3 116 555\", \"output\": \"783568\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2263,
        "problem_description": "跳水是音乐节或者Livehouse上常见的活动，通常发生在乐迷密集的时候，跳水者站在舞台上仰面跃下，乐迷用手支撑跳水者在头顶上方传递（危险动作请勿模仿）。作为未来的传奇摇滚巨星，Bocchi对跳水再熟悉不过了。现在，Bocchi正打算进行一次跳水。观众席可以看作一个 n*m 的网格区域，每个 1*1 的格子里可能有 1 个观众，也可能没有，audienceSeats表示观众席，其中每个数均为 0 或 1，表示这个位置是否有观众。Bocchi想要找到一个观众数量最多的 x*y（x行y列）的区域作为跳水的位置。Bocchi会给你 q 个询问，每次给定 x,y，你需要回答观众席上一个 x*y 的区域最多有多少名观众，返回q个答案。",
        "function_declaration": "vector<int> answerQueries(int n, int m, vector<vector<int>>& audienceSeats,\n                               vector<pair<int, int>>& queries)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the sum of audiences in each x*y region\n//function start\n//function end\n\nint main() {\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<vector<int>> audienceSeats(n, vector<int>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> audienceSeats[i][j];\n        }\n    }\n\n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        cin >> queries[i].first >> queries[i].second;\n    }\n\n    // Answering the queries\n    //calling start\n    vector<int> results = answerQueries(n, m, audienceSeats, queries);\n    //calling end\n\n    // Printing the results\n    for (int i = 0; i < results.size(); i++) {\n        cout << results[i] << endl;\n    }\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"5 6 3\\n1 1 1 1 0 1\\n1 0 1 0 1 1\\n1 1 1 1 1 1\\n1 1 1 0 0 1\\n1 0 1 1 1 1\\n4 2\\n3 3\\n3 4\", \"output\": \"7\\n8\\n10\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1916,
        "problem_description": "给定正整数 s 和 t ，我们希望利用增长与翻倍的操作，让 s 变成 t 。一步增长可以让数字加一，一步翻倍可以让数字翻倍。最少需要用多少步操作才能将 s 变成 t？保证s<t。对于 50% 的数据，1 ≤s<t≤ 100；?     对于 100% 的数据，1 ≤s<t≤ 1,000,000,000；",
        "function_declaration": "int calculateAns(int s, int t)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int s, t;\n    cin >> s >> t;\n    // calling start\n    int ans = calculateAns(s, t);\n    // calling end\n    cout << ans << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"1 4\", \"output\": \"2\"}, {\"input\": \"2 10\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1969,
        "problem_description": "为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期所在年份是否为闰年。我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 31 天、 二月 28 天或 29 天、三月 31 天、四月 30 天、五月 31 天、六月 30 天、七月 31 天、八月 31 天、九月 30 天、十月 31 天、十一月 30 天、十二月 31 天。其中，闰年的二月为 29 天，平年为 28 天。当年份是 400 的倍数，或日期年份是 4 的倍数但不是 100 的倍数时，该年为闰年。2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 4 的倍数就是闰年。4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，公元零年并不存在，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。",
        "function_declaration": "bool isLeapYear(int n)",
        "code_context": "#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\t//calling start\n\tbool result = isLeapYear(n);\n\t//calling end\n\tif(result) cout << \"Yes\";\n\telse cout << \"No\";\n}",
        "example": "[{\"input\": \"1\", \"output\": \"Yes\"}, {\"input\": \"1000\", \"output\": \"No\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2038,
        "problem_description": "央视8套为了鼓励年轻人努力奋斗，避免躺平，3月9号推出新剧《心想事成》，女主是穷人，在北京打工了几年，才凑够钱在北二环的中心大楼旁买了一套四合院。小A看剧之后大受鼓舞，他决定开始存钱，给自己也买一套四合院。小A把自己的计划告诉了你，请你帮忙算算，他的梦想最快什么时候才能实现？输入一个正整数 n，q，表示考虑接下来的 n 天，income包含 n 个非负整数，表示接下来的 n 天小A每天的收入。小A想尽快实现梦想，所以他开始存钱后每天都会吃土，所有收入都会被存下来。输入两个正整数 t，m，表示小A询问你，如果从第 t 天开始存钱，总共需要存 m 元钱，那么他最快什么时候能实现梦想。对于 40% 的数据，$n,q \\le 10^3$；对于 100% 的数据，$n \\le 10^5$，$m \\le 10^9$，$t \\le n$，保证小A接下来 n 天的总收入在int表示范围内。返回一个整数，表示按照这个计划小A最快在第几天能存够钱。如果 n 天结束仍然不能存够，返回 -1，表示小A的愿望只能在梦中实现。",
        "function_declaration": "int fastestDreamDay(int n, vector<int>& income, int t, int m)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> income(n);\n    for (int i = 0; i < n; i++) {\n        cin >> income[i];\n    }\n\n    // Process q queries\n    for (int i = 0; i < q; i++) {\n        int t, m;\n        cin >> t >> m;\n\n        //calling start\n        int result = fastestDreamDay(n, income, t, m);\n        //calling end\n\n        cout << result << endl;\n    }\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"10 3\\n100 100 200 100 300 200 100 100 200 300\\n1 1000\\n4 1001\\n6 1000\", \"output\": \"6\\n10\\n-1\"}, {\"input\": \"100000 1\\n1000 1000 1000 ...... 1000 （100000个1000）\\n1 100000000\", \"output\": \"100000\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2125,
        "problem_description": "小万决定创造一种特别的由括号构成的图案。这个图案可以被一个整数 $n$ 决定。具体来说，n=1\n()<>\nn=2\n(()<>)<()<>>\nn=3\n((()<>)<()<>>)<(()<>)<()<>>>\nn=...\n规律非常明显，$n$ 的图案中包含两次 $n-1$ 的图案。小万现在给你整数 $n$，请你帮他把图案写出来。！！提示！！函数可以调用自身。这被称为 递归调用。",
        "function_declaration": "void dfs(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n int n = 0;\n cin >> n;\n    //calling start\n dfs(n);\n    //calling end\n cout << endl;\n return 0;\n}",
        "example": "[{\"input\": \"1\\n\", \"output\": \"()<>\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1742,
        "problem_description": "现有n个物品，我们要挑选若干物品装进背包。每个物品的初始价值为Ai，并且都需要Ti的时间装进背包，但是在被装进背包之前，每个物品会以Bi的速率衰减价值，也就是说如果从开始到该物品被完全装进背包的时间为t，那么该物品的实际价值为Ai - t*Bi。请你求出在有限时间内，能获得的最大价值。输入为两个整数n T (1 ≤ n ≤ 50 , 1 ≤ T ≤ 10000)及三个数组A B Ti，两个整数n T表示物品数量和总时间。三个数组A B Ti，分别包含了每个物品的初始价值Ai (1 ≤ Ai ≤ 10^5)，衰减系数Bi (1 ≤ Bi ≤ 100)，装包所需时间Ti (1 ≤ ti ≤ 1000)。返回一个整数，表示能获得的最大价值。",
        "function_declaration": "int calculateMaxValue(int n, int T, vector<int>& A, vector<int>& B, vector<int>& Ti) ",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the maximum value that can be obtained\n// by selecting items to fit within the given total time\n//function start\n\n//function end\n\nint main() {\n    int n, T;\n    cin >> n >> T;\n\n    vector<int> A(n), B(n), Ti(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> A[i] >> B[i] >> Ti[i];\n    }\n\n    // Calling the function to calculate the maximum value\n    //calling start\n    int maxValue = calculateMaxValue(n, T, A, B, Ti);\n    //calling end\n\n    cout << maxValue << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"2 50\\n100 1 10\\n100 2 15\", \"output\": \"145\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2135,
        "problem_description": "给定三个正整数，用函数求出其中位数。",
        "function_declaration": "int middle(int x,int y,int z)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    int x,y,z;\n    // calling start\n    cin >> x >> y >> z;\n    cout << middle(x,y,z);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"1 9 2\\n\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2104,
        "problem_description": "从 $n$ 个不同元素中，任取 $m(m\\leq n)$ 个元素组成一个集合，叫做从 $n$ 个不同元素中取出 $m$ 个元素的一个组合；从 $n$ 个不同元素中取出 $m(m\\leq n)$ 个元素的所有组合的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的组合数。用符号 $\\mathrm C_n^m$ 或 $\\dbinom{n}{m}$ 来表示。组合数的一种计算方式为 $\\mathrm C_n^m=\\dfrac{n!}{m!(n-m)!}$，即 $\\mathrm C_n^m=\\dfrac{n\\times(n-1)\\times\\cdots\\times (n-m+1)}{1\\times2\\times\\cdots\\times m}$。例如，$\\mathrm C_7^3$ 的计算过程为 $\\dfrac{7\\times6\\times5}{1\\times2\\times3}=35$。特别的，我们规定 $\\mathrm C_n^0=1\\ (n>0)$。现在请你计算 $\\mathrm C_n^m$。",
        "function_declaration": "long long calculate(long long n, long long m)",
        "code_context": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tlong long n, m;\n\tcin >> n >> m;\n\t// calling start\n\tlong long result = calculate(n, m);\n\t// calling end\n\tcout << result;\n\treturn 0;\n}",
        "example": "[{\"input\": \"10 4\", \"output\": \"210\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2034,
        "problem_description": "小万同学又打算去商店买一些零食，带回来分给小橙同学。这种情况下小万同学一般都会买偶数份，最多有一个会买得不一样。小橙同学有些纠结要不要接受他的分享。最终她决定，如果小万同学的购物单上每种零食都是偶数个，就和他一起吃零食。为了干扰小橙同学的判断，小万同学的购物清单很长，共有 $n$ 个商品，每个商品都有一个种类编号。小橙同学遇到了困难，请你帮她判断一下是不是每种都是偶数个。如果小橙同学可以接受，则返回accept，否则返回deny。",
        "function_declaration": "string checkShoppingList(int n, int arr[])",
        "code_context": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    //calling start\n    string result = checkShoppingList(n, arr);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"2\\n1 1\", \"output\": \"accept\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1973,
        "problem_description": "输入五个整数，请你输出这五个整数的最大值。",
        "function_declaration": "int findMax(int a, int b, int c, int d, int e)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int a, b, c, d, e, ans;\n  cin >> a >> b >> c >> d >> e;\n  // calling start\n  ans = findMax(a, b, c, d, e);\n  // calling end\n  cout << ans;\n  return 0;\n}",
        "example": "[{\"input\": \"1 7 4 6 5\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1831,
        "problem_description": "由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。Marry 乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格是不同的。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。注：每天所有奶农的总产量大于 Marry 乳业的需求量。 输入为第一行二个整数n m (0 ≤ n ≤ 2 * 10^6)，表示需要牛奶的总量，和提供牛奶的农民个数。接下来m (0 ≤ m ≤ 5000)行，每行两个整数pi ai(0 ≤ pi ≤ 1000, 0 ≤ ai ≤ 2 * 10^6)，表示第i个农民牛奶的单价，和农民i一天最多能卖出的牛奶量。 输出为单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。",
        "function_declaration": "long long calculateMinimumCost(long long n, int m, vector<pair<int, int>>& farmers)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    long long n;\n    int m;\n    cin>>n>>m;\n    vector<pair<int, int>> farmers;\n    for(int i=0; i<m; i++){\n        int p, a;\n        cin>>p>>a;\n        farmers.push_back(make_pair(p, a));\n    }\n    // calling start\n    long long result = calculateMinimumCost(n, m, farmers);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"100 5\\n5 20\\n9 40\\n3 10\\n8 80\\n6 30\", \"output\": \"630\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1930,
        "problem_description": "给定一个整数 n ，请找出 n 的最大平方因子。所谓平方因子，就是一个 n 的因子，且是一个完全平方数。最大平方因子就是 n的所有平方因子中最大的数。如 12 的最大平方因子为 4，81 的最大平方因子为其本身，21 的最大平方因子为 1。对于 50% 的数据，1 ≤n≤ 10000；  对于 100% 的数据，1≤n≤ 10,000,000。",
        "function_declaration": "int findMaxPerfectSquare(int n)",
        "code_context": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint n, mx = 0;\n\n// function start\n\n// function end\n\nint main()\n{\n    cin >> n;\n\n    // calling start\n    mx = findMaxPerfectSquare(n);\n    // calling end\n\n    cout << mx;\n\n    return 0;\n}",
        "example": "[{\"input\": \"12\", \"output\": \"4\"}, {\"input\": \"81\", \"output\": \"81\"}, {\"input\": \"21\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2326,
        "problem_description": "给定两个 n*m 的整数矩阵，将对应位置的元素相加，输出得到的矩阵。",
        "function_declaration": "vector<vector<int>> addMatrices(int n, int m, vector<vector<int>>& matrix1, vector<vector<int>>& matrix2)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to add two matrices\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> matrix1(n, vector<int>(m, 0));\n    vector<vector<int>> matrix2(n, vector<int>(m, 0));\n\n    for (int i = 0; i < 2 * n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i < n) {\n                cin >> matrix1[i][j];\n            } else {\n                cin >> matrix2[i - n][j];\n            }\n        }\n    }\n\n    // Add the two matrices\n    //calling start\n    vector<vector<int>> result = addMatrices(n, m, matrix1, matrix2);\n    //calling end\n\n    // Print the result\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << result[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"2 3\\n1 2 3\\n4 5 6\\n3 0 -1\\n-4 5 8\", \"output\": \"4 2 2\\n0 10 14\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2154,
        "problem_description": "给定两个整数$n$与$k$，打印出一个栅栏图形，这个栅栏应该分成$n$段，段内的填充为$k$个。形如$n=5$，$k=6$时，图形如下：+------+------+------+------+------+",
        "function_declaration": "void printPattern(int n, int k)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n    int n, k;\n    cin >> n >> k;\n\n    // calling start\n    printPattern(n, k);\n    // calling end\n}",
        "example": "[{\"input\": \"4 5\", \"output\": \"+-----+-----+-----+-----+\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2056,
        "problem_description": "众所周知，Dark 教授是一个 ASCII 画爱好者，因此她想让你输出一些 ASCII 画。简单来说，你要输出一个由字符 * 构成的长方形，其高度和宽度由 Dark 教授给出。两个正整数整数 n,m 表示 ASCII 画的高度和宽度，保证不超过 100",
        "function_declaration": "void printStars(int n, int m)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    int n,m;\n    cin >> n >> m;\n    // calling start\n    printStars(n, m);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"2 3\\n\", \"output\": \"***\\n***\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1662,
        "problem_description": "明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤100），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。注：请使用选择排序方法完成此题。输出2行，第1行为1个正整数M，表示不相同的随机数的个数。第2行为M个用空格隔开的正整数，为从小到大排好序的不相同的随机数。",
        "function_declaration": "void removeDuplicatesAndSort(int N, vector<int>& nums)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int N;\n    cin>>N;\n    vector<int> nums(N);\n    for(int i=0; i<N; i++){\n        cin>>nums[i];\n    }\n    // calling start\n    removeDuplicatesAndSort(N, nums);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"10\\n20 40 32 67 40 20 89 300 400 15\", \"output\": \"8\\n15 20 32 40 67 89 300 400\"}]",
        "time_limit": 1000,
        "memory_limit": 125
    },
    {
        "id": 1998,
        "problem_description": "小A的账户上每天都会有一些收入和支出。现在小A告诉了你账户余额在一段时间内的变化情况，想请你帮忙计算他的收支。输入balance包含t 个非负整数，第 i 个数表示小A的账户在第 i 天结束时的余额。 Queries包含q对整数 l,r，表示小A询问你他在第 l 天到第 r 天的收支情况。对于 100% 的数据，t,q<=100，1<=l<r<=t，账户余额<=100000，返回q个询问的答案。",
        "function_declaration": "vector<long long> calculateBalance(vector<long long> balance, vector<pair<int, int>> queries)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int t, q;\n    cin>>t>>q;\n    vector<long long> balance(t+1);\n    for(int i=1; i<=t; i++){\n        cin>>balance[i];\n    }\n    vector<pair<int, int>> queries(q);\n    for(int i=0; i<q; i++){\n        int l, r;\n        cin>>l>>r;\n        queries[i] = make_pair(l, r);\n    }\n    // calling start\n    vector<long long> result = calculateBalance(balance, queries);\n    // calling end\n    for(auto res : result){\n        cout<<res<<endl;\n    }\n}",
        "example": "[{\"input\": \"10 3\\n100 200 300 400 500 600 350 450 50 0\\n1 8\\n4 5\\n5 10\", \"output\": \"350\\n100\\n-500\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2317,
        "problem_description": "给定一个01序列$b_1,b_2 ,… ,b_n$，01的意思就是这个数列里只有0与1。请问最少需要将多少个1改成0，序列里会出现至少$k$个连续的0。",
        "function_declaration": "int calculateBestb(int n, int k, int b[])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n int n, k;\n cin >> n >> k;\n int b[500001];\n for (int i = 1; i <= n; ++i) \n {\n  char c;\n  cin >> c;\n  if (c == '0') b[i] = 0;\n  else b[i] = 1;\n } \n\n // calling start\n int best = calculateBestb(n, k, b);\n // calling end\n\n cout << best; \n}",
        "example": "[{\"input\": \"6 3\\n101010\", \"output\": \"1\"}, {\"input\": \"5 5\\n00100\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2164,
        "problem_description": "给定$n$个整数$a_1,a_2,…,a_n$，每个数字表示一条线段的长度，请问能否用这些线段，围成一个封闭的$n$边形？$n$条线段能围成$n$边形的充分必要条件是：任何一条线段的长度都严格小于剩余$n-1$条线段的长度之和。输入单个整数$n$和$n$个整数$a_1,a_2,…,a_n$，数据范围$1≤a_i?≤1,000,000,000$；对于$30%$的数据，$1≤n≤100$；对于$60%$的数据，$1≤n≤5,000$；对于$100%$的数据，$1≤n≤100,000$；如果可以围成$n$边形，输出Yes，否则输出No。",
        "function_declaration": "string canFormPolygon(int n, vector<int>& lineSegments)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to check if the given line segments can form a closed n-gon\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> lineSegments(n);\n    for (int i = 0; i < n; i++) {\n        cin >> lineSegments[i];\n    }\n    //calling start\n    string result = canFormPolygon(n, lineSegments);\n    //calling end\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n1 3 5 2 4 6\", \"output\": \"Yes\"}, {\"input\": \"3\\n1 1 2\", \"output\": \"No\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1796,
        "problem_description": "利用指针，编写用于交换两个整型变量值的函数。",
        "function_declaration": "void swapNumbers(int *xp, int *yp)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    // calling start\n    swapNumbers(&a, &b);\n    // calling end\n    cout << a << \" \" << b << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"5 6\", \"output\": \"6 5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2100,
        "problem_description": "小万带着小橙去观赏一个艺术品楼梯。这个楼梯一共有 $n$ 层台阶，每一层台阶的宽度是相同的，高度则不一定相同。小橙同学突然有一个问题，如果从侧面去看这个楼梯，楼梯上表面和地面围成的面积是多少？你能帮小万同学解答下这个问题吗？输入两个整数 $n$ 和 $w$和$n$ 个整数，表示有 $n$ 个台阶，每个台阶的宽度都是 $w$， $n$ 个整数中第 $i$ 个数表示第 $i$ 个楼梯相对于上一个楼梯的高度 $h_i$，输出一个整数，表示台阶上表面与地面围成的面积。（注意答案可能超过int范围）。",
        "function_declaration": "long long calculateSurfaceArea(int n, int w, vector<int>& heights)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n, w;\n    cin >> n >> w;\n\n    vector<int> heights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> heights[i];\n    }\n\n    //calling start\n    long long surfaceArea = calculateSurfaceArea(n, w, heights);\n    cout << surfaceArea << endl;\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"3 2\\n1 2 3\\n\", \"output\": \"20\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2177,
        "problem_description": "小橙家养了一只可爱的小猫。这天小猫跑到了公园和小橙玩躲猫猫！小橙知道公园的地形。具体来说，公园可以看作是 $n$ 行 $m$ 列的矩形区域，每个矩形区域内海拔近似相等。小橙家的小猫喜欢爬高，所以小橙同学求助小万同学去每一个居高临下的区域寻找。称一个区域是居高临下的，当它紧临的四个区域都存在并且海拔都比这个区域低（严格）。请你根据地形图，判断小万要去多少个区域。",
        "function_declaration": "int findPeaks(int n, int m, int a[maxn][maxn])",
        "code_context": "#include <iostream>\nusing namespace std;\nint const maxn = 5001;\n\nint n = 0, m = 0;\nint a[maxn][maxn];\n\n// function start\n\n// function end\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tcin >> a[i][j];\n\t// calling start\n\tint ans = findPeaks(n, m, a);\n\t// calling end\n\tcout << ans << endl;\n\treturn 0;\n}",
        "example": "[{\"input\": \"3 5\\n1 2 3 4 5\\n6 7 6 7 6\\n5 4 3 2 1\", \"output\": \"2\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1793,
        "problem_description": "用指针编写一个程序，当输入一个字符串后，要求不仅能够统计其中字符的个数，还能分别指出其中的大写字母、小写字母、数字以及其他字符的个数。",
        "function_declaration": "void countCharacters(char* ptr, int& total, int& cap, int& sma, int& num, int& oth)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    char str[100];\n    char *ptr = str;\n    int total, cap, sma, num, oth;\n    cin.get(ptr, 100);\n    // calling start\n    countCharacters(ptr, total, cap, sma, num, oth);\n    // calling end\n    cout << cap << endl;\n    cout << sma << endl;\n    cout << num << endl;\n    cout << oth << endl;\n    cout << total << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"I am 21 years old.\", \"output\": \"1\\n10\\n2\\n5\\n18\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1799,
        "problem_description": "输入两个整数，使用变量的引用，将它们按由小到大的顺序交换。",
        "function_declaration": "void swapValues(int &a, int &b)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    // calling start\n    if (m > n)\n        swapValues(m, n);\n    // calling end\n    cout << m << \" \" << n << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"3 2\", \"output\": \"2 3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1573,
        "problem_description": "输入一个字符，若该字符是否是大写或小写字母。额外提示：if语句的写法if ( 表达式 ) {\n    // 如果表达式为真将执行的语句\n}\nelse {\n    // 如果表达式为假将执行的语句（可以没有else分支）\n}\n",
        "function_declaration": "bool isAlphabet(char a)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    char a;\n    cin >> a;\n    // calling start\n    bool result = isAlphabet(a);\n    // calling end\n    if (result) {\n        cout << \"yes\";\n    }\n    else {\n        cout << \"no\";\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"q\", \"output\": \"yes\"}, {\"input\": \">\", \"output\": \"no\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2062,
        "problem_description": "小A在学习编程的过程中发现，浮点数类型是不支持取模（%）运算的，而如果使用整数除法，又会出现 (A/B)*B 不等于 A 的不合理情况。小A想要解决这个问题。具体来说，小A想找到一个整数 t，满足 (t*B)%C == A%C，这个整数 t 就可以看作 (A/B)%C 的结果。小A经过研究发现，当 c 是一个质数时，在 0,1,...,c-1 中一定恰好有一个满足条件的整数 t。小A想请你帮他找出这个数。输入包含三个正整数 a，b，c。输出一个小于 c 的非负整数，表示答案。",
        "function_declaration": "long long calculate(long long a, long long b, long long c)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n\tlong long a,b,c;\n\tcin>>a>>b>>c;\n\t// calling start\n\tlong long result = calculate(a, b, c);\n\t// calling end\n\tcout<<result;\n}",
        "example": "[{\"input\": \"1 2 7\", \"output\": \"4\"}, {\"input\": \"3 5 11\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1578,
        "problem_description": "本题要求编写程序，使用cout语句，在屏幕上打印5行菜单。按照下列格式打印菜单，每行显示一句。注意除了每行的换行不能有任何多余字符。[1] Select crisps\n[2] Select popcorn\n[3] Select chocolate\n[4] Select cola\n[0] Exit\n",
        "function_declaration": "void displayMenu()",
        "code_context": "#include <iostream>\nusing namespace std; \n\n//function start\n\n//function end\n\nint main() {\n    //calling start\n    displayMenu();\n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \" \", \"output\": \"[1] Select crisps\\n[2] Select popcorn\\n[3] Select chocolate\\n[4] Select cola\\n[0] Exit\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2003,
        "problem_description": "给定两个正整数 a,b，求 a+b，a*b 的值。 输入为输入共一行，包含两个正整数 a,b。对于 100% 的数据，$a,b \\le 10^9$ 输出为输出一行两个数，分别表示 a+b 和 a*b 的值。",
        "function_declaration": "pair<long long, long long> calculateSumAndProduct(long long a, long long b)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    long long a, b;\n    cin>>a>>b;\n    // calling start\n    pair<long long, long long> result = calculateSumAndProduct(a, b);\n    // calling end\n    cout<<result.first<<\" \"<<result.second;\n}",
        "example": "[{\"input\": \"2 3\", \"output\": \"5 6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2149,
        "problem_description": "做好一只烧饼，需要把烧饼的两面都加热。给定两个正整数$n$与$k$，$n$表示需要做的烧饼数量，而$k$表示厨房里有$k$口锅，每口锅每分钟能做好一面烧饼。请计算至少需要多少分钟才能做完所有的烧饼。",
        "function_declaration": "int calculate(int n, int k)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    // calling start\n    int result = calculate(n, k);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"3 2\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2373,
        "problem_description": "假设我们有个集合${1, 2, 3, ..., n}$，输出所有满足 集合中所有数求和是3的倍数 的子集的个数。比如，当n等于3时，所有子集为：{1}、{2}、{3}、{1，2}、{1，3}、{2，3}{1，2，3}其中满足所有数求和是3的倍数的集合有3个，分别是{3}、{1，2}、{1，2，3}。比如，当n等于4时，所有子集为：{1}、{2}、{3}、{4}、{1，2}、{1，3}、{1，4}、{2，3}、{2，4}、{3，4}、{1，2，3}、{1，2，4}、{1，3，4}、{2，3，4}、{1，2，3，4}其中满足所有数求和是3的倍数的集合有5个，分别是{3}、{1，2}、{2，4}、{1，2，3}、{2，3，4}。",
        "function_declaration": "int calculate_ans(int n)",
        "code_context": "#include <bits/stdc++.h>  \nusing namespace std;  \nint n;\n\n// function start\n\n// function end\n\nint main() {  \n    cin >> n;\n    // calling start\n    int ans = calculate_ans(n);\n    // calling end\n    printf(\"%d\\n\", ans);  \n}",
        "example": "[{\"input\": \"3\", \"output\": \"3\"}, {\"input\": \"4\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1966,
        "problem_description": "小A和小B正在玩一个拼点游戏。拼点指双方各以牌面向下的方式出一张手牌后同时亮出，牌面上的点数大的一方赢。游戏开始时小A和小B各有三张手牌，每回合双方同时打出一张手牌进行拼点，赢的一方得2分。如果平局，则双方各得1分。三回合后双方打完手牌，游戏结束。你已经提前看过了双方的手牌，现在小A想请你告诉他，游戏结束时他可能得到的最高分数是多少？输入三个整数 a1,a2,a3，表示小A的三张手牌的点数。三个整数 b1,b2,b3，表示小B的三张手牌的点数。",
        "function_declaration": "int calculateScore(int a1, int a2, int a3, int b1, int b2, int b3)",
        "code_context": "#include<cstdio>\n\n//function start\n\n//function end\n\nint main(){\n\tint a1,a2,a3,b1,b2,b3;\n\tscanf(\"%d%d%d%d%d%d\",&a1,&a2,&a3,&b1,&b2,&b3);\n\t//calling start\n\tint result = calculateScore(a1, a2, a3, b1, b2, b3);\n\t//calling end\n\tprintf(\"%d\",result);\n}",
        "example": "[{\"input\": \"2 9 8\\n9 3 10\", \"output\": \"3\"}, {\"input\": \"1 8 5\\n2 5 6\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1994,
        "problem_description": "输入一个非负整数，输出它各位数字相加的结果",
        "function_declaration": "int calculateSum(int n)",
        "code_context": "#include<cstdio>\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    // calling start\n    int result = calculateSum(n);\n    // calling end\n    printf(\"%d\\n\",result);\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"3\"}, {\"input\": \"67\", \"output\": \"13\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2321,
        "problem_description": "给定 $n$ 个数字 $a_1,a_2,…,a_n$，从 1 到 $n$ 中挑出 $i$ 与 $j$ 并要求 $i<j$，将 $a_i$ 与 $a_j$ 组成一个有序的序对 $(a_i,a_j)$。请统计，能从序列中挑选出多少种互不相等的数对？两个数对 $(x,y)$ 与 $(p,q)$ 称之为不相等，是指 $x≠p$ 或 $y≠q$。",
        "function_declaration": "int countUniquePairs(int n, vector<int>& arr) ",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to count the number of unique pairs\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n\n    // Calling the function to count the number of unique pairs\n    //calling start\n    int result = countUniquePairs(n, arr);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"4\\n3 1 3 2\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2114,
        "problem_description": "输入一个非负整数 n，计算 2 的 n 次方（$2^n$）。",
        "function_declaration": "double calculatePower(int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    // calling start\n    double result = calculatePower(n);\n    // calling end\n    printf(\"%.0lf\", result);\n}",
        "example": "[{\"input\": \"3\", \"output\": \"8\"}, {\"input\": \"200\", \"output\": \"1606938044258990275541962092341162602522202993782792835301376\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1564,
        "problem_description": "输入一个n*m大小的矩阵，将其行列互换，第1行换成第1列，第2行换成第2列，依此类推。1 <= n, m <= 100，输出m行，每行n个整数，表示互换之后的矩阵。",
        "function_declaration": "void printMatrix(int m, int n, int nums[][100])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    int nums[100][100];\n    \n    for (int i=0; i<n; i++)\n        for (int j=0; j<m; j++)\n            cin >> nums[j][i];\n    \n    // calling start\n    printMatrix(m, n, nums);\n    // calling end\n    \n    return 0;\n}",
        "example": "[{\"input\": \"2 3\\n1 2 3\\n4 5 6\", \"output\": \"1 4\\n2 5\\n3 6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2140,
        "problem_description": "成书于汉代的《九章算术》是我国古代的一本数学专著。在其中一个章节里，讨论了一个盈亏问题：今有（人）买（物），（每）人出八（钱）盈余三（钱），（每）人出七（钱）不足四（钱），问人数、物价各几何？大意是说，一群人组团买一件物品，若每人出8元，则比物价多了3元；若每人出7元，则比物价少了4元，求物价及参与的人数。假设有一群人买一件物品，如果每个人出 $a$元，所付的总金额比物品的价格多了 $x$元；如果每个人出 $a-1$元，所付的总金额比物品的价格少了 $y$元。给定 $a,x,y$，求人数及物品的价格，输出两个整数：第一个整数表示参与的人数，第二个整数表示物品的价格，中间用一个空格分开。",
        "function_declaration": "void findPeopleAndPrice(int a, int x, int y)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// Function to find the number of people and the price of the item\n//function start\n\n//function end\n\nint main() {\n    int a, x, y;\n    cin >> a >> x >> y;\n\n    // Call the function to find the number of people and the price of the item\n    //calling start\n    findPeopleAndPrice(a, x, y);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"8 3 4\", \"output\": \"7 53\"}, {\"input\": \"5 2 6\", \"output\": \"8 38\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2276,
        "problem_description": "给定一个长度为 n 的整数数组和 q 个询问，每次询问给出一个区间，在此区间中找到一段连续的数（至少1个），使得它们的和最大。",
        "function_declaration": "vector<int> maxSubarraySum(vector<int>& nums, vector<pair<int, int>>& queries)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the maximum subarray sum within a given range\n//function start\n\n//function end\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        int l, r;\n        cin >> l >> r;\n        queries[i] = make_pair(l, r);\n    }\n\n    // Find the maximum subarray sum within each query range\n    //calling start\n    vector<int> results = maxSubarraySum(nums, queries);\n    //calling end\n\n    // Output the results\n    for (int i = 0; i < q; i++) {\n        cout << results[i] << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"9 2\\n-1 8 3 -7 5 3 -9 2 6\\n1 9\\n4 4\", \"output\": \"12\\n-7\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2215,
        "problem_description": "小爱可以玩两个游戏，每个游戏各有 $n$ 关，每过一关升一级，每关的通关时间是不同的。给定一个整数 $t$，表示小爱玩游戏的时间，请问她应该如何分配时间，才能让升级的次数达到最大？",
        "function_declaration": "int calculateMaxPassengers(long long a[], long long b[], int n, int t)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tlong long a[100001], b[100001];\n\tint n, t;\n\tcin >> n >> t;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> b[i];\n\t}\n\t// calling start\n\tint result = calculateMaxPassengers(a, b, n, t);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"4 22\\n6 8 10 7 \\n7 11 9 9\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1641,
        "problem_description": "现有一棵根节点为1且按照顺序存储的完全二叉树。我们已知完全二叉树的最后一个结点是n。我们想知道，以结点m为根节点，其所在的子树中一共包括多少个结点。",
        "function_declaration": "int getNodeNum(int n,int m)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\nint n, m, ans;\n\nvoid getAns(int pos) {\n    ans++;\n    if (pos * 2 <= n)\n        getAns(pos * 2);\n    if (pos * 2 + 1 <= n)\n        getAns(pos * 2 + 1);\n    return;\n}\n// function start\n\n// function end\n\nint main() {\n    cin >> n >> m;\n    // calling start\n    ans =  getNodeNum(n,m);\n    // calling end\n    cout << ans;\n    return 0;\n}",
        "example": "[{\"input\": \"7 3\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1498,
        "problem_description": "求两数的积。说明/提示：每个数字不超过 10^2000 ，需用高精度。",
        "function_declaration": "string multiply(string num1, string num2)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    string num1, num2;\n    cin >> num1 >> num2;\n    // calling start\n    string result = multiply(num1, num2);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"123456789\\n987654321\", \"output\": \"121932631112635269\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1571,
        "problem_description": "输入一个数字，判断它是否既是5的倍数，又是7的倍数。",
        "function_declaration": "bool isDivisibleBy5And7(int a)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a;\n    cin >> a;\n    // calling start\n    bool result = isDivisibleBy5And7(a);\n    // calling end\n    if (result) {\n        cout << \"yes\";\n    }\n    else {\n        cout << \"no\";\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"35\", \"output\": \"yes\"}, {\"input\": \"1\", \"output\": \"no\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1779,
        "problem_description": "有2Xn的一个长方形方格，用一个1*2的骨牌铺满方格。例如当n=3时，用骨牌铺满2X3的长方形方格，一共有3种方法，输入一个整数n (1 ≤ n ≤ 50)，表示需要填满方格的长度，请计算方案数量。",
        "function_declaration": "long long fibonacci(int n)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long a[60];\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin >> n;\n    // calling start\n    long long result = fibonacci(n);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2014,
        "problem_description": "给出三条线段的长度，均是不大于10000的正整数。打算把这三条线段拼成一个三角形，它可以是什么三角形呢？如果三条线段不能组成一个三角形，输出Not triangle；如果是直角三角形，输出Right triangle；如果是锐角三角形，输出Acute triangle；如果是钝角三角形，输出Obtuse triangle；如果是等腰三角形，输出Isosceles triangle；如果是等边三角形，输出Equilateral triangle。如果这个三角形符合以上多个条件，请按以上顺序分别输出，并用换行符隔开。",
        "function_declaration": "string triangleType(int a, int b, int c)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main()\n{\n    int a, b, c;\n    cin >> a >> b >> c;\n    //calling start\n    string result = triangleType(a, b, c);\n    //calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"3 3 3\", \"output\": \"Acute triangle\\nIsosceles triangle\\nEquilateral triangle\"}, {\"input\": \"3 4 5\", \"output\": \"Right triangle\"}, {\"input\": \"6 10 6\", \"output\": \"Obtuse triangle\\nIsosceles triangle\"}, {\"input\": \"1 14 5\", \"output\": \"Not triangle\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2324,
        "problem_description": "给定 n 个非负整数，计算其中所有奇数的和。",
        "function_declaration": "int calculateOddSum(int n, vector<int>& numbers)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> numbers(n);\n    for (int i = 0; i < n; i++) {\n        cin >> numbers[i];\n    }\n\n    //calling start\n    int oddSum = calculateOddSum(n, numbers);\n    //calling end\n\n    cout << oddSum << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n1 2 3 4 5 6\", \"output\": \"9\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1993,
        "problem_description": "输入一个整数，输出它mod \\ 5的结果",
        "function_declaration": "int calculateRemainder(int n)",
        "code_context": "#include<cstdio>\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    // calling start\n    int result = calculateRemainder(n);\n    // calling end\n    printf(\"%d\\n\", result);\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"3\"}, {\"input\": \"-1\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1790,
        "problem_description": "把整数1 ~ 10依次赋予某个int型数组，然后用int型指针输出该数组元素的值。",
        "function_declaration": "void printArray(int* ptr, int size)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, *ptr;\n    ptr = a;\n    // calling start\n    printArray(ptr, 10);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \" \", \"output\": \"1 2 3 4 5 6 7 8 9 10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1934,
        "problem_description": "所有的网页浏览器都有访问、前进与后退按钮，它们的工作原理如下：访问操作需要用户提供一个网址，浏览器将会访问该网址，并将该网址的前继设为跳转前的网址；后退操作会检查当前网址是否有前继（除第一个网址外，每个网址都有前继），如果有，浏览器将访问当前网址的前继；前进是用于抵消后退的：若前一步是后退，浏览器退回至后退前的网页。若前一步是访问，忽略这条前进操作。若前一步也是前进，若上步前进已经抵消了一个后退，则根据更早的操作确定前进的作用，否则，忽略这条操作。给定 n 条操作，请你模拟浏览器的行为，并输出它执行每条操作时所访问的网址。保证每个输入的网址长度不会超过 30；对于 30% 的数据，1 ≤n≤ 1000；对于 60% 的数据，1 ≤n≤ 10000；对于 100% 的数据，1 ≤n≤ 50000。输入单个正整数 n 表示操作数量； 接下来 n 步操作，访问以字母 v 开头，后接一条网址，用空格隔开，保证该网址中间没有空格或者其他不可见字符；后退仅有一个字母 b；前进仅有一个字母 f。输出共 n 行：对每一步操作，如果浏览器访问了某个网址，则输出该网址；如果浏览器忽略了这部操作，则输出一个 ？。",
        "function_declaration": "void simulateBrowser(int n, vector<string>& operations)",
        "code_context": "#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Function to simulate browser behavior\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<string> operations(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> operations[i];\n    }\n\n    //calling start\n    simulateBrowser(n, operations);\n    //calling end\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"10\\nv iai.sh.cn\\nv scs.sh.cn\\nv yacs.club\\nb\\nb\\nf\\nf\\nf\\nv ioinformatics.org\\nf\", \"output\": \"iai.sh.cn\\nscs.sh.cn\\nyacs.club\\nscs.sh.cn\\niai.sh.cn\\nscs.sh.cn\\nyacs.club\\n?\\nioinformatics.org\\n?\"}, {\"input\": \"8\\nv iai.sh.cn\\nv taobao.com\\nv baidu.com\\nb\\nb\\nv tmall.com\\nf\\nb\", \"output\": \"iai.sh.cn\\ntaobao.com\\nbaidu.com\\ntaobao.com\\niai.sh.cn\\ntmall.com\\n?\\niai.sh.cn\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1704,
        "problem_description": "有若干只鸡和兔同在一个笼子里，从上面数，有n个头，从下面数，有m只脚。请问笼中各有多少只鸡和兔。",
        "function_declaration": "pair<int, int> calculate(int n, int m)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    // calling start\n    pair<int, int> result = calculate(n, m);\n    // calling end\n    cout << result.first << \" \" << result.second << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"2 6\", \"output\": \"1 1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1378,
        "problem_description": "输入n，输出n行的平行四边形，用*打印平行四边形。",
        "function_declaration": "void printPattern(int n)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    //calling start\n    printPattern(n);\n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \"4\", \"output\": \"****\\n ****\\n  ****\\n   ****\"}, {\"input\": \"3\", \"output\": \"***\\n ***\\n  ***\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1902,
        "problem_description": "用户输入密码输入两次，判断两次密码是否不一致。",
        "function_declaration": "bool checkPasswordConsistency(char* passWord1, char* passWord2)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    char userName[21];\n    char passWord1[21];\n    char passWord2[21];\n    printf (\"请输入你的用户名\\n\");\n    scanf (\"%s\", userName);\n    printf (\"请输入你的密码\\n\");\n    scanf (\"%s\", passWord1);\n    printf (\"请再次输入密码\\n\");\n    scanf (\"%s\", passWord2);\n    // calling start\n    if (checkPasswordConsistency(passWord1, passWord2))\n        printf (\"%s你好，欢迎来到伯禹商城\", userName);\n    else\n        printf (\"两次密码不一致\");\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"Akatsuki\\n123456789\\n123456789\\n\", \"output\": \"请输入你的用户名\\n请输入你的密码\\n请再次输入密码\\nAkatsuki你好，欢迎来到伯禹商城\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2301,
        "problem_description": "小爱经营了一家牧场生产牛奶，接下来$n$天时间里，每天都有订单，其中第$i$天，必须发出$a_i$?箱牛奶。生产牛奶的成本来自于两方面：一是材料费。原料价格每天都会变化，如果选择在第$i$天生产牛奶，需要为每箱牛奶支付$c_i$?元的材料费。二是存储费。如果原材料成本上涨，可以提前把牛奶做好，放在冷库里保存，但需要支付仓储费，一箱牛奶存放一天的成本是$s$元。每天的产能都没有上限，也就是说可以在任一天生产出任意多数量的牛奶，冷库的容量也没有上限，且假设牛奶可以存放任意长的时间。请问，为了满足这些订单的要求，小爱应该如何规划每天的产量，又如何存储，才能把总成本控制到最小？输出单个整数表示为了满足所有订单的最小总成本。",
        "function_declaration": "long long calculateSum(int n, long long s, long long a[], long long c[])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tlong long s;\n\tcin >> n >> s;\n\tlong long a[1000001], c[1000001];\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> c[i] >> a[i]; \t\n\t}\n\n    // calling start\n\tlong long sum = calculateSum(n, s, a, c);\n    // calling end\n\n    cout << sum;\n}",
        "example": "[{\"input\": \"3 10\\n100 5\\n200 5\\n90 20\", \"output\": \"2850\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1863,
        "problem_description": "逢七必过的游戏规则如下：从一个正整数出发，依次报数，遇到7的倍数或个位数是7的情况，则不报数，输出pass。给定开始游戏的第一个整数a，和结束游戏时的最后一个整数b，请输出整个报数过程。输出若干行：每行一个数字或者一个单词pass。",
        "function_declaration": "void checkNumber(int a, int b)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    // calling start\n    checkNumber(a, b);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"5 8\", \"output\": \"5\\n6\\npass\\n8\"}, {\"input\": \"42 49\", \"output\": \"pass\\n43\\n44\\n45\\n46\\npass\\n48\\npass\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1792,
        "problem_description": "编写一个用于在字符串中查找某字符的函数。查找成功，函数返回该字符的地址（指针），查找失败，返回的指针为NULL。如果找到，输出字符在源字符串中的序号(序号起始为1）；如果找不到，输出Not Found。",
        "function_declaration": "void findCharacter(char* str, char c)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    char str[100];\n    char c;\n    cin.getline(str, 100, ' ');\n    cin>>c;\n    // calling start\n    findCharacter(str, c);\n    // calling end\n}",
        "example": "[{\"input\": \"ABCDEFGHIJKLMN D\", \"output\": \"4\"}, {\"input\": \"ABCDEFG S\", \"output\": \"Not Found\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2283,
        "problem_description": "给定 $n$ 个整数 $a_1,a_2,...,a_n$，请计算一组乘积，记为 $P_1,P_2,...,P_n$，其中 $P_i$ 的定义如下：$$P_i = \\frac{a_1  a_2  a_3  a_n}{a_i}$$也就是说，$P_i$ 是 $a_1$ 到 $a_n$ 的连乘再除去 $a_i$。由于答案可能比较大，输出每个 $P_i$ 模 $10000$ 的余数。",
        "function_declaration": "vector<int> calculateProductArray(int n, vector<int>& nums)",
        "code_context": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to calculate the product array\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    // Calculate the product array and output the results\n    //calling start\n    vector<int> result = calculateProductArray(n, nums);\n    //calling end\n\n    for (int i = 0; i < n; i++) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"4\\n1 3 4 6\", \"output\": \"72\\n24\\n18\\n12\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1706,
        "problem_description": "本题要求从输入的N个整数中查找给定的X。如果找到，输出X第一次出现的位置（从1开始计数）；如果没有找到，返回-1。",
        "function_declaration": "int findElement(int n, int x, int a[])",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[110];\n\n// function start\n\n// function end\n\nint main() {\n    int n, x, i;\n    cin >> n;\n    for (i = 1; i <= n; i++)\n        cin >> a[i];\n    cin >> x;\n    // calling start\n    int result = findElement(n, x, a);\n    // calling end\n    if (result != -1)\n        cout << result << endl;\n    else\n        cout << \"Not Found\" << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 4 2 3 5\\n3\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1716,
        "problem_description": "输出自然数1到n所有排列。输入n (1<=n<=9)。输出由 1~n 组成的所有数字序列，每行一个序列（序列中允许出现重复数字）。",
        "function_declaration": "void generatePermutations(int n)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to generate all permutations of 1 to n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    //calling start\n    generatePermutations(n);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"2\", \"output\": \"1 1\\n1 2\\n2 1\\n2 2\"}]",
        "time_limit": 10000,
        "memory_limit": 256
    },
    {
        "id": 1846,
        "problem_description": "给定一个数列，初始为空，请支持下面三种操作：给定一个整数x，请将x加入到数列中。输出数列中最小的数。删除数列中最小的数（如果有多个数最小，只删除1个）。输入第一行是一个整数，表示操作的次数n。接下来n行，每行表示一次操作。每行首先有一个整数op表示操作类型。若op = 1，则后面有一个整数x，表示要将x加入数列。若op = 2，则表示要求输出数列中的最小数。若op = 3，则表示删除数列中的最小数。如果有多个数最小，只删除1个。对于100%的数据，保证1 ≤ n ≤ 10^6，1 ≤ x < 2^31。对于每个操作2，输出一行一个整数表示答案。",
        "function_declaration": "void processOperations(int n)",
        "code_context": "#include <iostream>\n#include <queue>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    //calling start\n    processOperations(n);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 2\\n1 5\\n2\\n3\\n2\", \"output\": \"2\\n5\\n\"}]",
        "time_limit": 5000,
        "memory_limit": 256
    },
    {
        "id": 2309,
        "problem_description": "小爱和小明在玩一个游戏，每个人的游戏目标是为自己夺取尽量多的分数。游戏一共有$n$轮，每一轮游戏都对应一个分数，分数在游戏开始前就是给定的，记为$a_1,a_2,...,a_n$。每一轮游戏中，手上有花的人可以做出选择：她可以选择保留花。这样，这轮的分数就会送给对方，而到下一轮的时候，花仍在自己手上；她可以选择取走这一轮的分数。这样，到下一轮的时候，花就是对方的，但这一轮的分数就是自己的；游戏开始前，花在小爱手里。若双方都会使用最佳策略去尽量多得获得分数，那么小爱可以获得多少分数呢？输出小爱获得的最大分数。",
        "function_declaration": "int maxScore(vector<int>& a)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    // Calling the function to find the maximum score that Little Ai can get\n    //calling start\n    int maxScoreA = maxScore(a);\n    //calling end\n\n    cout << maxScoreA << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"4\\n5 2 7 3\", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1752,
        "problem_description": "有一栋大楼总共有N (1 ≤ N ≤ 200)层。大楼的每一层楼都可以停电梯，而且第i (1 <= i <= N)层楼上有一个数字Ki (0 <= Ki <= N)。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如：3 3 1 2 5代表了Ki ( K1=3, K2=3, …… )，从一楼开始。在一楼，按上可以到4楼，按下是不起作用的，因为没有-2楼。那么，从A楼到B楼至少要按几次按钮呢？输入三个正整数，表示N A B。全部数据保证1 ≤ A,B ≤ N。输入N个正整数，表示Ki。输出最少按键次数，若无法到达，则输出-1。",
        "function_declaration": "int calculateButtonPress(int N, int A, int B, vector<int> K)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int N, A, B;\n    cin>>N>>A>>B;\n    vector<int> K(N);\n    for(int i=0; i<N; i++){\n        cin>>K[i];\n    }\n    // calling start\n    int result = calculateButtonPress(N, A, B, K);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"5 1 5\\n3 3 1 2 5\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1988,
        "problem_description": "博小鱼要到文具店里买铅笔。已知一只签字笔的价格是 1 元 9 角，他现在有 a 元 b 角， 博小鱼非常喜欢这里的铅笔，因为他很好用，所以他想知道这些钱最多可以买多少铅笔。",
        "function_declaration": "int calculatePrice(int a, int b)",
        "code_context": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main(){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n\n    //calling start\n    int result = calculatePrice(a, b);\n    //calling end\n\n    printf(\"%d\", result);\n    return 0;\n}",
        "example": "[{\"input\": \"10 3\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1984,
        "problem_description": "那是一个不知在何处、不知何时就存在的地方，一位叫做 Conless 的神建立了他的王国。为了更好的管理他的领土，他决定改革历法，采用新的日历来记时。Conless 所在的地方比较独特，一天只有 10000s。而为了便于记忆，Conless 规定，一年被等分为 0 ~ 19 这 20 个月，而每个月又均等地分为 0 ~ 19 这 20 天。现在是 0 年 0 月 0 日 0 秒，Conless 做出了一些规划，在某年某月某日前要完成某个任务，而完成这个任务需要花费一定的时间 t 。Conless 想知道这个任务能不能在截止日期之前完成，请你写一段程序帮助他解答这个问题。输入有两个整数和一个四位小数，表示年月 y,m 和日 d (d 保证大于等于0 且 小于20)，一个整数，表示所需时间 t，所有输入保证合法，且输入数字均不超过10^15为了防止浮点误差带来影响，本题不会出现 t 表示时刻正好等于输入的年月日的情况。",
        "function_declaration": "bool check(long long y, long long m, double d, long long t)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    long long y,m,t;\n    double d;\n    scanf(\"%lld%lld%lf%lld\",&y,&m,&d,&t);\n    // calling start\n    bool result = check(y, m, d, t);\n    // calling end\n    if(result) {\n        printf(\"Yes\");\n    } else {\n        printf(\"No\");\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"0 0 1.0000\\n10001\", \"output\": \"No\"}, {\"input\": \"100000000 1 1.0000\\n1919810114514\", \"output\": \"Yes\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2148,
        "problem_description": "竞选班长的条件是：语文、数学、英语三门成绩中，至少两门大于或等于90分，而且体育不能低于85分。给定小爱的语文、数学、英语及体育成绩，请问她能否竞选班长？如果可以竞选班长，返回1；否则，返回0。",
        "function_declaration": "int countQualified(int a, int b, int c, int d)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n  int a, b, c, d;\n  cin >> a >> b >> c >> d;\n  \n  // calling start\n  int result = countQualified(a, b, c, d);\n  // calling end\n  \n  if (result == 1)\n    cout << \"Qualified\";\n  else\n    cout << \"Not qualified\";\n}",
        "example": "[{\"input\": \"91\\n96\\n99\\n89\", \"output\": \"Qualified\"}, {\"input\": \"84\\n91\\n85\\n95\", \"output\": \"Not qualified\"}, {\"input\": \"94\\n98\\n97\\n80\", \"output\": \"Not qualified\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2199,
        "problem_description": "在一个国家的各个城市之间，需要进行物资的调配。给定一个整数 $n$，表示这个国家的城市数量。再给定一列整数 $a_1,a_2,?,a_n$，表示每个城市生产或者消费物资的数量——正数表示对应城市是生产物资的，其绝对值代表产量；负数表示对应城市是消费物资的，其绝对值代表消费量；这些城市之间的道路网络呈一条直线，只有编号相邻的城市有道路相连。从某个城市搬运一个单位的物资到相邻城市将产生一个单位的工作量。请设计一个方案，使得每个城市需要的物资都能达成，且运输的总工作量达到最小，输出表示最优运输方案产生的最少工作总量。输入数据保证生产总量和消费总量是相等的，即 $a_1+a_2+?+a_n=0$。",
        "function_declaration": "long long calculateCost(int n, int* arr)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n\tint n;\n\tcin >> n;\n\tint* arr = new int[n];\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> arr[i];\n\t}\n\t// calling start\n\tlong long cost = calculateCost(n, arr);\n\t// calling end\n\tcout << cost;\n\tdelete[] arr;\n}",
        "example": "[{\"input\": \"4\\n-10 10 20 -20\", \"output\": \"30\"}, {\"input\": \"5\\n100 -10 -20 -30 -40\", \"output\": \"300\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2320,
        "problem_description": "有$n$个整数$a_1,a_2,…,a_n$?，一开始，所有数字都是0，接下来将根据输入数据依次进行$q$条修改操作：加法修改操作以字符+开头，后接两个整数$p$与$d$，表示数列的第$p$项将增加$d$；乘法修改操作以字符*开头，后接一个整数$m$，表示数列的每一项都将乘以$m$。请输出经过修改后数列，由于答案可能很大，输出每一个数字模1,000,000,007的余数。",
        "function_declaration": "vector<int> modifiedSequence(int n, int q, vector<pair<char, pair<int, int>>>& queries)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\n// Function to perform modifications on the sequence\n//function start\n\n//function end\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<pair<char, pair<int, int>>> queries(q);\n    for (int i = 0; i < q; i++) {\n        cin >> queries[i].first;\n        if (queries[i].first == '+') {\n            cin >> queries[i].second.first >> queries[i].second.second;\n        } else if (queries[i].first == '*') {\n            cin >> queries[i].second.first;\n        }\n    }\n\n    //calling the function to perform modifications on the sequence\n    //calling start\n    vector<int> result = modifiedSequence(n, q, queries);\n    //calling end\n\n    for (int i = 0; i < n; i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"3 5\\n+ 1 3\\n* 10\\n+ 2 6\\n+ 3 9\\n* 5\", \"output\": \"150 30 45\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1369,
        "problem_description": "求两个正整数a，b的最大公约数。",
        "function_declaration": "int gcd(int a, int b)",
        "code_context": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  \tint a = 0, b = 0;\n  \tcin >> a >> b;\n  \t// calling start\n  \tcout << gcd(a, b) <<'\\n';\n  \t// calling end\n\treturn 0;\n}",
        "example": "[{\"input\": \"12 18\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1576,
        "problem_description": "使用两个cout语句，输出两行各一句话：This is line No.1.\nThis is line No.2.",
        "function_declaration": "void printLines()",
        "code_context": "#include <iostream>\nusing namespace std; \n\n//function start\n\n//function end\n\nint main() {\n    //calling start\n    printLines();\n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \"无输入\", \"output\": \"This is line No.1.\\nThis is line No.2.\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1940,
        "problem_description": "给定一个字符，用它构造一个对角线长5个字符，倾斜放置的菱形。",
        "function_declaration": "void printDiamond(char a)",
        "code_context": "#include <iostream> \nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    char a;\n    cin >> a;\n\n    // calling start\n    printDiamond(a);\n    // calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"*\", \"output\": \"  *\\n ***\\n*****\\n ***\\n  *\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2348,
        "problem_description": "给定一个二进制数，将其转为十进制输出。",
        "function_declaration": "int calculateBinaryToDecimal(string s)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s; \n\n//function start\n\n//function end\n\nint main(){\n    cin>>s;\n    //calling start\n    n = calculateBinaryToDecimal(s);\n    //calling end\n    cout<<n; \n}",
        "example": "[{\"input\": \"10000000010\", \"output\": \"1026\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1684,
        "problem_description": "金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。设第j件物品的价格为w[j]，重要度为v[j]，共选中了k件物品，编号依次为j1，j2，...，jk，则所求的总和为：w[j1] * v[j1] + w[j2] * v[j2] + …+ w[jk] * v[jk]。（其中*为乘号）请你帮助金明设计一个满足要求的购物单，返回一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<100000000）。",
        "function_declaration": "int calculateMaxValue(int m, int n, int w[], int v[], int f[])",
        "code_context": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint w[35],v[35],f[50005]; //w代表价格，v代表价值\nint n,m;\n\n//function start\n\n//function end\n\nint main()\n{\n    scanf(\"%d %d\",&m,&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d %d\",&w[i],&v[i]); //输入每个商品的价格和价值\n    }\n    //calling start\n    int result = calculateMaxValue(m, n, w, v, f);\n    //calling end\n    printf(\"%d\",result); //输出\n    return 0;\n}",
        "example": "[{\"input\": \"1000 5\\n800 2\\n400 5\\n300 5\\n400 3\\n200 2\", \"output\": \"3900\"}]",
        "time_limit": 1000,
        "memory_limit": 125
    },
    {
        "id": 2074,
        "problem_description": "小万最近学会了整除运算。他发现整除的威力很大。他随意写了一个正整数 1000，不断用 2 除它。他惊讶的发现 1000 除以 10 次 2 之后就会变成0。1000 -> 500 -> 250 -> 125 -> 62 -> 31 -> 15 -> 7 -> 3 -> 1 -> 0\n1000和10的差距很大。他想知道这是不是普遍规律，所以丢给你一个整数，请你输出它经过多少次除以2后变成0。",
        "function_declaration": "int countBits(int x)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n = 0;\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint x = 0;\n\t\tcin >> x;\n\t\t// calling start\n\t\tint t = countBits(x);\n\t\t// calling end\n\t\tcout << t << \"\\n\";\n\t}\n\treturn 0;\n}",
        "example": "[{\"input\": \"4\\n0 1 2 1000\\n\", \"output\": \"0\\n1\\n2\\n10\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2271,
        "problem_description": "给定 n 个整数，输出平均值。",
        "function_declaration": "double calculateAverage(vector<int>& nums)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to calculate the average of n integers\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    // Calculate the average\n    //calling start\n    double average = calculateAverage(nums);\n    //calling end\n\n     printf(\"%.2lf\", average);\n\n    return 0;\n}",
        "example": "[{\"input\": \"5 \\n5 4 3 2 1\", \"output\": \"3.00\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1650,
        "problem_description": "已知一张图有n个点，点的编号为1 ~ n，现在给出该图的邻接矩阵，请你以节点x为第一次的起点，进行深度优先遍历，并输出节点访问的顺序。对于任一起点，若有多个出路，则首先遍历的是序号最小的点。并保证最后的遍历顺序的字典序最小。对于全部测试数据满足n ≤ 100。输入第一行两个整数n x，n表示图的顶点数，x表示遍历的开始顶点；接下来n行，每行n个整数，表示该图的邻接矩阵，若为0表示没有边，为1则表示有边。输出一行，以顶点x为起点的深度优先遍历序列，每个数字用空格隔开。",
        "function_declaration": "void dfs(int node, const vector<vector<int>>& graph, vector<bool>& visited, vector<int>& traversal)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to perform Depth First Search (DFS) from a given node\n//function start\n\n//function end\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n\n    vector<vector<int>> graph(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> graph[i][j];\n        }\n    }\n\n    vector<bool> visited(n + 1, false);\n    vector<int> traversal;\n\n    //calling start\n    dfs(x, graph, visited, traversal);\n    //calling end\n\n    for (int node : traversal) {\n        cout << node << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"4 1\\n0 1 0 1\\n1 0 1 1\\n0 1 0 1\\n1 1 1 0\", \"output\": \"1 2 3 4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1687,
        "problem_description": "给出一个长度为 n 的序列 a，选出其中连续且非空的一段使得这段和最大，返回最大和。",
        "function_declaration": "int maxSubarraySum(int n, vector<int>& a)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> a(n);\n    for(int i=0; i<n; i++){\n        cin>>a[i];\n    }\n    // calling start\n    int result = maxSubarraySum(n, a);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"7\\n2 -4 3 -1 2 -4 3\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2273,
        "problem_description": "给定 n 个整数和一个表示提问次数的整数q，每次提问中给出一个整数a。问是否能在 n 个整数中选择若干个求和，使和不小于 a。",
        "function_declaration": "vector<bool> checkSum(vector<int>& nums, int q)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to check if it's possible to select some integers and their sum is not less than a\n//function start\n\n//function end\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    // Check if it's possible to select some integers and their sum is not less than a\n    //calling start\n    vector<bool> result = checkSum(nums, q);\n    //calling end\n\n    // Output the results\n    for (int i = 0; i < q; i++) {\n        if (result[i]) {\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"6 3\\n3 -8 7 0 -6 6\\n16\\n-7\\n17\", \"output\": \"Yes\\nYes\\nNo\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1840,
        "problem_description": "假设在周末舞会上，男士们和女士们进入舞厅时，各自排成一队。跳舞开始时，依次从男队和女队的队头上各出一人配成舞伴。规定每个舞曲能有一对跳舞者。若两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一个程序，模拟上述舞伴配对问题。输入3个整数m，n，k，分别表示男士人数、女士人数、 几轮舞曲。输出各轮舞曲的配对方案，每行输出一个配对中的男士和女士序号，用空格隔开。",
        "function_declaration": "void dancePartners(int m, int n, int k)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int m, n, k;\n    cin >> m >> n >> k;\n //calling start\n    dancePartners(m, n, k);\n //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"2 4 6\", \"output\": \"1 1\\n2 2\\n1 3\\n2 4\\n1 1\\n2 2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1848,
        "problem_description": "编程计算由1围成的下类图形的面积。面积的计算方法是统计1所围成的闭合曲线中水平线和垂直线交点的数目。如下所示，在10*10的二维数组中，1围住了2个点；因此面积为2。0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 0 0 0\n0 1 0 1 0 0 0 0 0 0\n0 1 0 1 0 0 0 0 0 0\n0 0 1 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 1 0 0\n0 0 0 0 0 0 0 0 0 0，输入为十行，每行十个0或1，表示地图。输出一个整数表示1围住的面积。",
        "function_declaration": "int calculateArea(int grid[10][10])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int grid[10][10];\n\n    // Input grid\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 10; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    //calling start\n    int area = calculateArea(grid);\n    //calling end\n\n    cout << area << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"0 0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0 0\\n0 0 1 0 0 0 0 0 0 0\\n0 1 0 1 0 0 0 0 0 0\\n0 1 0 1 0 0 0 0 0 0\\n0 0 1 0 0 0 0 1 0 0\\n0 0 0 0 0 0 0 1 0 0\\n0 0 0 0 0 0 0 0 0 0\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2111,
        "problem_description": "给定一个整数 a，输出 a 的相反数（即-a）。",
        "function_declaration": "long long calculateNegative(long long a)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    long long a;\n    cin>>a;\n    // calling start\n    long long result = calculateNegative(a);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"-3\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2338,
        "problem_description": "定义符号 $\\gcd(a,b)$ 表示 $a$ 和 $b$ 的最大公因子。$\\gcd$ 满足这样几条性质：$\\gcd(a,b)=\\gcd(b,a)$若 $a = 0$，$\\gcd(a,b)=\\gcd(0,b)=b$。若 $a<b$，$\\gcd(a,b)=\\gcd(a,b-a)$。请计算最大公因子。",
        "function_declaration": "int gcd(int a, int b)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint a, b;\n\tcin >> a >> b;\n\t// calling start\n\tint result = gcd(a, b);\n\t// calling end\n\tcout << result << endl;\n\treturn 0;\n}",
        "example": "[{\"input\": \"33 121 \", \"output\": \"11\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1699,
        "problem_description": "斐波那契数列是指这样的数列：第一个数和第二个数都为 1，接下来每个数都等于前面两个数之和。编程输入一个正整数n，输出斐波那契数列第n个数。",
        "function_declaration": "int fibonacci(int n)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int a;\n    cin >> a;\n    // calling start\n    int result = fibonacci(a);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1979,
        "problem_description": "小鱼现在希望输出可变长度的小数，你能帮帮她吗？输入为一个小数b（在float范围内），一个长度n（$1\\leqn\\leq20$），输出小数部分长度为n的b（整数部分保留）注意：需要四舍五入和补末尾零。",
        "function_declaration": "void printFixedPrecision(double b, int n)",
        "code_context": "#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<iomanip>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+1;\nconst int INF=1e9+7;\n#define test(x) cout<<(x)<<endl;\n\n// function start\n\n// function end\n\nint main()\n{\n    int n;\n    double b;\n    cin>>b>>n;\n    // calling start\n    printFixedPrecision(b, n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"1.111 3\", \"output\": \"1.11\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1952,
        "problem_description": "分别输入狗和猫的数量，输出总数。",
        "function_declaration": "int calculatePet(int dog, int cat)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int dog;\n    int cat;\n    int pet;\n    cout << \"读入狗和猫的数量\\n\";\n    cin >> dog;\n    cin >> cat; \n    // calling start\n    pet = calculatePet(dog, cat);\n    // calling end\n    cout << \"BOYU宠物店的宠物总数为\" << pet; \n  \treturn 0;\n}",
        "example": "[{\"input\": \"14 16\", \"output\": \"读入狗和猫的数量\\nBOYU宠物店的宠物总数为30\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1736,
        "problem_description": "新学期开始了，小哈是小哼的新同学，小哼向小哈询问QQ号，小哈当然不会直接告诉小哼。所以小哈给了小哼一串加密过的数字，同时小哈也告诉了小哼解密规则。规则是这样的：首先将第1个数删除，紧接着将第2个数放到这串数的末尾，再将第3个数删除并将第4个数再放到这串数的末尾，再将第5个数删除……直到剩下最后一个数，将最后一个数也删除。按照刚才删除的顺序，把这些删除的数连在一起就是小哈的QQ啦。现在你来帮帮小哼吧。小哈给小哼加密过的一串数是6 3 1 7 5 8 9 2 4。解密后小哈的QQ号应该是6 1 5 9 4 7 2 8 3。输入n个整数为加密过的QQ号，每个整数在 1~9 之间。对于100%的数据满足1 ≤ n ≤ 10^5，输出解密后的QQ号。",
        "function_declaration": "deque<int> decryptQQ(deque<int> encryptedQQ) \n",
        "code_context": "#include <iostream>\n#include <deque>\n\nusing namespace std;\n\n// Function to decrypt the QQ number\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    deque<int> qq;\n\n    for (int i = 0; i < n; ++i) {\n        int num;\n        cin >> num;\n        qq.push_back(num);\n    }\n    //calling start\n    deque<int> decryptedQQ = decryptQQ(qq);\n    //calling end\n    for (int num : decryptedQQ) {\n        cout << num << \" \";\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"9\\n6 3 1 7 5 8 9 2 4\", \"output\": \"6 1 5 9 4 7 2 8 3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1581,
        "problem_description": "请你利用switch语句实现如下功能：2021年是平年，输入一个月份（1～12），输出2021年的该月份的天数。",
        "function_declaration": "string getMonthDays(int a)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a;\n    cin >> a;\n    // calling start\n    cout << getMonthDays(a);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"2\", \"output\": \"28\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1661,
        "problem_description": "将 1,2,…,9 共 9 个数分成三组，分别组成三个三位数，且使这三个三位数的比例是 a : b : c，试求出所有满足条件的三个三位数，若无解，输出 No!!!。输入三个数，a, b, c。输出若干行，每行 3 个数字。按照每行第一个数字升序排列。",
        "function_declaration": "void generateValidCombinations(int a, int b, int c)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to generate all valid combinations of three 3-digit numbers with the given ratio\n//function start\n\n//function end\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n\n    //calling start\n    generateValidCombinations(a, b, c);\n    //calling end\n    \n    return 0;\n}",
        "example": "[{\"input\": \"1 2 3\", \"output\": \"192 384 576\\n219 438 657\\n273 546 819\\n327 654 981\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2260,
        "problem_description": "Nijika的姐姐Ijichi Seika（伊地知星歌）正在对结束乐队进行考核，以决定结束乐队是否有在下一次Live演出中上场的资格。结束乐队需要完成一次试演，而Seika将会综合考察乐队的吉他水平、贝斯水平、主唱水平和爵士鼓水平。现在试演刚刚结束，结束乐队演出了原创歌曲《吉他与孤独与蓝色星球》，请你帮助Seika判断结束乐队是否通过考核。Seika已经对结束乐队的吉他水平、贝斯水平、主唱水平和爵士鼓水平进行了评分，分数分别为 $a,b,c,d$。乐队的整体评分由下面的式子计算得到：$score = 100 \\times (\\frac{a}{100} \\cdot \\frac{b}{100} \\cdot \\frac{c}{100} \\cdot \\frac{d}{100})$将 score 四舍五入到整数，如果 score 不低于60，则认为结束乐队通过考核。",
        "function_declaration": "bool checkPass(int a, int b, int c, int d)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    // calling start\n    bool result = checkPass(a, b, c, d);\n    // calling end\n    if(result) cout<<\"pass\";\n    else cout<<\"fail\";\n}",
        "example": "[{\"input\": \"90 90 90 90\", \"output\": \"pass\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2351,
        "problem_description": "给定 n 个正整数，选择其中两个数，使得乘积不超过 m，在此前提下使乘积最大。输出一个数，表示满足题目要求的最大乘积。",
        "function_declaration": "long long findMaxProduct(long long n, long long m, long long a[])",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a[200010]; \n\n// function start\n\n// function end\n\nint main(){\n\tlong long n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i) cin>>a[i];\n\t\n\t// calling start\n\tlong long result = findMaxProduct(n, m, a);\n\t// calling end\n\t\n\tcout<<result;\n}",
        "example": "[{\"input\": \"4 27\\n3 9 4 7\", \"output\": \"27\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1549,
        "problem_description": "输入两个数字，输出他们的和。两个变量或常量求和时，可以用+连接二者，例如求变量a与常量2的和，则可写为a + 2。",
        "function_declaration": "int add(int a, int b)",
        "code_context": "#include <iostream>\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    // calling start\n    cout << add(a, b);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"1 2\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2179,
        "problem_description": "小万又拉着小橙去跳格子啦！广场上有 $n$ 个格子，依次编号为 $1,2,\\cdots,n$。每个格子上都写着一个格子编号，且彼此不相同。小万和小橙轮流游戏。每一轮，玩家随意挑选一个从没有跳到过的格子，然后从这个格子开始，根据格子上写的编号，确定下一步去到哪个格子。当他跳到已经过的格子，他的轮次结束。第一轮小橙行动。当一个人跳完他的轮次后，场上不再有未曾经过的格子，另一个人就输了。请你帮小万同学判断他能不能赢吧！输入一个整数 $n$，表示格子的数量。$1\\le n\\le 10^6$。有 $n$ 个整数 $a_i$，$1\\le i \\le n$ 且互不相同。如果小万赢了，输出win，否则输出uim。",
        "function_declaration": "bool canWin(vector<int>& grid) ",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> grid(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        cin >> grid[i];\n    }\n\n    //calling start\n    if (canWin(grid)) {\n        cout << \"win\" << endl;\n    } else {\n        cout << \"uim\" << endl;\n    }\n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n2 1 3\", \"output\": \"win\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2116,
        "problem_description": "小A和小B正在玩一个拼点游戏。拼点指双方各以牌面向下的方式出一张手牌后同时亮出，牌面上的点数大的一方赢。游戏开始时小A和小B各有 n 张手牌，每回合双方同时打出一张手牌进行拼点，赢的一方得2分。如果平局，则双方各得1分。n 回合后双方打完手牌，游戏结束。你已经提前看过了双方的手牌，现在小A想请你告诉他，游戏结束时他可能得到的最高分数是多少？输入a包含 n 个整数，表示小A的 n 张手牌的点数。b包含 n 个整数，表示小B的 n 张手牌的点数。输出个整数，表示小A可能得到的最高分数。",
        "function_declaration": "int calculateMaxScore(vector<int>& a, vector<int>& b)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n    }\n\n    //calling start\n    int maxScore = calculateMaxScore(a, b);\n    cout << maxScore << endl;\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n1 9 8\\n9 3 10\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1761,
        "problem_description": "课间操时间到了，有部分同学已经按照个子从低到高排成了一个队伍。这时候来了一位新同学小白，他站在队伍的后面，老师带着小白从队伍的最后往前走，一边走一边比较小白和同学们的身高，当找到第一位比小白矮的同学时，老师就让小白站到该同学的后面，其余同学往后顺移一位。这时候又来了一位新同学小黑，老师重复刚才小白的操作，为小黑找到了位置，又来了一些新同学……请你模拟上面的操作，为n个数来排序。",
        "function_declaration": "void sortArray(int a[], int n)",
        "code_context": "#include <bits/stdc++.h>\n#define N 1550\nusing namespace std;\nint a[N], n;\n\n//function start\n\n//function end\n\nint main() {\n    cin >> n; \n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    \n    //calling start\n    sortArray(a, n);\n    //calling end\n    \n    for (int i = 1; i <= n; ++i) \n        cout << a[i] << ' ';\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n7 4 6 8 3\", \"output\": \"3 4 6 7 8\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2297,
        "problem_description": "逆波兰式就是后缀表达式，它的定义如下：单个数字如6，8等都是后缀表达式；如果$e_1$，$e_2$都是后缀表达式，则$e_1 e_2 +$、$e_1 e_2 -$、$e_1 e_2 *$ 都是后缀表达式；不满足以上两条规则的表达式都不是后缀表达式。给定一个后缀表达式（保证合法），请计算表达式的值，并输出它模10的余数。注意，为了方便起见，我们省略了除法，同时也规定在表达式中出现的数字只能由一位数构成。",
        "function_declaration": "int evaluatePostfix(string postfix) ",
        "code_context": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\n\n// Function to evaluate the given postfix expression and return the result modulo 10\n//function start\n\n//function end\n\nint main() {\n    string postfix;\n    getline(cin, postfix);\n\n    // Calling the function to evaluate the postfix expression and get the result modulo 10\n    //calling start\n    int result = evaluatePostfix(postfix);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"3 4 +\", \"output\": \"7\"}, {\"input\": \"2 3 3 + *\", \"output\": \"12\"}, {\"input\": \"1 2 * 3 + 4 * 5 - 6 + 7 * 8 - 9 +\", \"output\": \"8\"}, {\"input\": \"1 5 -\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1842,
        "problem_description": "一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同，如果给定单词仅是文章中某一单词的一部分则不算匹配。输出只有一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从0开始）；如果单词在文章中没有出现，则返回整数-1。",
        "function_declaration": "pair<int, int> findWordInText(const string& text, const string& word)",
        "code_context": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    string text;\n    string word;\n    getline(cin, text); // Read the whole line as text\n    cin >> word;\n\n    // Convert both text and word to lowercase for case-insensitive matching\n    transform(text.begin(), text.end(), text.begin(), ::tolower);\n    transform(word.begin(), word.end(), word.begin(), ::tolower);\n\n    //calling start\n    pair<int, int> result = findWordInText(text, word);\n    //calling end\n    if (result.first!= -1)\n        cout << result.first << \" \" << result.second;\n    else\n        cout << -1;\n\n    return 0;\n}",
        "example": "[{\"input\": \"To\\nto be or not to be is a question\", \"output\": \"2 0\"}, {\"input\": \"to\\nDid the Ottoman Empire lose its power at that time\", \"output\": \"-1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1898,
        "problem_description": "1个for循环可以打印出：12345678910。for (i = 1; i <= 10; i++) { \n    cout << i;\n} \n3个for循环可以打印出：12345678910\n12345678910\n12345678910\nfor (i = 1; i <= 10; i++) { \n    cout << i;\n} \ncout << endl;\nfor (i = 1; i <= 10; i++) { \n    cout << i;\n} \ncout << endl;\nfor (i = 1; i <= 10; i++) { \n    cout << i;\n} \ncout << endl;\n请使用 嵌套的for循环改写上面的代码。",
        "function_declaration": "void printNumbers()",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    // calling start\n    printNumbers();\n    // calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"12345678910\\n12345678910\\n12345678910\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1783,
        "problem_description": "小A和小B在一起吃零食。他们在地上画了并排$n$个格子，每个格子里面放了不同数量的糖果。小B他会问小A，从第$x$个格子到第$y$个格子总共有多少个糖果？",
        "function_declaration": "int calculateSum(int x, int y, int a[])",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, x, y, a[110];\n\n// function start\n\n// function end\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; ++i)\n        cin >> a[i];\n    cin >> m;\n    while (m--) {\n        cin >> x >> y;\n        // calling start\n        int sum = calculateSum(x, y, a);\n        // calling end\n        cout << sum << endl;\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 3 2 5 0\\n4\\n1 2\\n2 3\\n1 5\\n3 3\", \"output\": \"4\\n5\\n11\\n2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2305,
        "problem_description": "有一条道路需要铺设地砖，这条道路由 $n×2$ 个方格组成。存在两种规格的地砖，一种是 $1×2$ 规格的，也就是恰好可以覆盖两个方格，另一种是 $2×2$ 规格的。两种规格的砖头的数量没有限制。请计算有多少种方法，将这条道路铺满地砖。由于方案数可能很大，输出它模 1,000,000,007 的余数即可。",
        "function_declaration": "int calculate_f(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    //calling start\n    int result = calculate_f(n);\n    //calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"2\", \"output\": \"3\"}, {\"input\": \"8\", \"output\": \"171\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2258,
        "problem_description": "一个图像的平滑处理涉及很多复杂的算法。简单起见，我们把一个图像简化为一个 n 行 m 列的整数方阵。而最基本的图像平滑处理操作大致如下:对于 i 行 j 列的整数，将其变为其周围 3 * 3 的正方形范围的整数的平均值向下取整。如果该整数在方阵的边或角上，那么只需变为 3 * 3 的正方形和方阵的交集部分的平均值向下取整即可。输入为第一行三个正整数 n,m,k ，表示方阵的高和宽，以及平滑处理次数。后面 n 行每行 m 个整数，表示该位置初始整数。保证所有输入整数绝对值不超过 100 且合法。现在，请你输出方阵在经过了 k 次平滑处理后的最终结果，输出 n 行，每行 m 个整数，表示该位置 k 次平滑处理后的整数。",
        "function_declaration": "vector<vector<int>> imageSmoothing(int n, int m, int k, vector<vector<int>>& matrix)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to perform the image smoothing operation\n//function start\n//function end\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<int>> matrix(n, vector<int>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    // Calling the function to perform image smoothing\n    //calling start\n    vector<vector<int>> result = imageSmoothing(n, m, k, matrix);\n    //calling end\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cout << result[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"2 4 1\\n1 2 3 4\\n5 6 7 8\", \"output\": \"3 4 5 5\\n3 4 5 5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2024,
        "problem_description": "有强迫症的 Darksharpless 希望把他手中的数字补成刚好八位（有前导零），你能帮帮他吗？输入一个数字 n，补全为 8 位后的数字。",
        "function_declaration": "string formatNumber(int n)",
        "code_context": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main () {\n    int n = 0;\n    cin >> n;\n    // calling start\n    string result = formatNumber(n);\n    // calling end\n    cout << result << '\\n';\n    return 0;\n}",
        "example": "[{\"input\": \"1\", \"output\": \"00000001\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1997,
        "problem_description": "小A和小B正在玩一个猜数游戏。规则如下：小B先想一个正整数 n 并告诉小A，然后在心里想一个大小不超过 n 的正整数，小A每次可以猜一个数，如果这个数比小B想的数小，小B会回答“猜小了”，其他情况则不会回答。小A也随时可以选择停止猜数，并说出自己认为小B想的数，如果说对则小A赢，否则小A输，游戏结束。现在小B已经将 n 告诉小A，小A想请你告诉他，他最少需要猜多少次才能保证，无论小B想的数是多少，最后他都能赢。",
        "function_declaration": "int calculateLog(int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int t,n;\n    cin>>t;\n    while(t--){\n        cin>>n;\n        // calling start\n        int result = calculateLog(n);\n        // calling end\n        cout<<result<<endl;\n    }\n}",
        "example": "[{\"input\": \"2\\n1\\n8\", \"output\": \"0\\n3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1944,
        "problem_description": "给定 3 个整数 a,b,c，计算表达式 $\\frac{(a+b)}{c}$ 的值。",
        "function_declaration": "float calculate(float a, float b, float c)",
        "code_context": "#include<cstdio>\n\n// function start\n\n// function end\n\nint main(){\n    float a,b,c;\n    scanf(\"%f%f%f\",&a,&b,&c);\n    // calling start\n    float result = calculate(a, b, c);\n    // calling end\n    printf(\"%.2f\", result);\n}",
        "example": "[{\"input\": \"0 1 2\", \"output\": \"0.50\"}, {\"input\": \"1 -1 1\", \"output\": \"0.00\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2264,
        "problem_description": "Bocchi正在为演出的定额而烦恼。突然，她想到了一个绝妙的办法：只需要自己买下全部定额的票不就行了吗！然而，这样做将会需要大量的资金，因此Bocchi想要在接下来的一段打工生活中赚到最多的钱。你能帮帮她吗？输入共 m+1 行，第一行包含两个正整数 n,m，n 表示Bocchi打工生活的总时长，m 表示Bocchi可以接取的打工任务数量。接下来 m 行，每行包含 3 个正整数 l,r,s，表示一个从 l 时刻开始，到 r 时刻结束的打工任务，完成后可得到的报酬为 s。Bocchi同时只能打一份工，因此Bocchi接取的任意两个打工任务 $(l_1,r_1,s_1),(l_2,r_2,s_2)$ 都必须满足$l_1 < r_1 \\le l_2 < r_2$ 或者 $l_2 < r_2 \\le l_1 < r_1$ （也就是说，选择的打工任务中任意两个的时间段[l,r)必须没有重合部分）。对于 30% 的数据，$m \\le 10$；对于另 10% 的数据，每个打工任务都满足 $l = r - 1$；对于另 20% 的数据，每个打工任务都满足 $s = 10000$；对于以上部分和另 20% 的数据（共 80% 的数据），$n,m \\le 1000$；对于 100% 的数据，$n,m \\le 100000$，$1 \\le l < r \\le n$，$s \\le 20000$。输出一个数，表示Bocchi通过打工最多能赚到多少钱。",
        "function_declaration": "int calculateMaxEarnings(int n, int m, vector<pair<pair<int, int>, int>>& jobDetails)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<pair<int, int>, int>> jobDetails(m + 1);\n    for (int i = 1; i <= m; ++i) {\n        cin >> jobDetails[i].first.first >> jobDetails[i].first.second >> jobDetails[i].second;\n    }\n\n    //calling start\n    int earnings = calculateMaxEarnings(n, m, jobDetails);\n    //calling end\n\n    cout << earnings << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"10 5\\n1 5 10000\\n3 6 12000\\n7 9 5000\\n8 10 4000\\n5 8 4000\", \"output\": \"18000\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2274,
        "problem_description": "给定一个正整数 n，计算 $1+\\frac{1}{2\\sqrt{2}}+\\frac{1}{3\\sqrt{3}}+\\dots+\\frac{1}{n\\sqrt{n}}$。",
        "function_declaration": "double calculate_ans(long long n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    long long n;\n    cin>>n;\n    // calling start\n    double result = calculate_ans(n);\n    // calling end\n    printf(\"%.3lf\",result);\n}",
        "example": "[{\"input\": \"3\", \"output\": \"1.546\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2259,
        "problem_description": "结束乐队有4名成员，她们分别是Ijichi Nijika（伊地知虹夏）、Yamada Ryo（山田凉）、Goto Hitori（后藤一里）和Kita Ikuyo（喜多郁代）。给出一名成员的名字，输出其简称。输入仅一行，为\"Ijichi Nijika\"、\"Yamada Ryo\"、\"Goto Hitori\"、\"Kita Ikuyo\"四个名字之一。输出为一行，根据输入的名字输出对应的简称。如果是伊地知虹夏，输出\"Nijika\"；如果是山田凉，输出\"Ryo\"；如果是后藤一里，输出\"Bocchi\"；如果是喜多郁代，输出\"Kita\"。",
        "function_declaration": "string checkName(string a, string b)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n\tstring a,b;\n\tcin>>a>>b; // 读入两个以空格分隔的字符串 \n\n\t// calling start\n\tstring result = checkName(a, b);\n\t// calling end\n\n\tif(result != \"\") cout<<result;\n\treturn 0; \n}",
        "example": "[{\"input\": \"Ijichi Nijika\", \"output\": \"Nijika\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2015,
        "problem_description": "DarkSharpness 是一个数学爱好者。 DarkSharpness 眼里，完美数是这样的 : 如果某个数字的每个数位的立方和等于自己，那么这个数字就是完美的。例如 153，数位的立方和为 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153，此时 153 就是一个完美数字。而又比如 201，数位立方和为 2 * 2 * 2 + 0 * 0 * 0 + 1 * 1 * 1 = 9 ，不等于 201，所以不是完美数字。现在，给你任意一个非负整数，你能判断它是不是完美数吗 ?一个非负整数 n ，保证 n 小于 1000，如果是完美数，返回 Yes否则，返回 No",
        "function_declaration": "string isPerfectNumber(int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    // calling start\n    string result = isPerfectNumber(n);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"370\", \"output\": \"Yes\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2158,
        "problem_description": "每天签到一个应用程序，至少可以得1分，若前一天也签到了，则当天得分为前一天的得分加1，一天最多只能得5分。给定一个由Y及N构成的字符序列，该序列表示小爱每天签到的情况，签到记为Y，没到记为N。请统计小爱能够获得的总积分。",
        "function_declaration": "int calculateTotalScore(string signIns) ",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// Function to calculate the total score based on the sign-in pattern\n//function start\n\n//function end\n\nint main() {\n    string signIns;\n    cin >> signIns;\n    //calling start\n    int totalScore = calculateTotalScore(signIns);\n    //calling end\n    cout << totalScore << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"YYNYYYYYYNNNYYY\", \"output\": \"29\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1715,
        "problem_description": "给定一个长度为n (1 <= n <= 100000)的序列，请你将他们从小到大排序。注：请使用归并排序",
        "function_declaration": "void sortArray(int n, int a[])",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[100010];\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    // calling start\n    sortArray(n, a);\n    // calling end\n    for (int i = 1; i <= n; i++)\n        cout << a[i] << \" \";\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n3 5 2 1 4\", \"output\": \"1 2 3 4 5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1904,
        "problem_description": "请判断用户输入的密码是否全部为阿拉伯数字构成。思路：先读入字符串，然后一个一个字符检查是否在‘0’～‘9’之间。先立1个flag，检查过程中如果有不符合条件的就让flag=0，并跳出循环。最后检查结束，查看flag的值。",
        "function_declaration": "bool checkPasswordValidity(char passWord[], int length)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  char passWord[21];\n  int length;\n  printf (\"请输入你的密码\\n\");\n  scanf (\"%s\", passWord);\n  length = strlen(passWord);\n  \n  // calling start\n  bool isValid = checkPasswordValidity(passWord, length);\n  // calling end\n  \n  if (isValid)\n      printf (\"你设置的密码有效\");\n  else\n      printf (\"你设置的密码无效\");\n  return 0;\n}",
        "example": "[{\"input\": \"1234567890\", \"output\": \"请输入你的密码\\n你设置的密码有效\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1772,
        "problem_description": "回文串的意思是，该字符串“从左往右读”和“从右往左读”的结果是一样的，比如“tenet” 。现有若干个字符串，请你一一判断他们是否为回文串。",
        "function_declaration": "bool isPalindrome(char* s)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar s[1010];\n\n// function start\n\n// function end\n\nint main() {\n    while (cin >> s) {\n        // calling start\n        bool result = isPalindrome(s);\n        // calling end\n        cout << (result ? \"Yes!\" : \"No!\") << endl;\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"abcba\\nabccba\\nabcd\", \"output\": \"Yes!\\nYes!\\nNo!\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1744,
        "problem_description": "有一棵完全二叉树，每个节点都有一个值，并满足：若当前节点值为A，若有左子树则左分支节点的值是A*2+1，若有右子树则右分支节点的值是A*3+2。开始时我们仅知道根节点的值root，现提供一个节点的层数和位置并希望找到该节点的值。",
        "function_declaration": "long long calculateNodeValue(int root, int level, int position)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int root, n;\n    cin>>root>>n;\n    // calling start\n    for(int i=0; i<n; i++){\n        int level, position;\n        cin>>level>>position;\n        int nodeValue = calculateNodeValue(root, level, position);\n        cout<<nodeValue<<endl;\n    }\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"1 3\\n2 1\\n3 1\\n3 4\", \"output\": \"3\\n7\\n17\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2036,
        "problem_description": "给定一个整数N，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零。",
        "function_declaration": "int reverseNumber(int n)",
        "code_context": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\t// calling start\n\tint result = reverseNumber(n);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"123\", \"output\": \"321\"}, {\"input\": \"-380\", \"output\": \"-83\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2350,
        "problem_description": "相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。小A正在学习汉诺塔问题的解法：设需要移动的盘子数为 n，可以通过以下三步解决汉诺塔问题。(1)以C杆为中介，从A杆将1至n-1号盘移至B杆；(2)将A杆中剩下的第n号盘移至C杆；(3)以A杆为中介；从B杆将1至n-1号盘移至C杆。现在给定盘子的数量 n，盘子从小到大编号依次为 1 到 n，请按照小A上面学到的解法，输出移动盘子的过程。输出若干行，表示移动过程。例如，将 1 号盘从 A 杆移至 B 杆，对应的输出是\"1 A B\"。",
        "function_declaration": "void solve(int n,char a,char b,char c)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n\tint n;\n\tcin>>n;\n\t// calling start\n\tsolve(n,'A','B','C');\n\t// calling end\n}",
        "example": "[{\"input\": \"2\", \"output\": \"1 A B\\n2 A C\\n1 B C\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1579,
        "problem_description": "请用switch语句实现：输入一个英文字母，输出该字母表示的成绩等级。A表示“优秀”；B表示“良”；C表示“及格”；D表示“不及格”。输出一个字符串，优秀为\"perfect\"，良为\"great\"，及格为\"good\"，不及格为\"miss\"。",
        "function_declaration": "string evaluateGrade(char c)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    char c;\n    cin >> c;\n    // calling start\n    string result = evaluateGrade(c);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"A\", \"output\": \"perfect\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2166,
        "problem_description": "给定一个正整数$n$，请打印一个空心的正方形，它的边界由*构成，每条边都恰好有$n$个字符。",
        "function_declaration": "void drawSquare(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n  int n;\n  cin >> n;\n  // calling start\n  drawSquare(n);\n  // calling end\n}",
        "example": "[{\"input\": \"5\", \"output\": \"*****\\n*   *\\n*   *\\n*   *\\n*****\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2180,
        "problem_description": "小万同学和小橙同学发掘了一个骨灰级别的游戏——超级弹珠。游戏的内容是：在一个 $n*n$ 的矩阵里有若干个棋子。你可以放置弹珠在一个没有棋子的地方，然后用它弹飞同一行和同一列的棋子，然后你的得分就是这些棋子的价值之和。小万想要在小橙面前大展身手，请你来帮他确定他最多的得分。输入一个正整数 $n$，$1\\le n\\le 1000$。接下来 $n$ 行，每行 $n$ 列，如果有棋子则为一个 $10^4$ 范围内的正整数，否则为 0。输出共一行表示最多分数。如果没有地方可以放置弹珠，输出 0。",
        "function_declaration": "int maxScore(vector<vector<int>>& grid)",
        "code_context": "#include <bits/stdc++.h>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> grid(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    //calling start\n    int result = maxScore(grid);\n    //calling end\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"4\\n1 1 1 0\\n1 2 2 1\\n1 2 2 1\\n0 1 1 1\\n\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2035,
        "problem_description": "你买了一箱n个苹果，很不幸的是买完时箱子里混进了一条虫子。虫子每x小时能吃掉一个苹果，假设虫子在吃完一个苹果之前不会吃另一个，那么经过y小时你还有多少个完整的苹果？",
        "function_declaration": "int calculateResult(int n, int x, int y)",
        "code_context": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tint n, x, y;\n\tcin >> n >> x >> y;\n\t\n\t// calling start\n\tint result = calculateResult(n, x, y);\n\t// calling end\n\t\n\tcout << result;\n\t\n\treturn 0;\n}",
        "example": "[{\"input\": \"10 4 9\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2243,
        "problem_description": "给定一个 n 行 m 列的整数方阵。请求出指定 a 行 b 列到 c 行 d 列方阵的数字和。输入第一行两个正整数 n,m。后面 n 行每行 m 个整数。最后一行四个正整数 a,b,c,d。保证所有输入合法，且输入整数绝对值不超过 100，输出 a 行 b 列到 c 行 d 列的方阵的数字和。",
        "function_declaration": "int submatrixSum(int n, int m, vector<vector<int> >& matrix, int a, int b, int c, int d) ",
        "code_context": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int> > matrix(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> matrix[i][j];\n        }\n    }\n    \n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    //calling start\n    int result = submatrixSum(n, m, matrix, a, b, c, d);\n    //calling end\n    cout << result << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"2 3\\n1 2 3\\n4 5 6\\n1 1 2 2\", \"output\": \"12\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1729,
        "problem_description": "筛选法又称为筛法，是由希腊著名数学家埃拉托色尼 （Eratosthenes） 提出的一种寻找素数的方法。相比穷举法，筛选法的效率更高。以求 1~20 之内素数为例，具体步骤如下：将所有数（2~n）放入“筛子”中，把 1 删除；2 在筛中，将 2 的倍数 2，4，…，20 删除（筛去）；3 在筛中，将 3 的倍数 6，9，…，18 删除（筛去）；4 不在筛中，不执行删除（筛去）操作；   ……\n10 不在筛中，不执行删除（筛去）操作。现在请你使用筛选法，输入n，找出2～n之内的所有素数。",
        "function_declaration": "vector<int> sieve(int n)",
        "code_context": "#include<bits/stdc++.h>\n#include <vector>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    // calling start\n    vector<int> result = sieve(n);\n    // calling end\n    for(int i=0; i<result.size(); i++){\n        cout<<result[i]<<\" \";\n    }\n}",
        "example": "[{\"input\": \"20\", \"output\": \"2 3 5 7 11 13 17 19\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1598,
        "problem_description": "输入两个数字A和B，要求计算A除以B后输出他们的商。说明：测试数据保证A可以被B整除。",
        "function_declaration": "int division(int a, int b)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    // calling start\n    int result = division(a, b);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"4 2\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1896,
        "problem_description": "下面是用while循环实现的“动次打次”，请用for循环进行改写。样例输出动次打次\n动次打次\n动次打次\n动次打次\nwhile代码：int i = 1;\nwhile (i <= 4) {\n   cout << \"动次打次\\n\";\n   i++;\n}\n",
        "function_declaration": "void printMessage()",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    // calling start\n    printMessage();\n    // calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"动次打次\\n动次打次\\n动次打次\\n动次打次\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1633,
        "problem_description": "一个学校里老师要将班上N个同学排成一列，同学被编号为1～N，他采取如下的方法：先将1号同学安排进队列，这时队列中只有他一个人；2~N号同学依次入列，编号为i的同学入列方式为：老师指定编号为i的同学站在编号为1 ~ (i-1)中某位同学（即之前已经入列的同学）的左边或右边；从队列中去掉M (M<N)个同学，其他同学位置顺序不变。在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。输入一个正整数N，表示了有N个同学。student包含N-1对整数，第i对整数包含两个整数k p，其中k为小于i的正整数，p为0或者1。若p为0，则表示将i号同学插入到k号同学的左边，p为1则表示插入到右边。输入一个正整数M，表示去掉的同学数目。removed包含M个正整数x，表示将x号同学从队列中移去，如果x号同学已经不在队列中则忽略这一条指令。返回一个数组，包含最多N个正整数，表示了队列从左到右所有同学的编号。",
        "function_declaration": "vector<int> arrangeStudents(int N, vector<pair<int, int>>& students, int M, vector<int>& removed)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int N;\n    cin>>N;\n    vector<pair<int, int>> students(N);\n    for(int i=0; i<N; i++){\n        int k, p;\n        cin>>k>>p;\n        students[i] = make_pair(k, p);\n    }\n    int M;\n    cin>>M;\n    vector<int> removed(M);\n    for(int i=0; i<M; i++){\n        cin>>removed[i];\n    }\n    // calling start\n    vector<int> result = arrangeStudents(N, students, M, removed);\n    // calling end\n    for(int i=0; i<result.size(); i++){\n        cout<<result[i]<<\" \";\n    }\n}",
        "example": "[{\"input\": \"4\\n1 0\\n2 1\\n1 0\\n2\\n3\\n3\", \"output\": \"2 4 1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2143,
        "problem_description": "体育馆里有三种球：足球，篮球和排球。已知：足球和篮球共有$a$个；篮球和排球共有$b$个；排球和足球共有$c$个。请问足球，篮球和排球分别各有几个？输入为三行，第一行：一个自然数 a，表示足球和篮球共有 a 个；第二行：一个自然数 b，表示篮球和排球共有 b 个；第三行：一个自然数 c，表示排球和足球共有 c 个；保证输入数据合理，不存在矛盾情况。数据范围$0≤a≤10000$；$0≤b≤10000$；$0≤c≤10000$。输出三行，第一行：一个自然数，表示足球的数量；第二行：一个自然数，表示篮球的数量；第三行：一个自然数，表示排球的数量。",
        "function_declaration": "void calculate(int a, int b, int c)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n    int a, b, c;\n    cin >> a >> b >> c;\n    // calling start\n    calculate(a, b, c);\n    // calling end\n}",
        "example": "[{\"input\": \"8\\n5\\n7\", \"output\": \"5\\n3\\n2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1891,
        "problem_description": "有句俗话叫“三天打渔，两天晒网”。如果小爱前三天打渔，后两天晒网，一直重复这个过程，那么在第n天，它是在打渔还是晒网呢？晒网返回True，打渔返回False。",
        "function_declaration": "bool isLying(int n)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int n;\n  cin >> n;\n  // calling start\n  bool result = isLying(n);\n  // calling end\n  if (result)\n      cout<< \"Lying\\n\";\n  else\n      cout<< \"Fishing\\n\";\n  return 0;\n}",
        "example": "[{\"input\": \"1\", \"output\": \"Fishing\"}, {\"input\": \"10\", \"output\": \"Lying\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1962,
        "problem_description": "请完成小博的自我介绍。让计算机打印出以下内容：”大家好，我叫小博\\n。我今年 $10$ 岁了，我的身高是 $1.5$ 米\\n我上 $4$ 年级了，我的体重是 $52.7$ 千克\\n我最喜欢的数字是 $3.14$\\n“。身高和体重保留1位小数，最喜欢的数字保留两位小数。",
        "function_declaration": "void printInfo(int age, int grade, float height, float weight, float num)",
        "code_context": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int age = 10;\n  int grade = 4;\n  float height = 1.5;\n  float weight = 52.7;\n  float num = 3.14159;\n\n  // calling start\n  printInfo(age, grade, height, weight, num);\n  // calling end\n\n  return 0;\n}",
        "example": "[{\"input\": \" \", \"output\": \"大家好，我叫小博。\\n我今年10岁了，我的身高是1.5米\\n我上4年级了，我的体重是52.7千克\\n我最喜欢的数字是3.14\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1580,
        "problem_description": "输入一个整数，表示小明的成绩（满分100）。请你利用switch语句判断该成绩所属的等级。规则：成绩 >= 90分为“优秀”；成绩 >= 80分为“良”；成绩 >= 60分为“及格”；成绩 <60分为“不及格”。输出一个字符串，优秀为\"perfect\"，良为\"great\"，及格为\"good\"，不及格为\"miss\"。",
        "function_declaration": "string evaluateGrade(int a)",
        "code_context": "#include <iostream>\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a;\n    cin >> a;\n    // calling start\n    string result = evaluateGrade(a);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"99\", \"output\": \"perfect\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2337,
        "problem_description": "小万拿出 $n$ 个纸杯，然后在小橙面前快速交换。聪明的小橙当然看出了物品藏在哪个纸杯下面。她想考考小万，如果将一开始的纸杯依次编号为 $1,2,3,...$，那么小万能交换出哪些排列呢？请你按字典序大小依次输出，一行一个排列。",
        "function_declaration": "void cupPermutations(int n)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    //calling start\n    cupPermutations(n);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"1 2 3\\n1 3 2\\n2 1 3\\n2 3 1\\n3 1 2\\n3 2 1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2285,
        "problem_description": "有 $n$ 名士兵参加了一场激烈的战斗。每个士兵身边有两个伙伴，第 $i$ 号士兵的左侧伙伴编号为 $i-1$，右侧伙伴的编号为和 $i+1$。1 号士兵没有左侧伙伴，$n$ 号士兵没有右侧伙伴。在战斗过程中，陆续牺牲了 $m$ 名士兵。一旦一名士兵牺牲了，存活的士兵就会相互接近，形成新的伙伴关系。给定士兵们牺牲的顺序及编号，请你输出当每个士兵牺牲时，新构成伙伴关系的两个士兵的编号。",
        "function_declaration": "void formNewPartners(vector<int>& partners, int soldier)",
        "code_context": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to form new partner relationships after a soldier is sacrificed\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> partners(n + 1);\n    for (int i = 1; i <= n; i++) {\n        partners[i] = i;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int soldier;\n        cin >> soldier;\n\n        // Form new partner relationships after the soldier is sacrificed\n        //calling start\n        formNewPartners(partners, soldier);\n        //calling end\n\n        // Output the new partner relationships of the left and right soldiers\n        int left_partner = (soldier > 1) ? partners[soldier - 1] : -1;\n        int right_partner = (soldier < n) ? partners[soldier + 1] : -1;\n\n        // Check if any side has no partner and output accordingly\n        if (left_partner == -1) {\n            cout << \"* \";\n        } else {\n            cout << left_partner << \" \";\n        }\n        if (right_partner == -1) {\n            cout << \"*\" << endl;\n        } else {\n            cout << right_partner << endl;\n        }\n    }\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"5 3\\n3\\n2\\n1\", \"output\": \"2 4\\n1 4\\n* 4\"}]",
        "time_limit": 4000,
        "memory_limit": 512
    },
    {
        "id": 1620,
        "problem_description": "期末要到了，小菜同学找到了自己的好朋友顿顿，希望可以预测一下自己这学期是否会挂科。首先，顿顿选取了如“课堂表现”、“自习时长”、“作业得分”、“社团活动参与度”等n项指标作为预测的依据。然后，顿顿根据自己平日里对小菜的暗中观察，以百分制给每一项指标打分，即小菜同学第$i(1 \\leq i \\leq n)$项指标的得分scorei是一个$[0,100]$范围内的整数。鉴于每一项指标的重要性不尽相同，顿顿用一个$[-10,10]$范围内的整数wi来表示第$i(1 \\leq i \\leq n)$项指标的重要程度。最后，小菜同学期末的安全指数y定义如下：$y=ReLU(\\sum_{i=1}^n score_i * w_i)$其中$ReLU(x)=max(0,x)$是一种常见的激活函数。因为使用了ReLU函数，安全指数一定是个非负值。如果安全指数过低（甚至为零），则说明小菜同学这学期很可能要挂科了……已知每一项指标的重要程度$w_i$和相应的得分$score_i$，快来算算小菜同学期末的安全指数吧。",
        "function_declaration": "int calculateSum(int n, vector<pair<int, int>> ws)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    vector<pair<int, int>> ws(n);\n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d%d\", &ws[i].first, &ws[i].second);\n    }\n    // calling start\n    int sum = calculateSum(n, ws);\n    // calling end\n    printf(\"%d\\n\", sum);\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n2 60\\n10 100\\n0 70\\n0 0\\n-10 50\\n10 60\", \"output\": \"1220\"}, {\"input\": \"2\\n-10 100\\n-1 15\", \"output\": \"0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2160,
        "problem_description": "给定一个整数$n$，请找出$n$的最大平方因子。所谓平方因子，就是一个$n$的因子，且是一个完全平方数。最大平方因子就是$n$的所有平方因子中最大的数。如12的最大平方因子为4，81的最大平方因子为其本身，21的最大平方因子为1。",
        "function_declaration": "int calculateSquare(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n  int n; \n  cin >> n;\n  // calling start\n  int result = calculateSquare(n);\n  // calling end\n  cout << result;\n}",
        "example": "[{\"input\": \"12\", \"output\": \"4\"}, {\"input\": \"81\", \"output\": \"81\"}, {\"input\": \"21\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2162,
        "problem_description": "汽水公司的兑换规则如下：收集$b$个瓶盖，可以换一瓶新汽水。收集$c$个 瓶子，也可以换一瓶新汽水。小爱一开始有尚未开封的汽水$a$瓶，请问利用上述规则，最终可以喝到多少瓶汽水？注意不可以向他人借瓶盖或瓶子。",
        "function_declaration": "int calculateSoda(int a, int b, int c)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    // calling start\n    int result = calculateSoda(a, b, c);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"10 5 4\", \"output\": \"17\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2242,
        "problem_description": "Dark 教授有一些点，它们之间有一些边。现在，Dark 教授告诉了你所有边的情况。她希望你能回答出某两个点之间是否有边直接相连，你能完成她的挑战吗?输入信息中，第一行输入m，q， 分别表示边数和询问个数。之后输入 m 行，每行两个正整数x，y，表示点 x 和点 y 之间由一条边。最后 q 行，每行两个正整数x，y，表示一组询问，询问 x 和 y 之间有没有一条边。保证所有输入整数不超过 500，输入q 行，每行对应一组询问。如果询问的两个点之间没有边直接相连，则输出 No否则，输出 Yes。",
        "function_declaration": "void processQuery(int m, int q)",
        "code_context": "#include <iostream>\nusing namespace std;\n\nconst int N = 501;\nbool g[N][N];\n\n// function start\n\n// function end\n\nsigned main() {\n    int m,q;\n    cin >> m >> q;\n    // calling start\n    processQuery(m, q);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"2 3\\n1 2\\n1 3\\n2 1\\n1 3\\n2 3\", \"output\": \"Yes\\nYes\\nNo\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2146,
        "problem_description": "对一个十进制的四位数来说，我们用以下规则将它加密成另一个四位数：首先，将个位和千位对调；然后，将十位和百位对调；最后将每一位数字进行替换操作。替换规则为：0替换成9、1替换成8、2替换成7、3替换成6，9替换成0，其他数字以此类推。例如，对8429加密，则个位和千位对调后得9428；十位和百位对调后得9248；将每个数字替换后得0751。现在给定一个已经被加密过的四位数（称之为 密文），请解密出原本的数字（称之为 明文）。",
        "function_declaration": "int calculate(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n   int n;\n   cin >> n;\n   // calling start\n   int result = calculate(n);\n   // calling end\n   cout << result << \"\\n\";  \n}",
        "example": "[{\"input\": \"0751\", \"output\": \"8429\"}, {\"input\": \"1123\", \"output\": \"6788\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2013,
        "problem_description": "输入一个自然数，输出它的中文念法（拼音形式，小写字母），每两个字之间用空格隔开。",
        "function_declaration": "string numToChinese(int x)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main()\n{\n\tint x;\n\tcin >> x;\n\t//calling start\n\tstring result = numToChinese(x);\n\t//calling end\n\tcout << result;\n\t\n\treturn 0;\n}",
        "example": "[{\"input\": \"14\", \"output\": \"shi si\"}, {\"input\": \"90\", \"output\": \"jiu shi\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2198,
        "problem_description": "有 $n$ 个人在排队办事，其中排在第 $i$ 个位置的人办事时间为 $a_i$。有两个窗口开放，小爱可以将这些人按原始顺序分割成两个队伍，请问，如何分割能够使得两个队列的办事时间总和相差最小？返回单个整数表示两队伍时间总和之差的最小值。",
        "function_declaration": "int calculateMin(int n, int a[])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tint a[100000];\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t  cin >> a[i];\t\n\t}\n\t// calling start\n\tint min = calculateMin(n, a);\n\t// calling end\n\tcout << min;\n}",
        "example": "[{\"input\": \"3\\n1 1 100\", \"output\": \"98\"}, {\"input\": \"6\\n1 2 3 4 5 6\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2370,
        "problem_description": "读入两个“大数”，存储到两个字符串str_a和str_b中，请你将str_a和str_b的每一位分别处理成整数，逆序存储到数组a和b。函数的入参为两个字符串，出参为两个整数数组",
        "function_declaration": "void reverseStore(char* str_a, char* str_b, int* a, int* b)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main(){\n    char str_a[1010], str_b[1010];\n    int a[1010], b[1010];\n    memset(a, 0, sizeof(a)); \n    memset(b, 0, sizeof(b));\n    \n    scanf(\"%s\", str_a);\n    scanf(\"%s\", str_b);\n\n    //calling start\n    reverseStore(str_a, str_b, a, b);\n    //calling end\n\n    //输出整数数组a和数组b\n    for (int i = 0; i < strlen(str_a); i++)\n         cout << a[i];\n    cout << endl;\n    for (int i = 0; i < strlen(str_b); i++)\n         cout << b[i];\n}",
        "example": "[{\"input\": \"20087\\n1876485\", \"output\": \"78002\\n5846781\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1625,
        "problem_description": "考虑一个简单的二分类问题——将二维平面上的点分为$A$和$B$两类。训练数据包含$n$个点，其中第$i$个点$(1 \\leq i \\leq n)$可以表示为一个三元组$(x_i, y_i, type_i)$，即该点的横坐标、纵坐标和类别。在二维平面上任意一条直线可以表示为 $\\theta_0 + \\theta_1 x+\\theta_2 y = 0$ 的形式，即由 $\\theta_0$ $\\theta_1$ 和 $\\theta_2$ 三个参数确定该直线，且满足 $\\theta_1$ $\\theta_2$不同时为$0$.基于这$n$个已知类别的点，我们想要在平面上找到一条直线作为一个线性分类器，具体来说，这条线要把训练数据中的$A$、$B$两类点完美分隔开来，即一侧只有$A$类点、另一侧只有$B$类点。这样，对于任意一个位置类别的点，我们就可以根据它是位于直线的那一侧来预测它的类别了。在本题中我们仅需要处理的查询是：给定一条直线，判断它是否能将训练数据中的$A$、$B$两类点完美分开。输入$n$个点的信息points和types。points包含$x_i$, $y_i$，分别表示第$i$个点的横、纵坐标，$type_i$表示类别，为一个大写英文字母A或B。三个整数 $\\theta_0$、$\\theta_1$ 和 $\\theta_2$，表示查询中给定直线的三个参数。返回一个字符串。如果给定直线可以完美分隔$A$、$B$两类点，则输出Yes；否则输出No。",
        "function_declaration": "string classifyPoints(vector<pair<int, int>>& points, vector<char>& types, int theta0, int theta1, int theta2)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n, m;\n    cin>>n>>m;\n    vector<pair<int, int>> points(n);\n    vector<char> types(n);\n    for(int i=0; i<n; i++){\n        int x, y;\n        char type;\n        cin>>x>>y>>type;\n        points[i] = make_pair(x, y);\n        types[i] = type;\n    }\n    for(int i=0; i<m; i++){\n        int theta0, theta1, theta2;\n        cin>>theta0>>theta1>>theta2;\n        // calling start\n        string result = classifyPoints(points, types, theta0, theta1, theta2);\n        // calling end\n        cout<<result<<endl;\n    }\n}",
        "example": "[{\"input\": \"9 3\\n1 1 A\\n1 0 A\\n1 -1 A\\n2 2 B\\n2 3 B\\n0 1 A\\n3 1 B\\n1 3 B\\n2 0 A\\n0 2 -3\\n-3 0 2\\n-3 1 1\", \"output\": \"No\\nNo\\nYes\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1553,
        "problem_description": "输入一个整数，输出该数的绝对值。额外提示: if语句的写法if ( 表达式 ) {\n    // 如果表达式为真将执行的语句\n}\nelse {\n    // 如果表达式为假将执行的语句（可以没有else分支）\n}\n",
        "function_declaration": "int absoluteValue(int a)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a;\n    cin >> a;\n    // calling start\n    int result = absoluteValue(a);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"-10\", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2255,
        "problem_description": "有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？答案对 $10^9+7$ 取模。输入一个整数 $n$及包含 $n$个整数的数组，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。返回一个整数代表答案。",
        "function_declaration": "int countTriangleWays(int n, vector<int>& sticks)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\n// Function to calculate the number of ways to choose 4 sticks to form a triangle\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> sticks(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> sticks[i];\n    }\n\n    //calling start\n    int ways = countTriangleWays(n, sticks);\n    //calling end\n\n    cout << ways << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"4 \\n1\\n1\\n2\\n2\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1895,
        "problem_description": "下面是用while循环实现的：自动输出1~10的每个整数，空格隔开。请用for循环来改写以下代码：输入：无。输出：1 2 3 4 5 6 7 8 9 10int i = 1;\nwhile (i <= 10) {\n    cout << i << \" \";\n    i++;\n}\n",
        "function_declaration": "void printNumbers()",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    // calling start\n    printNumbers();\n    // calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"1 2 3 4 5 6 7 8 9 10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1950,
        "problem_description": "输入0～99之内的任意一个整数n，第一行输出为n是几位数，如“n是一位数”，第二行输出每一位上的数字，以空格隔开。",
        "function_declaration": "string numberClassification(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin >> n;  \n    // calling start\n    string result = numberClassification(n);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"13\", \"output\": \"13是两位数\\n1 3\"}, {\"input\": \"8\", \"output\": \"8是一位数\\n8\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2325,
        "problem_description": "斐波那契数列的前两项为 1,1，之后每一项都是前两项之和。请输出数列的第 n 项对 998244353 取模的值。",
        "function_declaration": "long long fibonacci(long long n, long long mod)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n\tlong long n,mod=998244353;\n\tcin>>n;\n\t// calling start\n\tlong long result = fibonacci(n, mod);\n\t// calling end\n\tcout<<result;\n}",
        "example": "[{\"input\": \"50\", \"output\": \"607336789\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1673,
        "problem_description": "某次科研调查时得到了n个自然数，每个数均不超过1500000000（1.5*10^9）。已知不相同的数不超过10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。每组输出包含m行（m为n个自然数中不相同数的个数），按照自然数从小到大的顺序输出。每行输出两个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。注：请选择合适排序方法完成本题。",
        "function_declaration": "void countAndPrint(int n, int a[])",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[300000];                    // 防止越界\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin >> n;\n    for(int i = 1;i <= n;i++){\n        cin >> a[i];\n    }\n    // calling start\n    countAndPrint(n, a);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"8\\n2\\n4\\n2\\n4\\n5\\n100\\n2\\n100\", \"output\": \"2 3\\n4 2\\n5 1\\n100 2\"}]",
        "time_limit": 1000,
        "memory_limit": 125
    },
    {
        "id": 1868,
        "problem_description": "有3个候选人\"Li\"、\"Zhang\"和\"Sun\"，和5个选民，每个选民只能投票选一人，要求编一个统计选票得程序，依次输入投票结果，最后输出\"Li\"、\"Zhang\"和\"Sun\"的得票结果。输入五行为五个字符串，输出每行为人名与得票数，以:隔开，要求输出的结果使每一行的冒号上下对齐(即冒号前的字符数相等，不足的以空格补齐)",
        "function_declaration": "void countVotes() ",
        "code_context": "#include <iostream>\n#include <map>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    //calling start\n    countVotes();\n    //calling end\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"Zhang\\nSun\\nLi\\nSun\\nZhang\", \"output\": \"   Li:1\\nZhang:2\\n  Sun:2\"}, {\"input\": \"Sun\\nSun\\nZhang\\nLi\\nSun\", \"output\": \"   Li:1\\nZhang:1\\n  Sun:3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1996,
        "problem_description": "求一个正整数四舍五入到十位的结果",
        "function_declaration": "int calculate(int n)",
        "code_context": "#include<cstdio>\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    // calling start\n    int result = calculate(n);\n    // calling end\n    printf(\"%d\", result);\n    return 0;\n}",
        "example": "[{\"input\": \"84\", \"output\": \"80\"}, {\"input\": \"105\", \"output\": \"110\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1915,
        "problem_description": "要计算一个学生的 GPA，先将每门学科的等第换算成为一个绩点，规则为： 等第 A 为4分； 等第 B 为3分； 等第 C 为2分； 等第 D 为1分； 如果有 + 号后缀，则加0.3分。例如B+ 为 3.3分； 如果有 - 号后缀，则减0.3分。 例如C- 为 1.7分。 接下来，再计算这些分数的平均数，四舍五入保留两位小数即可获得 GPA。 给定一个字符序列表示小爱每门课程的等第，请计算她的GPA。记n表示输入字符序列的长度，有1 ≤n≤ 1000。",
        "function_declaration": "double calculateGPA(string str)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    string str;\n    cin >> str;\n    // calling start\n    double result = calculateGPA(str);\n    // calling end\n    cout << fixed << setprecision(2) << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"ABAB\", \"output\": \"3.50\"}, {\"input\": \"A+AA-B-BB+C+\", \"output\": \"3.33\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2261,
        "problem_description": "结束乐队顺利通过了考核，现在正在筹备Live演出，演出地点是由伊地知星歌开设的Livehouse “STARRY”。虽然伊地知星歌并不会额外收取Livehouse的使用费，但结束乐队必须承担在Livehouse演出的定额，也就是说，需要卖出指定的票数。定额是 m 张票，因为乐队成员有4人，所以每位成员承担的定额是 $\\frac{m}{4}$ 张。到现在为止结束乐队已经售出了 n 张票。请你帮忙统计售票信息，判断4名成员的定额完成情况。输入共 n+1 行，第一行包含两个正整数 n，m。接下来 n 行，每行包含以空格分开的一个字符串 s 和一个非负整数 t，表示乐队成员 s 在 t 时刻卖出了一张票。对于 40% 的数据，$n,m \\le 1000$，售票信息按照时间顺序给出（也就是说 t 为升序，后面的 t 一定不小于前面的 t）；对于 80% 的数据，$n,m \\le 1000$；对于 100% 的数据，$n,m \\le 100000$，m 是 4 的倍数，s 是\"Nijika\",\"Ryo\",\"Bocchi\",\"Kita\"之一，t 在int的表示范围内。输出共四行，依次输出 Nijika,Ryo,Bocchi,Kita 四位成员完成售票定额的时刻。如果对应成员尚未完成售票定额，输出-1。",
        "function_declaration": "void process(vector<int> v[], int m)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nmap<string,int> mp;\nstring a[4]={\"Nijika\",\"Ryo\",\"Bocchi\",\"Kita\"};\nvector<int> v[4];\nint n,m;\n\n// function start\n\n// function end\n\nint main(){\n    for(int i=0;i<4;++i) mp[a[i]]=i;\n    cin>>n>>m;\n    m/=4;\n    for(int i=0;i<n;++i){\n        string s;\n        int t;\n        cin>>s>>t;\n        v[mp[s]].push_back(t);\n    }\n    // calling start\n    process(v, m);\n    // calling end\n}",
        "example": "[{\"input\": \"20 20\\nNijika 0\\nNijika 7\\nKita 1\\nKita 6\\nKita 5\\nRyo 8\\nRyo 4\\nNijika 9\\nNijika 6\\nNijika 5\\nBocchi 3\\nBocchi 5\\nBocchi 4\\nKita 6\\nKita 2\\nRyo 9\\nRyo 6\\nRyo 2\\nKita 8\\nKita 7\", \"output\": \"9\\n9\\n-1\\n6\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1597,
        "problem_description": "定义一个常量a的值为3，输入数字b，求出常量a与变量b的乘积，两个变量或常量求乘积时，可以用*连接二者，例如求变量a与常量2的乘积，则可写为a * 2。",
        "function_declaration": "int multiply(int a, int b)",
        "code_context": "#include <iostream>\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    const int a = 3;\n    int b;\n    cin >> b;\n    // calling start\n    int result = multiply(a, b);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"5\", \"output\": \"15\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2201,
        "problem_description": "$n$ 的阶乘记为 $n!$，定义如下：$$n!=1×2×...×n$$给定两个正整数 $n$ 与 $m$，请计算 $n!$ 除以 $m$ 的余数。",
        "function_declaration": "long long calculate_s(int n, int m)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\n\t// calling start\n\tlong long result = calculate_s(n, m);\n\t// calling end\n\n\tcout << result; \n}",
        "example": "[{\"input\": \"5 1000\", \"output\": \"120\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1653,
        "problem_description": "计算非负整数m到n（包括m和n）之间的所有奇数的和，其中，m不大于n，且n不大于300。例如m = 3，n = 12，其和则为：3+ 5 + 7 + 9 + 11 = 35。",
        "function_declaration": "int calculateSum(int m, int n)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    // calling start\n    int result = calculateSum(m, n);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"7 15\", \"output\": \"55\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1788,
        "problem_description": "用指针编写一个对整型数组进行冒泡排序函数。冒泡排序是指将相邻的元素进行比较，如果不符合所要求的顺序，则交换这两个元素；对整个数列中所有的元素反复运用上法，直到所有的元素都排好序为止。输入为第一行一个整数n，表示序列中数字个数。第二行n个整数，表示该序列。输出为一行n个整数，表示排序后的序列，中间用空格隔开，最后一个整数后不加空格。",
        "function_declaration": "void bubble_up(int *ptr, int count)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    int list[100];\n    for (int x = 0; x < n; x++)\n        cin >> list[x];\n    // calling start\n    bubble_up(list, n);\n    // calling end\n    for (int i = 0; i < n; i++)\n        cout << list[i] << \" \";\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n503 87 512 61 908\", \"output\": \"61 87 503 512 908\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1557,
        "problem_description": "输入一个年份，判断其是否为闰年。",
        "function_declaration": "bool isLeapYear(int a)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a;\n    cin >> a;\n    // calling start\n    bool result = isLeapYear(a);\n    // calling end\n    if(result)\n        cout << \"yes\";\n    else\n        cout << \"no\";\n    return 0;\n}",
        "example": "[{\"input\": \"2021\", \"output\": \"no\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2210,
        "problem_description": "在超市里，有一些价格标签倒置后，数字竟不会发生改变。转置 180 度后不变的十进制数字被称为中心对称数（Strobogrammatic Numbers）。下图分别给出$0$到$9$这十个数字倒置后的样子：中心对称数是指沿中心旋转 180 度后不变的十进制正整数。0，1，8 旋转后不变；6 旋转后为 9，9 旋转后为 6；其他数字旋转后不能构成合理的数字。给定一个正整数字符串 $s$，请判断 $s$ 是否是中心对称数。注意有一部分输入将会非常大。",
        "function_declaration": "bool isStrobogrammatic(string s)",
        "code_context": "#include<iostream>\n#include<string>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n\tstring s;\n\tcin >> s;\n\t// calling start\n\tbool result = isStrobogrammatic(s);\n\t// calling end\n\tif (result) \n\t   cout << \"Strobogrammatic number\";\n    else \n\t   cout << \"Not a strobogrammatic number\";\n}",
        "example": "[{\"input\": \"18081\", \"output\": \"Strobogrammatic number\"}, {\"input\": \"666\", \"output\": \"Not a strobogrammatic number\"}, {\"input\": \"4287\", \"output\": \"Not a strobogrammatic number\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1694,
        "problem_description": "给定一个长度为n的序列，在其中找出一个子序列，并且满足该序列中的数字单调上升，那么该子序列最长的长度是多少。",
        "function_declaration": "int longestIncreasingSubsequence(int n, vector<int>& nums)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> nums(n);\n    for(int i=0; i<n; i++){\n        cin>>nums[i];\n    }\n    // calling start\n    int result = longestIncreasingSubsequence(n, nums);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"5\\n1 4 3 2 5\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1656,
        "problem_description": "给定一个长度为n的非负整数序列，请计算序列的最大跨度值（最大跨度值 = 最大值减去最小值）。",
        "function_declaration": "int calculateRange(int n, int arr[])",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int n, x;\n    cin >> n;\n    int arr[n];\n    for(int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    // calling start\n    int result = calculateRange(n, arr);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n3 0 8 7 5 9\", \"output\": \"9\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2344,
        "problem_description": "给定两个字符串，求出第二个字符串在第一个串中出现了几次。",
        "function_declaration": "int countSubstrings(char* str, char* sub)",
        "code_context": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int N = 1024;\nchar str[N];\nchar sub[N];\n\n// function start\n\n// function end\n\nint main() {\n    cin >> str >> sub;\n    // calling start\n    int result = countSubstrings(str, sub);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"abababa\\naba\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1849,
        "problem_description": "铁达尼克号遇险了 它发出了求救信号。距离最近的哥伦比亚号收到了讯息。时间就是生命，必须尽快赶到那里通过侦测，哥伦比亚要获取了一张海洋图 这张海洋图上划分成了n*n (2 ≤ n ≤ 1000)个比较小的单位，用1表示陆地 用0表示海洋 船只能从一个格子移到相邻的4个格子里。 为了尽快赶到出事地点，哥伦比亚号最少要走多少距离。输入一个0，1矩阵，表示海洋地图。 输入4个小于n的整数 表示哥伦比亚号和铁达尼克号的坐标。",
        "function_declaration": "int minDistance(vector<vector<int>>& grid, int cx, int cy, int tx, int ty)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> grid(n, vector<int>(n));\n\n    // Input grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n        }\n    }\n\n    int cx, cy, tx, ty;\n    cin >> cx >> cy >> tx >> ty;\n\n    //calling start\n    int minDist = minDistance(grid, cx - 1, cy - 1, tx - 1, ty - 1);\n    //calling end\n\n    cout << minDist << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n001\\n101\\n100\\n1 1 3 3\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1986,
        "problem_description": "听说你已经学过了 C++ 的基本运算符了，J 国的著名教育家田所教授决定再出一道难题考察你。现在他给你三个数字，希望您判断其中较小的两个数的和是不是等于最大的那个数。保证所有输入的数字在 float 的范围内，绝对值不超过 1000 ，且小数点后最多有 3 位小数。如果等于，输出 YES，否则，输出NO",
        "function_declaration": "string checkSum(float a, float b, float c)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    float a, b, c;\n    cin>>a>>b>>c;\n    // calling start\n    string result = checkSum(a, b, c);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"3.001 1.09 2.000\", \"output\": \"NO\"}, {\"input\": \"0.10 0.30 0.2\", \"output\": \"YES\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2256,
        "problem_description": "Scarlet 最近学会了一个数组魔法，她会在 $n\\times n$ 二维数组上将一个奇数阶方阵按照顺时针或者逆时针旋转 $90^\\circ$。首先，Scarlet 会把 $1$ 到 $n^2$ 的正整数按照从左往右，从上至下的顺序填入初始的二维数组中，然后她会施放一些简易的魔法。Scarlet 既不会什么分块特技，也不会什么 Splay 套 Splay，她现在提供给你她的魔法执行顺序，想让你来告诉她魔法按次执行完毕后的二维数组。输入两个整数 $n,m$，表示方阵大小和魔法施放次数。matrix为初始的二维数组，operations包含了 $m$ 个操作，每个操作包含 $4$ 个整数 $x,y,r,z$，表示在这次魔法中，Scarlet 会把以第 $x$ 行第 $y$ 列为中心的 $2r+1$ 阶矩阵按照某种时针方向旋转，其中 $z=0$ 表示顺时针，$z=1$ 表示逆时针。输出 $n$ 行，每行 $n$ 个用空格隔开的数，表示最终所得的矩阵。",
        "function_declaration": "void applyMagicOperations(int n, int m, vector<vector<int>>& matrix, vector<vector<int>>& operations) ",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to apply magic operations on the matrix\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> matrix(n, vector<int>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            matrix[i][j] = i * n + j + 1;\n        }\n    }\n\n    vector<vector<int>> operations(m, vector<int>(4));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            cin >> operations[i][j];\n        }\n    }\n\n    //calling start\n    applyMagicOperations(n, m, matrix, operations);\n    //calling end\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << matrix[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"5 4\\n2 2 1 0\\n3 3 1 1\\n4 4 1 0\\n3 3 2 1\", \"output\": \"5 10 3 18 15\\n4 19 8 17 20\\n1 14 23 24 25\\n6 9 2 7 22\\n11 12 13 16 21\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2006,
        "problem_description": "如果你已经知道了一个测试点的输入输出，那么你就可以用一个简单的if语句使你的程序在这个特定的输入下给出正确的结果，从而得到分数。这种行为叫做打表。通常情况下，我们不希望你使用打表的方法来通过测试，因为即使你通过打表拿到了100分，也不能说明你的程序是正确的。一个正确的程序应当对于所有合法的输入都能输出正确的结果。如果你能使用打表写出真正正确的程序，那当然我们也支持。下面的问题你可以尝试通过打表解决。给定一个小于50的正整数 n，输出圆周率，保留 n 位小数。",
        "function_declaration": "void roundPi(char* s, int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    char s[60]=\"3.14159265358979323846264338327950288419716939937510\";\n    int n;\n    cin>>n;\n    // calling start\n    roundPi(s, n);\n    // calling end\n}",
        "example": "[{\"input\": \"4\", \"output\": \"3.1416\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1723,
        "problem_description": "对于一个字符串来说，定义一次循环移位操作为：将字符串的第一个字符移动到末尾形成新的字符串。给定两个字符串s1和s2，要求判定其中一个字符串是否是另一个字符串通过若干次循环移位后的新字符串的子串。",
        "function_declaration": "bool isSubString(char* s1, char* s2)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 61;\nchar s1[N], s2[N], x[N], t[N];\nint l1, l2;\n\n//function start\n\n//function end\n\nint main() {\n    scanf(\"%s%s\", s1, s2);\n\n    //calling start\n    bool result = isSubString(s1, s2);\n    //calling end\n\n    if (result) {\n        printf(\"true\\n\");\n    } else {\n        printf(\"false\\n\");\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"AABCD CDAAB\", \"output\": \"true\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2032,
        "problem_description": "小万同学正打算去商店买一些零食，带回来分给小橙同学。这种情况下小万同学一般都会买偶数份，最多有一个会买得不一样。小橙同学有些纠结要不要接受他的分享。最终她决定，如果小万同学的购物单上每种零食都是偶数个，就和他一起吃零食。小万同学的购物清单上共有 4 个商品，每个商品都有一个种类编号。小橙同学请你帮她判断一下是不是每种都是偶数个。",
        "function_declaration": "bool checkAccept(int a, int b, int c, int d)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a = 0, b = 0, c = 0, d = 0;\n    cin >> a >> b >> c >> d;\n    // calling start\n    bool result = checkAccept(a, b, c, d);\n    // calling end\n    if (result)\n        cout << \"accept\";\n    else\n        cout << \"deny\";\n    cout << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"1 1 1 1\\n\", \"output\": \"accept\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 302,
        "problem_description": "津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。每组输入数据包括七行，分别表示周一到周日的日程安排。每行包括两个小于10的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。每组输出包括一行，这一行只包含一个数字。如果不会不高兴则输出0，如果会则输出最不高兴的是周几（用1, 2, 3, 4, 5, 6, 7分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。",
        "function_declaration": "int unhappiness(int schedule[7][2])",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int schedule[7][2];\n    for(int i=0; i<7; i++){\n        cin>>schedule[i][0]>>schedule[i][1];\n    }\n    // calling start\n    int result = unhappiness(schedule);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"5 3\\n6 2\\n7 2\\n5 3\\n5 4\\n0 4\\n0 6\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 125
    },
    {
        "id": 2157,
        "problem_description": "许多比赛在计算选手得分平均数的时候，都会先去掉一个最高得分，再去掉一个最低得分，这样可以避免极大值与极小值对平均值的影响。给定$n$个数字$a_1,a_2,...,a_n$，表示一个选手获得的分数，请根据上述流程计算并返回选手的最终得分并四舍五入保留两位小数。注意如果有多个分数并列第一，则只会去掉一个最高分，去掉最低分的情况同理。",
        "function_declaration": "double calculateAverage(int n, double* arr)",
        "code_context": "#include<iostream>\n#include<iomanip>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int n;\n  cin >> n;\n  double* arr = new double[n];\n  for (int i = 0; i < n; ++i) {\n  \tcin >> arr[i];\n  }\n  \n  // calling start\n  double avg = calculateAverage(n, arr);\n  // calling end\n  \n  cout << fixed << setprecision(2) << avg; \n  delete[] arr;\n}",
        "example": "[{\"input\": \"5\\n100 1 20 30 40 \", \"output\": \"30.00\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2316,
        "problem_description": "给定 $n$ 个整数 $a_1,a_2,...,a_n$ 构成一个序列，请为这个序列寻找一个子串，使数字之和达到最大，返回子串的最大和。子串是原序列中连续且保持顺序的一段数字，空串或序列全体都算原序列的子串。",
        "function_declaration": "int calculateMaxSuffixSum(int n, int arr[])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n    // calling start\n    int result = calculateMaxSuffixSum(n, arr);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"5\\n1 2 -10 2 3\", \"output\": \"5\"}, {\"input\": \"3\\n-1 -2 -3\", \"output\": \"0\"}, {\"input\": \"3\\n3 -2 3\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1862,
        "problem_description": "老师正在开发一个自动计数器，输入班级5个同学的语文成绩。计算出合格（60分及以上）的人数一共有几位。",
        "function_declaration": "int countPassScore(int scores[], int size)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int scores[5];\n    for (int i = 0; i < 5; i++) {\n        cin >> scores[i];\n    }\n    // calling start\n    int cnt = countPassScore(scores, 5);\n    // calling end\n    cout << cnt << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"78 93 42 51 60\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1970,
        "problem_description": "小朋友们，在学习了简单的运算符之后，相信你们已经可以学会了用计算机来做许多有用的数学运算。这次你需要判断三根给定长度的木棍能否拼成一个三角形。输入a, b, c三个整数，代表三根木棍的长度，如果能拼成三角形，请输出 \"yes\"（不含引号），否则输出 \"no\" （不含引号）。",
        "function_declaration": "bool isTriangle(int a, int b, int c)",
        "code_context": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    //calling start\n    bool result = isTriangle(a, b, c);\n    //calling end\n    if (result) puts(\"yes\");\n    else puts(\"no\");\n}",
        "example": "[{\"input\": \"1 2 3\", \"output\": \"no\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2310,
        "problem_description": "给定 $n$ 个整数 $a_1,a_2,…,a_n$，每个数字都是 0,1,2 中的一个，请将其中的一部分数字两两交换，使得结果是升序的，请问最少需要几次交换？",
        "function_declaration": "int calculateCost(int n, int a[])",
        "code_context": "#include<iostream>\nusing namespace std;\nconst int maxn = 1000000;\nint a[maxn];\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t// calling start\n\tint cost = calculateCost(n, a);\n\t// calling end\n\tcout << cost;\n}",
        "example": "[{\"input\": \"5\\n2 0 1 2 0\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1828,
        "problem_description": "阿晓制作了一个机器人迪拉.这台机器人对数字的理解和普通人不同，他读数字是反向读取的。例如，他看到1234时，会理解成4321；看到1020时，会理解成201。所以，当他比较两个数字的大小时，和普通人的结果也不同，比如当他比较13 21时，他会认为他在比较31 12，即为前者更大，在普通人眼里，他的比较结果就是13 > 21。现在给迪拉两个自然数n m (n < m ≤ n + 10^5)，让它将[n，m]区间中的数字由小到大排序，请输出他的排序结果。",
        "function_declaration": "void sortArray(int st, int ed, int* a)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int st, ed, n, a[100010];\n    cin >> st >> ed;\n    // calling start\n    sortArray(st, ed, a);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"9 15\", \"output\": \"10 9 11 12 13 14 15\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1448,
        "problem_description": "给定n四位数，求出其中满足以下条件的数的个数： 个位数上的数字减去千位数上的数字，再减去百位数上的数字， 再减去十位数上的数字的结果大于零。",
        "function_declaration": "int calculate_ans(int n)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    // calling start\n    int result = calculate_ans(n);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1234 1349 6119 2123 5017\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2228,
        "problem_description": "输出hello world。",
        "function_declaration": "void printHelloWorld()",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    // calling start\n    printHelloWorld();\n    // calling end\n}",
        "example": "[{\"input\": \"（没有输入）\", \"output\": \"hello world\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1497,
        "problem_description": "求两数的积。说明/提示：第1个数字不超过 10^2000 ，需用高精。第2个数字不超过10^8。",
        "function_declaration": "string multiplyStrings(string num1, int num2)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    string num1;\n    int num2;\n    cin >> num1 >> num2;\n    // calling start\n    string result = multiplyStrings(num1, num2);\n    // calling end\n    cout << result;\n}\n",
        "example": "[{\"input\": \"2368 32\", \"output\": \"75776\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2128,
        "problem_description": "由于经常给小橙同学买零食，某一天小万突然发现他花了好多好多钱！他想从账单中寻找一些规律，但是他面对着很多很多天的账单手足无措。你能不能帮小万同学统计一下周几的平均花销最高？输入两个正整数 $n$ 和 $k$ 表示账单的总天数和第一天是星期几。$7\\le n\\le 10^6$，$1\\le k\\le 7$。（周日认为是第7天），输入 $n$ 个正整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 天的花销，输出个整数表示星期几的平均花销最高，相同的平均花销输出编号较小的。",
        "function_declaration": "int findMaxAverageDay(int n, int k, vector<int>& expenses)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    vector<int> expenses(n);\n    for (int i = 0; i < n; i++) {\n        cin >> expenses[i];\n    }\n\n    // calling start\n    int result = findMaxAverageDay(n, k, expenses);\n    // calling end\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"7 1\\n1 1 1 2 1 1 1\\n\", \"output\": \"4\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1864,
        "problem_description": "输入一个四位的整数（1000～9999），返回它的个位、十位、百位、千位。",
        "function_declaration": "vector<int> calculateDigits(int n)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    // calling start\n    vector<int> result = calculateDigits(n);\n    // calling end\n    cout << result[0] << \" \" << result[1] << \" \" << result[2] << \" \" << result[3];\n    return 0;\n}",
        "example": "[{\"input\": \"1234\", \"output\": \"4 3 2 1\"}, {\"input\": \"4762\", \"output\": \"2 6 7 4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2178,
        "problem_description": "在同学的推荐下，小万同学接触到了“开心消消乐”这款发布于2014年的小型休闲游戏。我们对此做一点简化，只观察一步的情况。现在有一个方块构成的矩形，每个方块上有一个小动物。当三个相同的动物在同一条水平或竖直的直线上且相邻时，他们就可以被消去。玩家可以让相邻的两个动物临时交换，如果临时交换后满足了交换条件，就可以被消去，否则这两个动物就会换回来。同时，为了简化，我们先只考虑AABA型换成AAAB型的情况。现在给出了初始情况，请你帮小万想想，他第一步有多少种操作方式可以触发“消去”？（注：由于小万会先考虑连续二个，再去找第三个，所以他会认为AABABB是两种操作方式）保证初始局面不存在可以直接消去的动物。",
        "function_declaration": "int calculate_ans(int n, int m, int a[maxn][maxn])",
        "code_context": "#include <iostream>\nusing namespace std;\nint const maxn = 503;\n\nint n = 0, m = 0;\nint a[maxn][maxn];\n\n// function start\n\n// function end\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tcin >> a[i][j];\n\t// calling start\n\tint ans = calculate_ans(n, m, a);\n\t// calling end\n\tcout << ans << endl;\n\treturn 0;\n}",
        "example": "[{\"input\": \"3 6\\n1 1 2 2 1 1 \\n1 1 2 1 2 2\\n2 2 1 1 2 2\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1749,
        "problem_description": "给定一个n*n的矩阵，选出n个位置，使得这n个位置的和最小，并且满足每一行有且仅有一个选中的点，每一列有且仅有一个选中的点。返回一个整数，表示最小的和。",
        "function_declaration": "int calculateMinSum(vector<vector<int>>& matrix)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    \n    vector<vector<int>> matrix(n, vector<int>(n));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            cin>>matrix[i][j];\n        }\n    }\n    \n    // calling start\n    int result = calculateMinSum(matrix);\n    // calling end\n    \n    cout<<result;\n}",
        "example": "[{\"input\": \"3\\n4 2 5\\n2 3 6\\n3 4 5\", \"output\": \"9\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1976,
        "problem_description": "中国剩余定理是一个非常好玩的数论定理，在《孙子算经》中第一次提到：```今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？答曰：‘二十三’。```翻译一下：```一个整数除以3余2、除以5余3、除以7余2，求这个整数。答案是：23```为了简化问题，我们只考虑模2和模5。在模2和模5的余数确定时，请你告诉我原来的数是多少？给定两个整数a,b其中a为x模2的余数，b为x模5的余数。",
        "function_declaration": "int calculateResult(int a, int b)",
        "code_context": "#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+1;\nconst int INF=1e9+7;\n#define test(x) cout<<(x)<<endl;\n\n// function start\n\n// function end\n\nint main()\n{\n    int a,b;\n    cin>>a>>b;\n    // calling start\n    int result = calculateResult(a, b);\n    // calling end\n    cout<<result;\n    return 0;\n}",
        "example": "[{\"input\": \"0 0\", \"output\": \"0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1495,
        "problem_description": "高精度加法，相当于a+b problem，不用考虑负数，a, b ≤ 10^10000，输出a+b的值。",
        "function_declaration": "string add(string a, string b)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    string a, b;\n    cin>>a>>b;\n    // calling start\n    string result = add(a, b);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"1001 9099\", \"output\": \"10100\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2200,
        "problem_description": "给定一个正整数 n，输出 n 的阶乘（即$1 \\times 2 \\times \\dots \\times n$）对 1000003 取模的值。",
        "function_declaration": "long long factorialModulo(long long n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    long long n;\n    cin>>n;\n    // calling start\n    long long result = factorialModulo(n);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"10\", \"output\": \"628791\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2216,
        "problem_description": "三倍游戏是一种单人游戏。玩家会得到 $n$ 个整数 $a_1,a_2,…,a_n$。玩家从这些整数中挑出两个数字相加，如果它们的和是 $3$ 的倍数，则可以将这两个整数消除，如此反复，直到不能再消除数字为止。请问玩家最多能消除多少对数字？",
        "function_declaration": "int calculate(int n, int arr[])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int n;\n  cin >> n;  \n  int arr[n];\n  for (int i = 0; i < n; ++i) {\n  \tcin >> arr[i];\n  }\n  // calling start\n  int result = calculate(n, arr);\n  // calling end\n  cout << result;\n}",
        "example": "[{\"input\": \"4\\n1 3 3 2\", \"output\": \"2\"}, {\"input\": \"6\\n1 2 3 4 5 6\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2295,
        "problem_description": "⊕ 代表异或（xor）运算，运算规则为：当只有一位比特参与运算时，$0⊕0=0$，$0⊕1=1$，$1⊕0=1$，$1⊕1=0$（相同为0，相异为1）；当有多位比特参与运算时，对每位比特分别取异或运算，如 $0101⊕1011=1110$；给定一个正整数 $n$，求 $0$ 到 $2^{n-1}$ 中有多少个数 $x$ 满足以下方程：$$x⊕2x⊕3x=0$$，由于满足条件的 $x$ 可能很多，请将方案数对 $10^9+9$ 取模。",
        "function_declaration": "int calculate(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\nint solve[1000001];\n\n// function start\n\n// function end\n\nint main() {\n  int n;\n  cin >> n;\n  // calling start\n  int result = calculate(n);\n  // calling end\n  cout << result;                          \n}",
        "example": "[{\"input\": \"3\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2030,
        "problem_description": "“是故意的还是不小心的？”“是故意的”故意与不小心总是散落在生活的角角落落。的确，我们经常会在意一件事情是有意为之还是无意为之。然而，不管是故意的还是不小心的，总之这件事情已经发生了，所以刨根问底地只要做事的意图有时并没有必要，更重要的是发现内在的道理。在这里，一个数被作为故意数，当且仅当它的位数是奇数且每一位上的数都是奇数。现在请你判断一个数是否为故意数。是故意数返回1，不是故意数返回0。",
        "function_declaration": "int checkNumber(int n)",
        "code_context": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n = 0;\n    cin >> n;\n    //calling start\n    int result = checkNumber(n);\n    //calling end\n    cout << (result? \"Yes\":\"No\") << '\\n';\n    return 0;\n}",
        "example": "[{\"input\": \"1\", \"output\": \"Yes\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1932,
        "problem_description": "小爱正在参加一个闯关游戏。游戏的关卡分为两类，一类为文艺，一类为体育。每类游戏都有n关，且必须按照顺序通关，即必须先通过某类游戏的的前一关，才能挑战该类游戏的下一关。 小爱的挑战时间有限，记为t，每关的通关时间不同，n个整数$a_1, a_2,...,a_n$，表示文艺类关卡的通关时间，n个整数$b_1, b_2,...,b_n$，表示体育类关卡的通关时间。她能自由地切换挑战关卡的类型，请问她最多可以通过多少关呢？返回在时限内能够完成挑战的最大关数。对于30%的数据，1 ≤ n ≤ 20 ，对于60%的数据， 1 ≤ n ≤ 1000； 对于100%的数据，1 ≤ n ≤ 100000，1 ≤ t ≤ 1,000,000,000，1 ≤ $ a_i $, $ b_i $≤ 10000。",
        "function_declaration": "int calculateMax(int n, int t, int a[], int b[])",
        "code_context": "#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n, t, a[100010], b[100010], ans;\n\n// function start\n\n// function end\n\nint main()\n{\n    cin >> n >> t;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n        if (i > 0) a[i] += a[i - 1];\n    }\n    for (int i = 0; i < n; i++) {\n        cin >> b[i];\n        if (i > 0) b[i] += b[i - 1];\n    }\n\n    // calling start\n    ans = calculateMax(n, t, a, b);\n    // calling end\n\n    cout << ans;\n\n    return 0;\n}",
        "example": "[{\"input\": \"4 22\\n6 8 10 7\\n7 11 9 9\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1606,
        "problem_description": "请用while语法实现：输入一个小于10000的整数，判断其是否为质数。",
        "function_declaration": "bool isPrime(int n)",
        "code_context": "#include <iostream>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    // calling start\n    bool result = isPrime(n);\n    // calling end\n    if (result) {\n        cout << \"yes\" << endl;\n    } else {\n        cout << \"no\" << endl;\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"5\", \"output\": \"yes\"}, {\"input\": \"10\", \"output\": \"no\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2292,
        "problem_description": "在平面直角坐标系上有 $n$ 座像山峰一样的图案。每座山峰是一个直角等腰三角形，它们的底边都是坐标系的X轴，第 $i$ 座山峰的峰顶坐标为 $(x_i,y_i)$。如果一座山峰的峰顶在另一座山峰的内部，或者恰好在山峰的边界上，那么这座山峰就被遮蔽了。给定每个山峰的峰顶坐标，请统计有多少山峰是能被看见的。",
        "function_declaration": "int countVisiblePeaks(vector<pair<int, int>>& peaks) ",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\n// Function to count the number of visible peaks\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> peaks(n);\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        peaks[i] = make_pair(x, y);\n    }\n\n    // Sort the peaks by their x-coordinate in ascending order\n    sort(peaks.begin(), peaks.end());\n    //calling start\n    int visiblePeaks = countVisiblePeaks(peaks);\n    //calling end\n    cout << visiblePeaks << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"4\\n1 1\\n2 2\\n4 1\\n4 2\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1773,
        "problem_description": "现有一个无序的数列，请你找出其中最小的十个数，并且按照从小到大的顺序输出这10个数。",
        "function_declaration": "void findMinAndPrint(int n, int a[])",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[1010];\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    // calling start\n    findMinAndPrint(n, a);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"11\\n1 2 3 4 5 6 7 8 9 10 11\", \"output\": \"1 2 3 4 5 6 7 8 9 10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2130,
        "problem_description": "请你在一组数据中找出出现次数最多的数字吧！若出现次数最多的数字有多个，返回其中第一个出现的数字。",
        "function_declaration": "int findMostFrequentNumber(vector<int>& nums)",
        "code_context": "#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    // calling start\n    int result = findMostFrequentNumber(nums);\n    cout << result << endl; // calling end\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"7\\n1\\n1\\n2\\n2\\n2\\n3\\n3\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1910,
        "problem_description": "请用递归实现：输出1～10每个数字，数字之间用空格隔开。",
        "function_declaration": "void printN(int N)",
        "code_context": "#include <iostream> \nusing namespace std;\n\n// function start\n\n// function end\nint main(){     \n    printN(10); \n}               ",
        "example": "[{\"input\": \" \", \"output\": \"1 2 3 4 5 6 7 8 9 10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1941,
        "problem_description": "读入一个字符，一个整数，一个单精度浮点数，一个双精度浮点数，然后按顺序输出它们，并且要求在他们之间用一个空格分隔。输出浮点数时保留6位小数。",
        "function_declaration": "void printValues(char a, int b, float c, double d)",
        "code_context": "#include <iostream> \nusing namespace std;\n\n//function start\n\n//function end\n\nint main(){\n    char a;\n    int b;\n    float c;\n    double d;\n\n    cin >> a >> b >> c >> d;\n    //calling start\n    printValues(a, b, c, d);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"a\\n12\\n2.3\\n3.2\", \"output\": \"a 12 2.300000 3.200000\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2018,
        "problem_description": "chayso 现在给你一个整数t，她希望知道这个数的三进制表示中数字 0 , 1 , 2 分别出现了多少次，出现的次数用a,b,c表示，你能帮助她吗。",
        "function_declaration": "void countNumbers(unsigned long long t, int& a, int& b, int& c)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    int a = 0,b = 0,c = 0;\n    unsigned long long t;\n    cin >> t;\n    // calling start\n    countNumbers(t, a, b, c);\n    // calling end\n    cout << a << ' ' << b << ' ' << c;\n    return 0;\n}",
        "example": "[{\"input\": \"10\", \"output\": \"1 2 0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2150,
        "problem_description": "在植树节，小爱种了$a$棵树、小艾种了$b$棵树， 小哀种了$c$棵树。老师准备帮助学生补种一些树，使得三人的植树数量相等。请问老师最少应该种多少树，才能使三人的种树数量保持一致？",
        "function_declaration": "int calculateMaxDifference(int a, int b, int c)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n   int a, b, c;\n   cin >> a >> b >> c;\n   \n   // calling start\n   int result = calculateMaxDifference(a, b, c);\n   // calling end\n   \n   cout << result;\n}",
        "example": "[{\"input\": \"2 1 3\", \"output\": \"3\"}, {\"input\": \"4 4 2\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1725,
        "problem_description": "输入1行句子（不多于200个单词，每个单词长度不超过100），只包含字母、空格。单词由至少一个连续的字母构成，空格是单词间的间隔，两个单词中间只有一个空格。试输出第1个最长的单词和第1个最短单词。",
        "function_declaration": "pair<string, string> findMinMaxWord(string s)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main()\n{\n    string s;\n    getline(cin, s);\n    //calling start\n    pair<string, string> result = findMinMaxWord(s);\n    //calling end\n    cout << result.first << endl;\n    cout << result.second << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"I am studying Programming language C in Peking University\", \"output\": \"Programming\\nI\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2312,
        "problem_description": "扔 $n$ 次硬币的结果可以用一串 $0/1$ 序列来表示。给定 $n$，请统计有多少种扔硬币的结果中不含三个连续的 $0$ 且不含三个连续的 $1$。当 $n$ 较大的时候，答案可能很大，所以输出答案模 1,000,000,007 的余数即可。",
        "function_declaration": "long long calculate(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\nlong long HH[1000001];\nlong long HT[1000001];\nlong long TH[1000001];\nlong long TT[1000001];\nconst int mod = 1000000007;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\t// calling start\n\tlong long result = calculate(n);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2075,
        "problem_description": "听说你学会了数组，Dark 教授决定考察你最基本的运用。现在 Dark 教授给你一串数字，她希望你逆序输出这些数字。例如，她给你 1 2 3 4 6 5 这六个数字，你需要输出 5 6 4 3 2 1。输入一个整数 n ，表示数字的个数，a包含了n个整数，要求输出的 n 个整数，中间用一个空格隔开。",
        "function_declaration": "void printReverse(int n, int a[])",
        "code_context": "#include <iostream>\nusing namespace std;\nconst int N = 10000;\nint a[N];\n\n// function start\n\n// function end\n\nsigned main() {\n    int n;\n    cin >> n;\n    for(int i = 0 ; i < n ; ++i) cin >> a[i];\n    // calling start\n    printReverse(n, a);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"7\\n0 1 8 9 1 9 1\", \"output\": \"1 9 1 9 8 1 0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1718,
        "problem_description": "开灯问题，有n盏灯，编号为1~n。第一个人把所有灯都打开，第二个人按下所有编号为2的倍数的开关（这些灯将被关掉），第三个人按下所有编号为3的倍数的开关（其中关掉的灯将被打开，开着的灯将被关闭），以此类推。一共有k个人，问最后有哪些灯开着？输入n和k,输出开着的灯的编号。(k<=n<=1000)，几个整数用空格隔开，表示开着的灯的编号。",
        "function_declaration": "void processArray(int n, int k, bool a[])",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool a[1010];\n\n// function start\n\n// function end\n\nint main ( ) {\n    memset(a, true, sizeof(a));\n    int n, k;\n    cin >> n >> k;\n    // calling start\n    processArray(n, k, a);\n    // calling end\n    return 0; \n}",
        "example": "[{\"input\": \"7 3\", \"output\": \"1 5 6 7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2291,
        "problem_description": "小爱在参加一个跑步比赛，比赛路线分为$n$段，其中第$i$段的分数为$a_i$?。在每段路上，小爱可以选择跑步、突击或慢走，每种方式得分不同，具体规则如下：如果在一段路上选择跑步，可以得$a_i$?分；如果在一段路上选择突击，分数会加倍，变成$2a_i$?分，但下一段路就只能慢走了；如果在一段路慢走，得分为$0$。小爱在每段路上应该如何选择，才能使得分之和最大呢？输出最大分数。",
        "function_declaration": "int calculateMax(int n, int* arr)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint* arr = new int[n];\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> arr[i];\n\t}\n\t// calling start\n\tint result = calculateMax(n, arr);\n\t// calling end\n\tcout << result;\n\tdelete[] arr;\n}",
        "example": "[{\"input\": \"4\\n1 2 3 4\", \"output\": \"14\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1636,
        "problem_description": "给出两个序列 pushed 和 poped 两个序列，其取值从 1 到n (1 ≤ n ≤ 10^5)。已知入栈序列是1 2 3 ... n，如果出栈序列有可能是 poped，则输出Yes，否则输出No。输入一个整数n表示序列长度；n个整数表示出栈序列，如可能，则输出Yes；反之，则输出No。",
        "function_declaration": "string checkPopedSequence(int n, vector<int>& poped)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int q;\n    cin>>q;\n    while(q--){\n        int n;\n        cin>>n;\n        vector<int> poped(n);\n        for(int i=0; i<n; i++){\n            cin>>poped[i];\n        }\n        // calling start\n        string result = checkPopedSequence(n, poped);\n        // calling end\n        cout<<result<<endl;\n    }\n}",
        "example": "[{\"input\": \"2\\n5\\n5 4 3 2 1\\n4\\n2 4 1 3\", \"output\": \"Yes\\nNo\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2129,
        "problem_description": "Hastin 和 DarkSharpless 的决斗还在继续，他们并不满足于通过一场石头剪刀布就决出胜负。因此，他们进行了 n 场石头剪刀布对决，获胜更多的那位将赢得最终的胜利。请你判断谁是最后的赢家吧！N对数字，分别代表 Hastin 和 DarkSharpless 所出的招式，其中：-0代表石头-1代表剪刀-2代表布，且规则就是传统的石头剪刀布规则，即石头赢剪刀，剪刀赢布，布赢石头。输出最后的胜者的名字，如果二人胜利场数相同，输出 \"draw\" （不含引号）。",
        "function_declaration": "string findWinner(vector<int>& hastin_moves, vector<int>& darksharpless_moves)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> hastin_moves(n);\n    vector<int> darksharpless_moves(n);\n\n    for (int i = 0; i < n; i++) {\n        cin >> hastin_moves[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n        cin >> darksharpless_moves[i];\n    }\n\n    // calling start\n    string winner = findWinner(hastin_moves, darksharpless_moves);\n     // calling end\n    cout << winner << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n1 0\\n0 2\\n2 1\", \"output\": \"DarkSharpless\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2327,
        "problem_description": "有 n 个滑梯，编号从1到n，其中有一个是“碰都不能碰的滑梯”。坐在一个滑梯上可能会滑到另一个滑梯。如果坐在一个滑梯上可能会滑到“碰都不能碰的滑梯”，那么这个滑梯也是不能碰的滑梯。现在你需要判断一共有多少个不能碰的滑梯。输入包含两个正整数 n,x，分别表示滑梯个数和“碰都不能碰的滑梯”的编号，包含 n 个1到n之间的整数，第 k 个数表示坐 k 号滑梯会滑到的下一个滑梯的编号。特别的，如果第 k 个数等于 k，表示坐 k 号滑梯不会滑到另一个滑梯。输出一个数，表示不能碰的滑梯的个数。",
        "function_declaration": "int countUntouchableSlides(int n, int x, vector<int>& nextSlide)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\n// Function to calculate the number of untouchable slides\n//function start\n\n//function end\n\nint main() {\n    // Input the number of slides and the untouchable slide number\n    int n, x;\n    cin >> n >> x;\n\n    // Input the next slide for each slide\n    vector<int> nextSlide(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nextSlide[i];\n    }\n\n    // Calling the function to count the untouchable slides\n    //calling start\n    int untouchableSlides = countUntouchableSlides(n, x, nextSlide);\n    //calling end\n\n    // Output the result\n    cout << untouchableSlides << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"8 4\\n2 1 4 6 5 3 5 7\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1818,
        "problem_description": "给定一个数列，它是由从小到大一共n个整数构成的；给定一个数x，将数列中所有 >=x 的数都舍弃掉，那么该数列还剩下多少个数？",
        "function_declaration": "int findLowerBound(int a[], int n, int x)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[100010];\n\n// function start\n\n// function end\n\nint main() {\n    int n, x;\n    cin >> n >> x;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    // calling start\n    int result = findLowerBound(a, n, x);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"10 7\\n1 2 2 2 3 5 7 7 10 20\", \"output\": \"6\"}, {\"input\": \"10 2\\n1 2 2 2 3 5 7 7 10 20\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2005,
        "problem_description": "小A和小B各有两张牌，小A的牌记为 a1,a2，小B的牌记为 b1,b2，按下面的规则比较，谁的牌更大？用 1,2,...,10,11,12,13 分别表示纸牌中的 A,2,...,10,J,Q,K 。牌从大到小排序是 A,K,Q,J,10,...,3,2。一对（两张相同的牌）比两张不同的牌更大，例如样例中小B的牌 22 比小A的牌 AK 大。两张不同的牌比大小，先比较双方较大的那张牌，若一样大再比较另一张牌，仍然一样则平局。",
        "function_declaration": "int calculateScore(int a1, int a2, int b1, int b2)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n\tint a1,a2,b1,b2,a,b;\n\tcin>>a1>>a2>>b1>>b2;\n\t// calling start\n\tint result = calculateScore(a1, a2, b1, b2);\n\t// calling end\n\tif(result == -1) cout<<\"B\";\n\tif(result == 1) cout<<\"A\";\n\tif(result == 0) cout<<\"Draw\";\n}",
        "example": "[{\"input\": \"1 13\\n2 2\", \"output\": \"B\"}, {\"input\": \"4 6\\n6 4\", \"output\": \"Draw\"}, {\"input\": \"1 12\\n1 10\", \"output\": \"A\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1637,
        "problem_description": "假设一个表达式有英文字母（小写）、运算符+ — * /和左右小（圆）括号构成，以@作为表达式的结束符。请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，则返回0；否则返回其他。表达式长度小于255，左圆括号少于20个。",
        "function_declaration": "int checkParentheses(char* s)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nchar s[1010];\n\n// function start\n\n// function end\n\nint main() {\n    scanf(\"%s\", s);\n    // calling start\n    int result = checkParentheses(s);\n    // calling end\n    if (result == 0)\n        printf(\"YES\");\n    else\n        printf(\"NO\");\n    return 0; \n}",
        "example": "[{\"input\": \"2*(x+y)/(1-x)@\", \"output\": \"YES\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2031,
        "problem_description": "小万同学有一只可爱的小狗。小万同学会给他一些骨头，然后给出L或者R作为指示。狗狗很聪明，小万希望当他给出L时，狗狗向右边跑；给出R时，狗狗向左跑。今天小狗狗已经陪小万同学玩了很久，它会用行动表示如果不能给它比昨天更多的骨头（不包含相等），它就不继续玩了，呆在原地。输入依次为 昨天小万给的骨头数量(int)，今天给的骨头数量（int），小万的指示（char）。保证骨头数量在int范围内，指示只会是L或R中的一个字符，输出一行字符串。如果狗狗不做任何事则输出nothing，向左跑则输出left，向右跑则输出right。",
        "function_declaration": "string mainLogic(int a, int b, char c)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a = 0, b = 0;\n    char c = 0;\n    cin >> a >> b >> c;\n    \n    // calling start\n    string result = mainLogic(a, b, c);\n    // calling end\n    \n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"1 0 L\", \"output\": \"nothing\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2141,
        "problem_description": "小爱正在建设一座方舱医院，医院位于一个长方形的场地内，该场地的长为 $a$，宽为$b$。场地里要安置尽量多的病床。每张病床需要占据长度为$c×c$的正方形区域，且正方形的边与场地的边界平行。请问最多可以放置多少张病床？",
        "function_declaration": "int calculate(int a, int b, int c)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n  int a, b, c;\n  cin >> a >> b >> c;\n  \n  // calling start\n  int result = calculate(a, b, c);\n  // calling end\n  \n  cout << result;\n}",
        "example": "[{\"input\": \"7 5\\n2\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1582,
        "problem_description": "2001年1月1日至2100年12月31日期间的时间称为21世纪。输入一个年份，输出21世纪开始截止到该年份以来的所有闰年年份。输入一个整数，表示21世纪中的某个年份。逐行输出满足条件的所有闰年年份，即每个年份占一行。输入的年份若不属于21世纪则输出\"Invalid year!\"。若不存在任何闰年，则输出“None”。",
        "function_declaration": "void printLeapYears(int year)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int year;\n    cin>>year;\n    // calling start\n    printLeapYears(year);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"2005\", \"output\": \"2004\"}, {\"input\": \"2000\", \"output\": \"Invalid year!\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2101,
        "problem_description": "小万同学很喜欢数字8，因为他了解到 8 横过来看是无穷的意思。小橙同学便问道，“小万，你当真认识8么？”小万看着小橙，显出不屑置辩的神气。小橙便接着说道，“你知道1到100中一共有几个8吗？”小万立刻显出颓唐不安模样，脸上笼上了一层灰色，嘴里说些话；这回可是全是8,18,28...之类，一些不懂了。在这时候，众人也都哄笑起来：教室内外充满了快活的空气。请你快来帮小万同学解围吧！他一定会好好感谢你的。白话文版题意：给定一个范围 $1,2,3,...,n$，求这之中一共出现了多少次数字8。（比如18,81是一次，88是两次）",
        "function_declaration": "int countEights(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n = 0;\n\tcin >> n;\n\t// calling start\n\tint result = countEights(n);\n\t// calling end\n\tcout << result << endl;\n\treturn 0;\n}",
        "example": "[{\"input\": \"88\\n\", \"output\": \"18\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2071,
        "problem_description": "小橙同学请小万同学帮忙买零食。小橙同学今天只想吃一种零食，所以她知道小万同学最多只会买两种零食（另一种是小万自己想吃的）。除非小万同时也帮别人买零食。快来帮小橙同学看一看是不是只有最多两种零食吧！输入一个整数 $n$，表示小万同学买的零食的个数，输入$n$ 个整数，表示每个零食的种类。",
        "function_declaration": "bool checkNumbers(int n, int numbers[])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n = 0;\n\tcin >> n;\n\tint numbers[n];\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> numbers[i];\n\t}\n\t// calling start\n\tbool result = checkNumbers(n, numbers);\n\t// calling end\n\tif (result) cout << \"yes\" << endl;\n\telse cout << \"no\" << endl;\n\treturn 0;\n}",
        "example": "[{\"input\": \"4\\n1 1 2 2\\n\", \"output\": \"yes\\n\"}, {\"input\": \"3\\n1 2 3\\n\", \"output\": \"no\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2113,
        "problem_description": "因数是指正整数 a 除以正整数 b 的商正好是整数而没有余数，我们就说 b 是 a 的因数。假如 a*b=c（a、b、c都是正整数)，那么 a 和 b 就是 c 的因数。给定一个正整数，输出这个数的因数有多少个。输入一个正整数 a。对于 40% 的数据，$a \\le 10000$；对于 100% 的数据，$a \\le 10^{12}$。",
        "function_declaration": "long long calculateDivisors(long long a)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n\tlong long a;\n\tcin>>a;\n\t// calling start\n\tlong long result = calculateDivisors(a);\n\t// calling end\n\tcout<<result;\n}",
        "example": "[{\"input\": \"17\", \"output\": \"2\"}, {\"input\": \"63\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2341,
        "problem_description": "小爱正在参加一个闯关游戏。游戏的关卡分为两类，一类为文艺，一类为体育。每类游戏都有 n 关，且必须按照顺序通关，即必须先通过某类游戏的的前一关，才能挑战该类游戏的下一关。小爱的挑战时间有限，记为 t，每关的通关时间不同，n 个整数 a1, a2, . . . , an，表示文艺类关卡的通关时间，n 个整数 b1, b2, . . . , bn，表示体育类关卡的通关时间，她能自由地切换挑战关卡的类型，请问她最多可以通过多少关呢？",
        "function_declaration": "int calculateMax(int n, int tim, int a[], int b[])",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[100010], b[100010];\n\n// function start\n\n// function end\n\nint main() {\n    int n, t, tim;\n    cin >> n >> tim;\n    for (int i = 1; i <= n; i++) {\n        cin >> t;\n        a[i] = a[i - 1] + t;\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> t;\n        b[i] = b[i - 1] + t;\n    }\n\n    // calling start\n    int result = calculateMax(n, tim, a, b);\n    // calling end\n\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"4 22\\n6 8 10 7\\n7 11 9 9\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2319,
        "problem_description": "电视里将要播放 $n$ 个节目，第 $i$ 个节目从时刻 $s_i$ 开始，到 $t_i$ 结束，没有回放。小爱有两台录像机，每台录像机在工作的时候只能录一个节目，小爱最多可以录下多少完整的节目呢？如果某节目的结束时间等于另一个节目的开始时间，那么这两个节目是可以用一台录像机的。",
        "function_declaration": "int maxCompletePrograms(int n, vector<pair<int, int>>& programs)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to find the maximum number of complete programs that can be recorded\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> programs(n);\n    for (int i = 0; i < n; i++) {\n        cin >> programs[i].first >> programs[i].second;\n    }\n\n    // Calling the function to find the maximum number of complete programs that can be recorded\n    //calling start\n    int result = maxCompletePrograms(n, programs);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 5\\n2 6\\n8 10\\n3 9\\n5 10\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1632,
        "problem_description": "现有若干个空的整数序列，需要你对其进行如下操作：若命令为1 x y，表示需要在第x个序列末尾新插入整数y。若命令为2 x，表示需要在第x个序列末尾删除一个数字，删除前保证该序列不为空。若命令为3，表示需要查询当前所有序列中的所包含的元素，每个序列单独一行，对于每个序列按照输入的顺序输出。数据保证命令3总数不超过2条。输入两个整数n m，表示序列的的数量和操作的次数。数据保证n ≤ 10^5  m ≤ 5 * 10^5。输入m个命令，具体如题目所表述。返回执行m个命令后的各个序列。",
        "function_declaration": "vector<vector<int>> operateSequences(int n, int m, vector<vector<int>>& commands)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n, m;\n    cin>>n>>m;\n    vector<vector<int>> commands(m, vector<int>(3));\n    for(int i=0; i<m; i++){\n        for(int j=0; j<3; j++){\n            cin>>commands[i][j];\n        }\n    }\n    // calling start\n    vector<vector<int>> result = operateSequences(n, m, commands);\n    // calling end\n    for(int i=0; i<n; i++){\n        if(result[i].empty()){\n            cout<<\"none\"<<endl;\n        }\n        else{\n            for(int j=0; j<result[i].size(); j++){\n                cout<<result[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n    }\n}",
        "example": "[{\"input\": \"2 7\\n1 1 3\\n3\\n1 1 4\\n1 2 1\\n1 2 2\\n2 1\\n3\", \"output\": \"3\\nnone\\n3\\n1 2\"}]",
        "time_limit": 5000,
        "memory_limit": 256
    },
    {
        "id": 1759,
        "problem_description": "假设我们有个集合{1,2,3……n}，输出所有满足集合中所有数求和是5的倍数的子集的个数。比如当n=4的时候，集合{1,2,3,4}中所有数求和是5的倍数的子集的个数是4个，分别是：{1 4}、 {2 3}、 {1 2 3 4}、 {}。下面请你根据不同的n，求出符合要求的子集个数。",
        "function_declaration": "int calculate_ans(int n)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    // calling start\n    int ans = calculate_ans(n);\n    // calling end\n    cout << ans;\n    return 0;\n}",
        "example": "[{\"input\": \"4\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1977,
        "problem_description": "众所周知，$x^n$在模一个固定的数m时的余数分布是有规律的,这在代数中被称为x在模m域上的轨道。举个简单的例子，比如$3^1,3^2,3^3,\\cdots $ 关于模7的余数是：$$(3,2,6,4,5,1),(3,2,6,4,5,1),\\ldots$$可以看到，模7的余数出现了循环。那么，你能找到这其中的规律吗？为了简化问题，我们只考虑模11时候的循环，给定整数n，你能输出$3^n$模11的余数吗？ 输入为一个整数n($0\\leqn\\leq10^9+1$) 输出为$3^n\\%11$",
        "function_declaration": "int calculateModulo(int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    // calling start\n    int result = calculateModulo(n);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"0\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1741,
        "problem_description": "一个数轴上有n个点，现在需要建立m个标记，使得每个点到最近的标记距离的和最小，请你求出最小距离的和。其中，标记可以与数轴上的点重合，若重合，则该点到标记的最近距离可以视为零。输入两个整数n m (1 ≤ m ≤ n ≤ 200)，表示点数量和标记数量。Distances包含n - 1个整数，表示数轴上每个点之间的距离d (1 ≤ d ≤ 100)。返回一个整数，表示最小距离的和。",
        "function_declaration": "int calculateMinDistanceSum(int n, int m, vector<int>& distances) ",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to calculate the minimum distance sum\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> distances(n - 1);\n    for (int i = 0; i < n - 1; ++i) {\n        cin >> distances[i];\n    }\n\n    // Calling the function to calculate the minimum distance sum\n    //calling start\n    int minSum = calculateMinDistanceSum(n, m, distances);\n    //calling end\n\n    cout << minSum << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"10 2\\n3 1 3 1 1 1 1 1 3\", \"output\": \"18\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1865,
        "problem_description": "班上有学生若干名，给出每名学生的身高（小数，单位为米），求班上所有学生的身高的最大值和最小值，保留到小数点后一位。",
        "function_declaration": "pair<float, float> findMinMax(int n, vector<float> heights)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;//人数 \n    vector<float> heights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> heights[i];\n    }\n    // calling start\n    pair<float, float> result = findMinMax(n, heights);\n    // calling end\n    printf(\"%.1f\\n%.1f\", result.first, result.second);\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1.6\\n1.4\\n1.8\\n1.7\\n1.5\", \"output\": \"1.8\\n1.4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2328,
        "problem_description": "给定 n 个非负整数，输出最大的数。小A觉得这道题过于简单，于是决定增加一点难度。小A会给你 q 个询问，每次给定两个正整数 l,r，表示询问第 l 个到第 r 个数中最大的数。",
        "function_declaration": "vector<int> answerQueries(int n, vector<int>& numbers, int q, vector<pair<int, int>>& queries) ",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> numbers(n);\n    for (int i = 0; i < n; i++) {\n        cin >> numbers[i];\n    }\n\n    vector<pair<int, int>> queries(q);\n    for (int i = 0; i < q; i++) {\n        cin >> queries[i].first >> queries[i].second;\n    }\n\n    // Calling the function to answer the queries\n    //calling start\n    vector<int> result = answerQueries(n, numbers, q, queries);\n    //calling end\n\n    // Outputting the results\n    for (int i = 0; i < q; i++) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"10 3\\n1 8 3 4 8 0 7 1 9 3\\n1 6\\n6 8\\n10 10\", \"output\": \"8\\n7\\n3\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2262,
        "problem_description": "暑假快结束了，结束乐队的成员们意识到大家还没有一起出游过，于是一行人打算前往江之岛游玩。现在是8月25日，大家希望能在25日到31日之间尽早安排这次旅行。但是大家都有自己的日程安排，需要找出一段大家都有空的时间。旅行必须安排在某一天的8时到20时之间的一段连续时间，且时长不能少于6小时。给出结束乐队4名成员的日程安排，请你帮忙判断旅行最早可以安排在哪天。输入一个非负整数 n。输入四个数组，数组中每个元素对应一个字符串 s 和三个整数 t,a,b，表示乐队成员 s 在8月t日a时到b时有事。对于 20% 的数据，$b \\le 12$；对于 100% 的数据，$n \\le 100$，s 是\"Nijika\",\"Ryo\",\"Bocchi\",\"Kita\"之一，$25 \\le t \\le 31$，$8 \\le a < b \\le 20$。返回一个25到31之间的整数，表示安排夏日旅行的日期。如果大家都很忙以至于没有合适的日期，返回-1。",
        "function_declaration": "int findEarliestDate(int n, vector<string> names, vector<int> days, vector<int> startTimes, vector<int> endTimes)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    vector<string> names(n);\n    vector<int> days(n);\n    vector<int> startTimes(n);\n    vector<int> endTimes(n);\n    for(int i=0; i<n; i++){\n        cin>>names[i]>>days[i]>>startTimes[i]>>endTimes[i];\n    }\n    // calling start\n    int result = findEarliestDate(n, names, days, startTimes, endTimes);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"7\\nNijika 26 8 10\\nKita 25 13 16\\nNijika 27 11 12\\nRyo 27 18 20\\nRyo 31 18 20\\nKita 28 10 15\\nKita 26 14 18\", \"output\": \"27\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1925,
        "problem_description": "三倍游戏是一个单人游戏。玩家会得到 n 个整数 $a_1$, $a_2$,...,$a_n$ 。玩家需要将这些数字两两配对，使得尽量多的配对数字相加后的和为 3 的倍数。请设计一个配对方案，输出最多能有多少对数字之和是 3 的倍数。1 ≤ $a_i$ ≤ 1,000,000；对于 50% 的数据，1 ≤n≤ 1000；对于 100% 的数据，1 ≤n≤ 100000。",
        "function_declaration": "int findMaxPairs(vector<int>& nums)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> nums[i];\n    }\n    //calling start\n    int result = findMaxPairs(nums);\n    //calling end\n    cout << result << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"4\\n1 3 3 2\", \"output\": \"2\"}, {\"input\": \"6\\n1 2 3 4 5 6\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1830,
        "problem_description": "DNA是染色体的主要化学成分，同时也是基因组成的材料，它重要的组成是：G 鸟嘌呤、C 胞嘧啶、A 腺嘌呤、T 胸腺嘧啶。作为科学家阿晓的有力助手，你要在她给定的多个DNA片段中，按照有序性由高到低进行排序。我们可以把一个片段看成一个字符串（由A C G T按顺序组成）,每个片段的有序性由其中相互无序的基因对数量表示。例如基因序列1AACTG中，相互无序的基因对只有T G一对；而基因序列2CGTA中，CA GA TA均为相互无序，共三对，所以我们认为基因序列1比基因序列2更有序。然而我们考虑会存在多个基因序列有序性相同的情况，那么这时我们按照序列长度由小至大排序；若长度也相同，则字典序顺序排列输出。现给定一个基因序列数组genes，请将其按题目要求排序。",
        "function_declaration": "void sortGenes(vector<string>& genes)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int N;\n    cin >> N;\n\n    for (int i = 0; i < N; i++) {\n        int k;\n        cin >> k;\n        vector<string> genes(k);\n\n        for (int j = 0; j < k; j++) {\n            cin >> genes[j];\n        }\n\n        //calling start\n        sortGenes(genes);\n        //calling end\n\n        for (int j = 0; j < k; j++) {\n            cout << genes[j] << endl;\n        }\n\n        // Print an empty line between each group of data\n        if (i < N - 1) {\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"2\\n6\\nAACATGAAGG\\nTTTTGGCCAA\\nTTTGGCCAAA\\nGATCAGATTT\\nCCCGGGGGGA\\nATCGATGCAT\\n3\\nCA\\nGC\\nACG\", \"output\": \"CCCGGGGGGA\\nAACATGAAGG\\nGATCAGATTT\\nATCGATGCAT\\nTTTTGGCCAA\\nTTTGGCCAAA\\n\\nACG\\nCA\\nGC\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1617,
        "problem_description": "$A_1,A_2,...,A_n$是一个由$n$个自然数（即非负整数）组成的数组。在此基础上，我们用数组$B_1,...,B_n$表示$A$的前缀最大值。$B_i=max\\{A_1,A_2,...,A_i\\}$如上所示，$B_i$定义为数组$A$中前$i$个数的最大值。根据该定义易知$A_1=B_1$，且随着$i$的增大，$B_i$单调不降。此外，我们用$sum=A_1+A_2+...+A_n$表示数组$A$中$n$个数的总和。现已知数组$B$，我们想要根据$B$的值来反推数组$A$。显然，对于给定的$B$，$A$的取值可能并不唯一。试计算，在数组$A$所有可能的取值情况中，$sum$的最大值和最小值分别是多少？输入包含一个正整数$n$及$n$个自然数$B_1,B_2,..,B_n$。50%的测试数据满足数组$B$单调递增，即$0<B1<B2<...<Bn<10^5$；全部的测试数据满足$n\\leq 100$且数组$B$单调不降，即$0\\leq B1\\leq B2\\leq ...\\leq Bn\\leq 10^5$。输出共两行。第一行输出一个整数，表示sum的最大值。第二行输出一个整数，表示sum的最小值。",
        "function_declaration": "void calculateSumMinMax(int n, vector<int>& B)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> B(n);\n    for(int i=0; i<n; i++){\n        cin>>B[i];\n    }\n    // calling start\n    calculateSumMinMax(n, B);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n0 0 5 5 10 10\", \"output\": \"30\\n15\"}, {\"input\": \"7\\n10 20 30 40 50 60 75\", \"output\": \"285\\n285\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2050,
        "problem_description": "DarkSharpness ，即 Dark 教授，是 C 国著名的数学家。现在，她面前有四个数字，作为数学家的她，一眼就看出来这四个数的平均值是正还是负。现在，她想考考您，这四个数的平均值是正还是负。简单来说，她会给你四个数字，你要判断他们的平均值是正数还是负数。如果四个整数的平均值大于 0 ，输出 Larger than 0如果四个整数的平均值恰为 0 ，输出 Exactly 0如果四个整数的平均值大于 0 ，输出 Smaller than 0.",
        "function_declaration": "string calculateSum(int a, int b, int c, int d)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    // calling start\n    string result = calculateSum(a, b, c, d);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"1 2 3 -2\", \"output\": \"Larger than 0\"}, {\"input\": \"11 4 -5 -14\", \"output\": \"Smaller than 0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2077,
        "problem_description": "chayso 先生面前有一串字符。出于好奇，他想要知道这一串字符里面有多少个大写字母，有多少个小写字母。请你写一个程序，帮他解决这个问题。特别地，请不要使用字符数组。第一个个整数表示小写字母有多少个，第二个整数表示大写字母有多少个。",
        "function_declaration": "pair<int, int> countLetters(int n, char c[])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    char c[100];\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n        cin >> c[i];\n    }\n    // calling start\n    pair<int, int> result = countLetters(n, c);\n    // calling end\n    cout << result.first << '\\n' << result.second;\n    return 0;\n}",
        "example": "[{\"input\": \"5\\nABcd0\", \"output\": \"2\\n2\"}]",
        "time_limit": 1000,
        "memory_limit": 8
    },
    {
        "id": 2302,
        "problem_description": "给定 $n$ 个数字，已知这些数字的入栈顺序为 $1,2,...,n$，给定一个出栈顺序 $a_1,a_2,...,a_n$，请判断它是否是一个合理的出栈顺序。如出栈顺序为4 5 3 2 1,对应的栈操作为1 入栈\n2 入栈\n3 入栈\n4 入栈\n4 出栈\n5 入栈\n5 出栈\n3 出栈\n2 出栈\n1 出栈",
        "function_declaration": "bool checkStackSequence(int n, int sequence[])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint sequence[100000];\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> sequence[i];\n\t}\n\t// calling start\n\tbool result = checkStackSequence(n, sequence);\n\t// calling end\n\tif (result) cout << \"Valid\";\n\telse cout << \"Invalid\";\n}",
        "example": "[{\"input\": \"5\\n4 5 3 2 1\", \"output\": \"Valid\"}, {\"input\": \"2\\n1 1\", \"output\": \"Invalid\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1893,
        "problem_description": "当游戏中出现玩家失败或者尴尬的场面时，通常会有一只乌鸦飞过，并且发出“啊啊啊啊啊啊”的声音。请你使用while循环输出以下效果：啊\n啊\n啊\n啊\n啊\n啊\n",
        "function_declaration": "void printAh(int times)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int times = 6;\n    // calling start\n    printAh(times);\n    // calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"啊\\n啊\\n啊\\n啊\\n啊\\n啊\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1700,
        "problem_description": "有一块大小是 2*a 的墙面，现在需要用2种规格的瓷砖铺满，瓷砖规格分别是 2 * 1 和 2 * 2，请计算一共有多少种铺设的方法。",
        "function_declaration": "int calculateF(int a)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f[50];\n\n// function start\n\n// function end\n\nint main(){\n    int a, t;\n    cin >> t;\n    // calling start\n    while (t--) {\n        cin >> a;\n        cout << calculateF(a) << endl;\n    }\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n2\\n8\\n12\", \"output\": \"3\\n171\\n2731\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1845,
        "problem_description": "给定一棵二叉树的前序遍历和中序遍历，求其后序遍历。输入两个字符串，其长度n均小于等于26。第一行为前序遍历，第二行为中序遍历。二叉树中的结点名称以大写字母表示：A，B，C....最多26个结点。",
        "function_declaration": "void doit(char *pre, char *in, int length)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main()\n{\n    char pre[30], in[30];\n    int length;\n    while (scanf(\"%s%s\", pre, in) != EOF) {\n        length = strlen(pre);\n  //calling start\n        doit(pre, in, length);\n  //calling end\n        cout << endl;\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"ABC\\nCBA\\nABCDEFG\\nDCBAEFG\", \"output\": \"CBA\\nDCBGFEA\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1654,
        "problem_description": "给定k(1<k<100)个正整数，其中每个数都是大于等于1，小于等于10的数。写程序计算给定的k个正整数中，1，5和10出现的次数。输入k个正整数，每两个正整数用一个空格分开。输出有三行，第一行为1出现的次数，第二行为5出现的次数，第三行为10出现的次数。",
        "function_declaration": "void countOccurrences(int k)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int k;\n    cin >> k;\n    //calling start\n    countOccurrences(k);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 5 8 10 5\", \"output\": \"1\\n2\\n1\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2182,
        "problem_description": "有n本书，第i本书的价格为a_i，小爱想把这些书全部买回家。现在正有一个买二送一的促销活动，即凡购买两本书，就可以免费带走第三本书，只要免费书的价格不超过两本付费书中任意一本的价格即可。请问，最少需要多少钱，才能将n本书全部买回家？",
        "function_declaration": "int calculateSum(int a[], int n)",
        "code_context": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n, ans, a[100010];\n\n// function start\n\n// function end\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    // calling start\n    ans = calculateSum(a, n);\n    // calling end\n    cout << ans << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n1 3 2 4 5 6\", \"output\": \"16\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2233,
        "problem_description": "给定 n 个整数和 q 个询问，每次询问给出一个数 a，问能否在 n 个数中选取可重复的 3 个，使它们的和为 a。",
        "function_declaration": "vector<string> canSumToA(int n, int q, vector<int>& numbers, vector<int>& queries)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    vector<int> numbers(n);\n    for (int i = 0; i < n; i++) {\n        cin >> numbers[i];\n    }\n\n    vector<int> queries(q);\n    for (int i = 0; i < q; i++) {\n        cin >> queries[i];\n    }\n    //calling start\n    vector<string> result = canSumToA(n, q, numbers, queries);\n    //calling end\n\n    for (const string& answer : result) {\n        cout << answer << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"2 3\\n-1 10\\n-3\\n8\\n20\", \"output\": \"Yes\\nYes\\nNo\"}]",
        "time_limit": 2000,
        "memory_limit": 512
    },
    {
        "id": 1765,
        "problem_description": "已知两个字符串，现需要将第二个字符串恰好插入第一个字符的中间。其中第一个字符串长度一定为偶数，请输出插入后得到的字符串。",
        "function_declaration": "void insertString(char* a, char* b)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar a[110], b[60];\n\n// function start\n\n// function end\n\nint main() {\n    cin >> a >> b;\n    // calling start\n    insertString(a, b);\n    // calling end\n    cout << a;\n    return 0;\n}",
        "example": "[{\"input\": \"ABCD\\nqwe\", \"output\": \"ABqweCD\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2257,
        "problem_description": "Dark 教授听说你学过了数组，决定考你一道相关的题目。她现在给你一个数列，有 n 个整数。接下来，她会给出 m 个操作。每次操作输入两个整数 x 和 y，表示把前 x 个元素的值加 y 。在 m 次操作后，她想知道最终的数列变成了什么，你能告诉她吗？输入n 个整数，表示数列，输入m 行，每行两个整数 x 和 y 表示一次操作。保证所有输入整数绝对值不超过 1000，且合法。",
        "function_declaration": "vector<int> finalSequence(int n, int m, vector<int>& nums, vector<pair<int, int>>& operations)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Function to perform the operations on the sequence\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    vector<pair<int, int>> operations(m);\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        cin >> x >> y;\n        operations[i] = make_pair(x, y);\n    }\n\n    // Calling the function to perform operations on the sequence\n    //calling start\n    vector<int> result = finalSequence(n, m, nums, operations);\n    //calling end\n\n    for (int i = 0; i < n; i++) {\n        cout << result[i] << endl;\n    }\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"5 3\\n0 0 0 1 0\\n1 -1\\n2 3\\n5 2\", \"output\": \"4\\n5\\n2\\n3\\n2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2037,
        "problem_description": "小万同学有一些苹果，他想要与小橙同学和另一个同学分享。当苹果不能平分时，如果只多一个，小万会把它给小橙。如果多两个，小万会去再买一个。给定N个苹果，请问小万、小橙、另一个同学各分到几个苹果？输出一行三个整数，中间用空格分隔。",
        "function_declaration": "void shareApples(int n) ",
        "code_context": "#include <iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    //calling start\n    shareApples(n);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n\", \"output\": \"1 1 1\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1658,
        "problem_description": "每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。识别码的计算方法如下：首位数字乘以1加上次位数字乘以2...以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，...，9，再求和，即0×1+6×2+...+2×9=158，然后取158 mod 11的结果4作为识别码。你的任务是编写程序计算识别码，输入为一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求），返回计算所得的识别码。",
        "function_declaration": "int calculateCode(char* str)",
        "code_context": "#include <bits/stdc++.h> \nusing namespace std;  \nchar str[20];  \n\n// function start\n\n// function end\n\nint main() {  \n    scanf(\"%s\", str);  \n\n    // calling start\n    int tmp = calculateCode(str);\n    // calling end\n\n    char c = tmp == 10 ? 'X' : tmp + '0';  // 计算识别码  \n    if (str[strlen(str) - 1] == c) \n        printf(\"Right\");  \n    else {  \n        str[strlen(str) - 1] = c;  \n        printf(\"%s\", str);  \n    }  \n    return 0;  \n}",
        "example": "[{\"input\": \"0-670-82162-4\", \"output\": \"Right\"}, {\"input\": \"0-670-82162-0\", \"output\": \"0-670-82162-4\"}]",
        "time_limit": 1000,
        "memory_limit": 50
    },
    {
        "id": 1762,
        "problem_description": "期末考结束了。一共考了5个科目，全校一共有10个人挂科了。假设拿到了这10人的挂科数目分别是：1、2、2、2、1、3、4、1、2、3。可以计数得到挂掉1科～挂掉4科的人数分别是：3、4、2、1。那么这10个人的挂科情况按照小到大的顺序输出就是：1 1 1 2 2 2 2 3 3 4。现在，输入10个整数，表示这10人的的挂科数目，请你从小到大输出这10个数据。",
        "function_declaration": "void sortScores(vector<int>& scores)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    vector<int> scores(10);\n    for(int i=0; i<10; i++){\n        cin>>scores[i];\n    }\n    // calling start\n    sortScores(scores);\n    // calling end\n}",
        "example": "[{\"input\": \"2 1 3 4 2 2 3 1 1 2\", \"output\": \"1 1 1 2 2 2 2 3 3 4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2000,
        "problem_description": "小爱获得了 $a$枚金牌，她获得的银牌数量比金牌多 $b$枚，她获得的铜牌数量比银牌多 $c$枚。请问她一共获得了多少枚奖牌？",
        "function_declaration": "int calculateSum(int a, int b, int c)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int a, b, c;\n  cin >> a >> b >> c;\n  \n  // calling start\n  int result = calculateSum(a, b, c);\n  // calling end\n  \n  cout << result;\n}",
        "example": "[{\"input\": \"1\\n2\\n3\", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2299,
        "problem_description": "给定一个长度为 $n$ 的数列：$a_1,a_2,...,a_n$，且每个元素都满足 $1≤a_i≤k$。请找出一个数列，它的每个元素同样不超过 $k$ 且不低于 1，且新数列不是原数列的子序列（所谓子序列，就是原序列中部分元素构成的序列，这些元素在原序列中不必连续）。请输出新序列的最短长度。",
        "function_declaration": "int calculateLength(int n, int k, int arr[])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n    int n, k;\n    cin >> n >> k;\n    int arr[n];\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n    // calling start\n    int result = calculateLength(n, k, arr);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"5 2\\n2 2 1 1 2\", \"output\": \"3\"}, {\"input\": \"9 3\\n1 2 3 1 2 3 1 2 3\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1631,
        "problem_description": "现有一个空的整数序列，需要你对其进行如下操作：若命令为1 x，表示需要在这个序列末尾新插入整数x。若命令为2 x，表示需要删除从前向后第x个数字，数据保证x一定小于等于当前序列中整数的个数。若命令为3 x，表示需要输出从前向后第x个数字，数据保证x一定小于等于当前序列中整数的个数。输入第一行一个整数m，表示操作的次数。数据保证m ≤ 10^3。接下来m行，每行两个整数，第一个数字表示该次操作的类型，第二个数字x表示该此操作的参数，具体如题目所表述。输出一行，若干个整数，为命令3输出的数字，用空格隔开。",
        "function_declaration": "vector<int> operateSequence(int m, vector<pair<int, int>>& operations)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int m;\n    cin>>m;\n    vector<pair<int, int>> operations;\n    for(int i=0; i<m; i++){\n        int type, x;\n        cin>>type>>x;\n        operations.push_back(make_pair(type, x));\n    }\n    // calling start\n    vector<int> result = operateSequence(m, operations);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n1 1\\n1 2\\n1 3\\n2 2\\n3 1\\n3 2\", \"output\": \"1 3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1634,
        "problem_description": "给定一个整数序列，在其中找出连续的一段，使得这段连续子序列的和最大。若该整数序列中所有数全部为负数，则答案为零。",
        "function_declaration": "int calculateMaxSum(int n, int a[], int sum[])",
        "code_context": "#include <iostream>\n\n#define N 2010\n\nusing namespace std;\n\nint a[N], sum[N];\n\n// function start\n\n// function end\n\nint main() {\n    int n, ans = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    // calling start\n    ans = calculateMaxSum(n, a, sum);\n    // calling end\n    cout << ans << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n2 -1 3 -4 3\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1859,
        "problem_description": "给定一张网格图，其中0代表可以走的地方，1代表不能走的地方，并且我们只能够横向和竖向走。已知出发点和目标点，请你找出一条路径，使得转弯次数最少，并求出最少转弯次数。 输入一个二维数组描述地图，0表示可以经过，1表示不能通过。输入起始位置和目标位置。 返回一个整数，表示最少的方向变化次数。",
        "function_declaration": "int calculateMinTurns(vector<vector<int>>& grid, pair<int, int> start, pair<int, int> target)",
        "code_context": "   #include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n, m;\n    cin>>n>>m;\n    \n    vector<vector<int>> grid(n, vector<int>(m));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            cin>>grid[i][j];\n        }\n    }\n    \n    pair<int, int> start, target;\n    cin>>start.first>>start.second;\n    cin>>target.first>>target.second;\n    \n    // calling start\n    int result = calculateMinTurns(grid, start, target);\n    // calling end\n    \n    cout<<result;\n}",
        "example": "[{\"input\": \"5 7\\n1 0 0 0 0 1 0 \\n0 0 1 0 1 0 0 \\n0 0 0 0 1 0 1 \\n0 1 1 0 0 0 0 \\n0 0 0 0 1 1 0\\n1 3\\n1 7\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2214,
        "problem_description": "九宫格输入法适合在手机上使用，它在屏幕上的布局如下：1 2abc 3def 4ghi 5jkl 6mno 7pqrs 8tuv 9wxyz 0，如果要打出一个x，就需要按两下9。第一次按9号键会出现w，按第二次才会将w改成x。注意0号键的作用是打出一个空格。给定一些仅有小写字母和空格组成的字符序列，请计算用九宫格输入法总计需要按多少次键。",
        "function_declaration": "int calculateKeyPresses(const string& input)",
        "code_context": "#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\n//function start\n//function end\n\nint main() {\n    string input;\n    getline(cin, input);\n    //calling start\n    int totalKeyPresses = calculateKeyPresses(input);\n    //calling end\n    cout << totalKeyPresses << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"hello world\", \"output\": \"25\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1563,
        "problem_description": "按照顺序输入n个数字，请你将这n个数字倒序输出。比如输入的3个数字为1 3 5，请你输出5 3 1。其中1 <= n <= 100。",
        "function_declaration": "void reversePrint(int n, int nums[])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    int nums[101];\n    \n    cin >> n;\n    \n    for (int i=0; i<n; i++)\n        cin >> nums[i];\n    \n    // calling start\n    reversePrint(n, nums);\n    // calling end\n    \n    return 0;\n}",
        "example": "[{\"input\": \"3\\n2 1 3\", \"output\": \"3 1 2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1647,
        "problem_description": "已知一个长度为n (1 ≤ n ≤ 10^5)的数列，其中元素保证不重复。现在我们想查询一些数字是否在这个数列中出现。nums包含n个整数，表示该数列。Queries包含m个整数，表示我们要查询的数字。注意：数字的大小有可能超过int的存储范围。返回m个字符串，对应查询的结果。若该次查询的数字在数列中，则返回yes；反之，则返回no。",
        "function_declaration": "vector<string> checkNumbers(vector<int> nums, vector<int> queries)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n, m;\n    cin>>n>>m;\n    vector<int> nums(n);\n    for(int i=0; i<n; i++){\n        cin>>nums[i];\n    }\n    vector<int> queries(m);\n    for(int i=0; i<m; i++){\n        cin>>queries[i];\n    }\n    // calling start\n    vector<string> result = checkNumbers(nums, queries);\n    // calling end\n    for(int i=0; i<result.size(); i++){\n        cout<<result[i]<<endl;\n    }\n}",
        "example": "[{\"input\": \"3 2\\n1 2 3\\n1 10\", \"output\": \"yes\\nno\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1943,
        "problem_description": "读入三个整数，按每个整数占8个字符的宽度，右对齐输出它们，之间以一个空格分开。",
        "function_declaration": "void printFormatted(int a, int b, int c)",
        "code_context": "#include <iostream> \nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int a, b, c;\n    cin >> a >> b >> c;\n\n    // calling start\n    printFormatted(a, b, c);\n    // calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"123456789 0 -1\", \"output\": \"123456789        0       -1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2083,
        "problem_description": "春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为 $n$ 的大厦，大厦可以看成由 $n$ 块宽度为 $1$ 的积木组成，第 $i$ 块积木的最终高度需要是 $h_i$。在搭建开始之前，没有任何积木（可以看成 $n$ 块高度为 $0$ 的积木）。接下来每次操作，小朋友们可以选择一段连续区间 $[l, r]$，然后将第 $L$ 块到第 $R$ 块之间（含第 $L$ 块和第 $R$ 块）所有积木的高度分别增加 $1$。小 M 是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。输入包含一个整数 $n$，表示大厦的宽度，一个数组包含 $n$ 个整数，第 $i$ 个整数为 $h_i$，输出建造所需的最少操作数。",
        "function_declaration": "int minimumOperations(int n, vector<int>& heights)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> heights(n);\n    for (int i = 0; i < n; i++) {\n        cin >> heights[i];\n    }\n\n    //calling start\n    int minOperations = minimumOperations(n, heights);\n    cout << minOperations << endl;\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n2 3 4 1 2\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2275,
        "problem_description": "给定一个长度为 n 的整数数组，找到一段连续的数（至少1个），使得它们的和最大，返回一个整数，表示你找到的一段连续的数的和。",
        "function_declaration": "long long findMaxSubarraySum(int n, vector<long long>& arr)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<long long> arr(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tcin >> arr[i];\n\t}\n\t// calling start\n\tlong long ans = findMaxSubarraySum(n, arr);\n\t// calling end\n\tcout << ans;\n}",
        "example": "[{\"input\": \"9\\n-1 8 3 -7 5 3 -9 2 6\", \"output\": \"12\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1559,
        "problem_description": "星期一～星期日的英文分别是：monday、tuesday、wednesday、thursday、friday、saturday和sunday。输入1～7中的一个整数，如果输入1，输出monday；如果输入2，输出tuesday；……如果输入7，输出sunday；（请用switch语句完成）",
        "function_declaration": "string getDay(int a)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a;\n    cin >> a;\n    // calling start\n    string day = getDay(a);\n    // calling end\n    cout << day;\n    return 0;\n}",
        "example": "[{\"input\": \"1\", \"output\": \"monday\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2144,
        "problem_description": "一个圆型的蛋糕，切$n$刀后，最多能将蛋糕分成多少块？例如$n=3$时，最多可以分成 $7$块。",
        "function_declaration": "int calculate_sum(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n   int n;\n   cin >> n;\n   // calling start\n   cout << calculate_sum(n) << \"\\n\";  \n   // calling end\n}",
        "example": "[{\"input\": \"1\", \"output\": \"2\"}, {\"input\": \"3\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1659,
        "problem_description": "春天是鲜花的季节，水仙花就是其中最迷人的代表，数学上有个水仙花数，他是这样定义的： “水仙花数”是指一个三位数，它的各位数字的立方和等于其本身，比如：153=13+53+33153=13+53+33。现在要求输出所有在m和n范围内的水仙花数。如果有多个，则要求从小到大排列在一行内输出，之间用一个空格隔开;如果给定的范围内不存在水仙花数，则输出\"no\";",
        "function_declaration": "void findNarcissisticNumber(int m, int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int m, n;\n    cin>>m>>n;\n    // calling start\n    findNarcissisticNumber(m, n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"100 120\\n\", \"output\": \"no\\n\"}, {\"input\": \"300 380\", \"output\": \"370 371\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1822,
        "problem_description": "给出一串数以及一个数字 C，要求计算出所有 A-B=C 的数对的个数（不同位置的数字一样的数对算不同的数对）。输入n 个整数和c，输出n 个整数中包含的满足 A-B=c的数对的个数。",
        "function_declaration": "long long  calculate_ans(int n, int c, int b[])",
        "code_context": "#include <cstdio> \n#include <cstring> \n#include <iostream> \n#include <algorithm> \n#define N 200005 \nusing namespace std; \n\nint n, c, b[N]; \n\n// function start\n\n// function end\n\nint main() { \n    scanf(\"%d%d\", &n, &c); \n    for (int i = 0; i < n; ++i) scanf(\"%d\", &b[i]); \n\n    // calong long ing start\n    long long  ans = calculate_ans(n, c, b);\n    // calong long ing end\n     \n    printf(\"%lld\\n\", ans); \n    return 0; \n}",
        "example": "[{\"input\": \"4 1\\n1 1 2 3\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1701,
        "problem_description": "已知方程2x^3 - 4x^2 + 3x - 6 = 0，用二分法求此方程在区间(l,r)之间的根，数据保证输入区间内有根。计算至误差小于10^-6为止。",
        "function_declaration": "double calculateMid(double l, double r)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// function start\n\n\n// function end\n\nint main(){\n    double l, r, mid;\n    cin >> l >> r;\n    // calling start\n    mid = calculateMid(l, r);\n    // calling end\n    printf(\"%.6lf\\n\", mid);\n    return 0;\n}",
        "example": "[{\"input\": \"-10 10\", \"output\": \"2.000000\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1945,
        "problem_description": "给定被除数和除数，求整数商及余数。",
        "function_declaration": "int calculate(int a, int b, int &div, int &mod)",
        "code_context": "#include<cstdio>\n\n// function start\n\n// function end\n\nint main(){\n    int a,b;\n    int div, mod;\n    scanf(\"%d%d\",&a,&b);\n    // calling start\n    calculate(a, b, div, mod);\n    // calling end\n    printf(\"%d %d\",div,mod);\n}",
        "example": "[{\"input\": \"10 3\", \"output\": \"3 1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1942,
        "problem_description": "读入一个双精度浮点数，保留12位小数，输出这个浮点数。",
        "function_declaration": "double process(double a)",
        "code_context": "#include <iostream> \nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    double a;\n    cin >> a;\n    // calling start\n    double result = process(a);\n    // calling end\n    printf(\"%.12f\", result);\n\n    return 0;\n}",
        "example": "[{\"input\": \"3.1415926535798932\", \"output\": \"3.141592653580\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2115,
        "problem_description": "给定 n 个整数，选择其中三个数，使得乘积最大。",
        "function_declaration": "long long findMaxProduct(long long arr[], long long n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,a[2000];\n\n// function start\n\n// function end\n\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;++i) cin>>a[i];\n\t\n    // calling start\n\tlong long result = findMaxProduct(a, n);\n    // calling end\n\n\tcout<<result;\n}",
        "example": "[{\"input\": \"10\\n-3 4 3 0 4 1 -9 7 8 -1\", \"output\": \"224\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1731,
        "problem_description": "用递归算法将一个十进制数n转换成任意进制数k（k<=16）。比如将17转换为2进制数为：10001将17转换为16进制数为：11十六进制数是用0～9，和A～F来表示的。",
        "function_declaration": "string t(int n, int k)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\nchar d[16] = {'0','1', '2','3', '4','5', '6', '7', '8','9', 'A','B', 'C','D', 'E','F'};\n// function start\n\n\n// function end\n\nint main () {\n    int x, m;\n    cin >> x >> m;\n    // calling start\n    string res = t(x, m);\n    // calling end\n    cout << res << endl;\n    return 0; \n}",
        "example": "[{\"input\": \"17 2\", \"output\": \"10001\"}, {\"input\": \"17 16\", \"output\": \"11\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1697,
        "problem_description": "输出高度为n (1 ≤ n ≤ 36)的杨辉三角形。【每一行的最左侧和最右侧数字都是 1，其他的每个数是它左上方和右上方的两个数字之和】",
        "function_declaration": "void calculate(int n)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint f[60][60];\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin >> n;\n    // calling start\n    calculate(n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"5\", \"output\": \"1\\n1 1\\n1 2 1\\n1 3 3 1\\n1 4 6 4 1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2339,
        "problem_description": "Dark 教授听说你学会了递归函数，她出了一道难题。现在你面前有若干个个台阶。你每次可以向上跳 $a_1$ 或 $a_2$ 或....或 $a_m$ 个台阶，即 m 种不同的跳法。现在，你要回答，跳上 $n$ 个台阶一共有多少种跳法。例如 $n = 3$ , $m = 2$, $a_1 = 2$ , $a_2 = 1$。此时，你可以连续三次跳 1 个台阶；或者先跳一次 2 个台阶，再跳一次 1 个台阶；或者先跳一次 1 个台阶，再跳一次两个台阶。所以一共有三种跳法。",
        "function_declaration": "int countWaysToReachN(int n, const vector<int>& stepSizes)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> stepSizes(m);\n    for (int i = 0; i < m; i++) {\n        cin >> stepSizes[i];\n    }\n\n    //calling start\n    int ways = countWaysToReachN(n, stepSizes);\n    //calling end\n\n    cout << ways << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"4 2\\n1 2\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2219,
        "problem_description": "在一次算法比赛中，有 $n$ 个程序提交到了竞赛平台上，测试每个程序需要两步：先编译，然后运行。竞赛平台有两台服务器，一台只负责编译，另一台只负责运行，编译第 $i$ 个程序的时间为 $a_i$，运行第 $i$ 个程序的时间为 $b_i$。服务器必须按照提交顺序来处理任务，也就是说一定要先处理第一个程序，最后处理第 $n$ 个程序。每台服务器在同一时刻只能处理一个任务。请问平台需要多少时间才能测试完所有的程序？",
        "function_declaration": "int calculateRunTime(int n, int arr[][2])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint arr[n][2];\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> arr[i][0] >> arr[i][1];\n\t}\n\t// calling start\n\tint result = calculateRunTime(n, arr);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"3\\n10 5\\n20 30\\n5 50\", \"output\": \"110\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2033,
        "problem_description": "小万同学邀请小橙同学一起听音乐。一首音乐可以用 $n$ 个乐符来表示，每个乐符可以用一个数字来表示。小橙喜欢变化的音乐。小万同学想知道一首歌曲中，最长的不断变化的连续一段乐符是多长，以及最长的不变化的连续一段乐符有多长。",
        "function_declaration": "pair<int, int> calculateMaxChangeAndContinual(int n, int* arr)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n = 0;\n\tcin >> n;\n\tint* arr = new int[n];\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> arr[i];\n\t}\n\t// calling start\n\tpair<int, int> result = calculateMaxChangeAndContinual(n, arr);\n\t// calling end\n\tcout << result.first << endl << result.second << endl;\n\tdelete[] arr;\n\treturn 0;\n}",
        "example": "[{\"input\": \"6\\n1 2 3 4 4 4 \\n\", \"output\": \"4\\n3\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1693,
        "problem_description": "给定一个n (n <= 200)层的金字塔，求一条从最高点到底层任意点的路径使得路径经过的数字之和最大。",
        "function_declaration": "int calculateMaxSum(int n)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[210][210], f[210][210];\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= i; j++)\n            cin >> a[i][j];\n    // calling start\n    int ans = calculateMaxSum(n);\n    // calling end\n    cout << ans << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"6\\n2\\n96 30\\n83 52 60\\n21 65 44 61\\n8 79 50 41 21\\n61 41 50 38 79 10\", \"output\": \"375\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1548,
        "problem_description": "输出一句话：This is my second program.",
        "function_declaration": "void printMessage()",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    // calling start\n    printMessage();\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \" \", \"output\": \"This is my second program.\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2076,
        "problem_description": "数列众数，定义为一个数列中出现次数最多的数字。例如，在数列 1,2,1,3,4,5,6,2 中，出现次数最多的数字为 1 和 2 ，因此该数列众数就是 1 和 2。现在，给定一个数列，求出其中的众数。如果出现多个众数，则输出其中最大的一个。",
        "function_declaration": "int findMaxCount(int n, int arr[])",
        "code_context": "#include <iostream>\nusing namespace std;\nconst int M = 101;\nint cnt[M];\n\n// function start\n\n// function end\n\nsigned main() {\n    int n;\n    cin >> n;\n    int arr[n];\n    for(int i = 0; i < n ; ++i) {\n        cin >> arr[i];\n    }\n    // calling start\n    int result = findMaxCount(n, arr);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"8\\n0 1 8 9 1 9 1 9\", \"output\": \"9\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2102,
        "problem_description": "这天小万和小橙又在格子广场玩游戏。地上一共有 $n$ 个格子，依次编号为 $0,1,2,..., n-1$，它们围成了一个圈，也就是说，格子$n-1$ 的右边是 $0$。设 $a$，$b$ 是给定的两个整数。每一次行动前，小万站在 $x$ 位置，然后他需要向右走 $a\\times x + b$ 步。最开始的时候，小橙和小万一起站在第 $A$ 号格子。然后小万开始行动。小万想知道，行动多少次之后，他能停在第 $A$ 号格子。",
        "function_declaration": "long long findIndex(long long n, long long a, long long b, long long A)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    long long n = 0, a = 0, b = 0, A = 0;\n    cin >> n >> a >> b >> A;\n    // calling start\n    long long index = findIndex(n, a, b, A);\n    // calling end\n    cout << index << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"3 1 1 0\\n\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2132,
        "problem_description": "输入一个偶数 $N$，验证 $4~N$ 所有偶数是否符合哥德巴赫猜想：任一大于 $2$ 的偶数都可写成两个质数之和。如果一个数不止一种分法，则输出第一个加数相比其他分法最小的方案。例如 $10$，$10=3+7=5+5$，则 $10=5+5$ 是错误答案。输出 $\\dfrac{N-2}{2}$ 行。对于第 $i$ 行：首先先输出正偶数 $2i+2$，然后输出等号，再输出加和为 $2i+2$ 且第一个加数最小的两个质数，以加号隔开。",
        "function_declaration": "void verifyGoldbachConjecture(int N)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int N;\n    cin >> N;\n    //calling start\n    verifyGoldbachConjecture(N);\n    //calling end\n    return 0;\n}\n",
        "example": "[{\"input\": \"10\", \"output\": \"4=2+2\\n6=3+3\\n8=3+5\\n10=3+7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1593,
        "problem_description": "当一个n位数k的每一位都是同样的数字a时，我们把k称作a的n重数，例如666被称为6的三重数。现在给定a和n，求a的n重数k。对于100%的数据满足1 ≤ k ≤ 10^11。",
        "function_declaration": "long long calculateNum(int a, int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int t, a, n;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n        cin >> a >> n;\n        // calling start\n        long long num = calculateNum(a, n);\n        // calling end\n        cout << num << endl;\n    }\n    \n    return 0;\n}",
        "example": "[{\"input\": \"2\\n1 2\\n6 3\", \"output\": \"11\\n666\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2347,
        "problem_description": "给定两个正整数 n,m，输入 n 个数，输出第 m 个数。",
        "function_declaration": "int get_element(int a[],int index)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nint a[101];\n\n// function start\n\n// function end\n\nint main(){\n int n,m;\n cin>>n;\n for(int i=1;i<=n;++i) cin>>a[i];\n cin>>m;\n \n // calling start\n int result = get_element(a,m);\n // calling end\n \n cout<<result;\n}",
        "example": "[{\"input\": \"5 \\n5 4 3 2 1\\n4\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2176,
        "problem_description": "小A写了一个如下的递归程序：#include<bits/stdc++.h>\nusing namespace std;\nint f(int x){\n    if(x==1) return 1;\n    return f(x-1)%7+f(x-1)%9;\n}\nint main(){\n    int n;\n    cin>>n;\n    cout<<f(n);\n    return 0;\n}给定输入的 x，请计算程序运行的整个过程中函数 f 总共被调用了多少次。",
        "function_declaration": "int countFunctionCalls(int x)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    //calling start\n    int totalCalls = countFunctionCalls(n);\n    //calling end\n    cout << totalCalls << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"2\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2224,
        "problem_description": "假设：语文课每过$a$天考试一次；数学课每过$b$天考试一次；英语课每过$c$天考试一次。又假设，在昨天，这三门课同时发生了考试。那么从今天开始算起，在接下来的$t$天时间里，有多少天是没有考试的呢？",
        "function_declaration": "long long calculate(long long t, long long a, long long b, long long c)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tlong long t, a, b, c;\n\tcin >> t >> a >> b >> c;\n\t// calling start\n\tlong long result = calculate(t, a, b, c);\n\t// calling end\n\tcout << result;\t           \n}",
        "example": "[{\"input\": \"20\\n3 5 7\", \"output\": \"9\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2155,
        "problem_description": "有只猴子发现了一堆桃子，接下来的$n$天，它重复执行以下操作：在每一天的上午，猴子会吃掉一半数量的桃子，输入数据保证每天早上桃子的数量都是偶数，不会出现不可分的情况；在每一天的下午，它会从森林里找1只新桃子加入桃子堆。若在第$n$天晚上，还剩$a$只桃子，请问猴子刚发现桃子的时候有多少只？",
        "function_declaration": "int calculate(int n, int a)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n  int n, a;\n  cin >> n >> a;\n  // calling start\n  a = calculate(n, a);\n  // calling end\n  cout << a;\n}",
        "example": "[{\"input\": \"3 5\", \"output\": \"26\"}, {\"input\": \"5 10\", \"output\": \"258\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1907,
        "problem_description": "1号同学说：我比2号多了5分。2号同学说：我比3号多了5分。 3号同学说：我比4号多了5分。4号同学说：我比5号多了5分。5号同学说：我考了62分。给定学生编号，请用递归求出这位同学考的分数。",
        "function_declaration": "int score(int stuNum)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main(){\n    //calling start\n    cout <<\"2号同学的分数是：\" << score(2);\n    //calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"2号同学的分数是：77\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2203,
        "problem_description": "四方定理是数论中著名的一个定理，指任意一个自然数都可以拆成四个自然数的平方之和。例如：$$25=1^2 + 2^2 + 2^2 + 4^2$$对25来说，还有其他方案：$$25=0^2 + 0^2 + 3^2 + 4^2$$以及$$25=0^2 + 0^2 + 0^2 + 5^2$$给定一个自然数 $n$，请输出 $n$ 的所有四平方拆分方案。输出若干行：每行四个由小到大排列的自然数，表示一种拆分方案。如果有多种方案，先输出首项较小的方案，对于首项相同的方案，先输出第二项较小的方案，其他情况以此类推。",
        "function_declaration": "void findSquares(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n    int n;\n    cin >> n;\n    // calling start\n    findSquares(n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"25\", \"output\": \"0 0 0 5\\n0 0 3 4\\n1 2 2 4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2323,
        "problem_description": "给定两个正整数，求最大公约数。",
        "function_declaration": "int calculateGCD(int a, int b)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int a,b;\n    cin>>a>>b;\n    // calling start\n    int result = calculateGCD(a, b);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"9 6\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2272,
        "problem_description": "给定2023年的一个日期，判断这一天是不是疯狂星期四（即周四）。输入为一行，包含两个正整数 m,d，表示给定的日期是2023年m月d日。对于 100% 的数据，保证2023年m月d日是合法的日期。如果是疯狂星期四，输出\"V50\"；如果不是，输出\"No\"。",
        "function_declaration": "string checkDate(int m, int d)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n\n// function start\n\n// function end\n\nint main(){\n    int m,d;\n    cin>>m>>d;\n    // calling start\n    string result = checkDate(m, d);\n    // calling end\n    cout<<result;\n    return 0;\n}",
        "example": "[{\"input\": \"6 1\", \"output\": \"V50\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1640,
        "problem_description": "有m个小组，n个元素，每个元素属于且仅属于一个小组。支持以下操作：push x：使元素x进队，如果前边有x所属小组的元素，x会排到自己小组最后一个元素的下一个位置，否则x排到整个队列最后的位置。pop：出队，弹出队头并输出出队元素，出队的方式和普通队列相同，即排在前边的元素先出队。对于全部测试数据，保证1 ≤ n ≤ 10^5，1 ≤ m ≤ 300，T ≤ 10^5，输入保证操作合法。输入有两个正整数n m，分别表示元素个数和小组个数，元素和小组均从0开始编号。Groups包含n个非负整数Ai，表示元素i所在的小组。一个正整数T，表示操作数。读入T行，每行为一个操作。对于每个出队操作输出一行，为出队的元素。",
        "function_declaration": "void groupQueueOperations(int n, int m, vector<int>& groups, int T)",
        "code_context": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform group-specific queue operations\n//function start\n\n//function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> groups(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> groups[i];\n    }\n\n    int T;\n    cin >> T;\n\n    //calling start\n    groupQueueOperations(n, m, groups, T);\n    //calling end\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"4 2\\n0 0 1 1\\n6\\npush 2\\npush 0\\npush 3\\npop\\npop\\npop\", \"output\": \"2\\n3\\n0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1821,
        "problem_description": "给定$$n$$个整数，从小到大输入，返回一个数$$x$$在该数组中出现的次数。",
        "function_declaration": "int countOccurrences(int arr[], int n, int x)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[100010];\n\n// function start\n\n// function end\n\nint main() {\n    int n, m, x;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    // calling start\n    while (m--) {\n        cin >> x;\n        cout << countOccurrences(a, n, x) << \" \";\n    }\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"10 3\\n1 2 2 2 3 5 7 7 10 20\\n2 3 11\", \"output\": \"3 1 0 \"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2304,
        "problem_description": "给定 $n$ 个整数 $a_1,a_2,...,a_n$，并且保证 $a_1<a_2<...<a_n$，再给定一个目标值 $t$，请判断是否能从数列中挑出两个不同的数 $a_i$ 与 $a_j$，使得 $a_i+a_j=t$。",
        "function_declaration": "bool findPair(int a[], int n, int t)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\tint a[1000000];\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n    int t;\n    cin >> t;\n\n    // calling start\n    bool result = findPair(a, n, t);\n    // calling end\n\n    if (!result) cout << \"No\";\n    else cout << \"Yes\";\n}",
        "example": "[{\"input\": \"4\\n1 3 5 7\\n8\", \"output\": \"Yes\"}, {\"input\": \"4\\n2 4 6 8\\n11\", \"output\": \"No\"}, {\"input\": \"3\\n1 2 5\\n2\", \"output\": \"No\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 304,
        "problem_description": "我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。FBI树是一种二叉树，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下：1) T的根结点为R，其类型与串S的类型相同；2) 若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。现在给定一个长度为2N的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历序列。输入一个整数N（0<=N<=10）及一个长度为2^N的“01”串。数据规模：对于40%的数据，N<=2；对于全部的数据，N<=10。输出一个字符串，即FBI树的后序遍历序列。",
        "function_declaration": "string constructFBITree(int N, string S)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int N;\n    string S;\n    cin>>N>>S;\n    // calling start\n    string result = constructFBITree(N, S);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"3\\n10001011\", \"output\": \"IBFBBBFIBFIIIFF\"}]",
        "time_limit": 1000,
        "memory_limit": 125
    },
    {
        "id": 2307,
        "problem_description": "给定一个仅由(，)，[与]构成的括号序列，请判断它是否是平衡的，平衡的定义如下：空序列是平衡的；如果某个括号序列s是平衡的，那么[s]与(s)也是平衡的；如果某两个括号序列s与t都是平衡的，那么st也是平衡的。",
        "function_declaration": "bool isBalanced(string& brackets)",
        "code_context": "#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\n\n// Function to check if the given bracket sequence is balanced\n//function start\n\n//function end\n\nint main() {\n    string brackets;\n    cin >> brackets;\n\n    // Calling the function to check if the bracket sequence is balanced\n    //calling start\n    bool balanced = isBalanced(brackets);\n    //calling end\n\n    if (balanced) {\n        cout << \"Balanced\" << endl;\n    } else {\n        cout << \"Unbalanced\" << endl;\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"[(])\", \"output\": \"Unbalanced\"}, {\"input\": \"[()][()()]()\", \"output\": \"Balanced\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2145,
        "problem_description": "小爱投入在学习上的总时间为$n$秒。请将它转换成以小时、分钟和秒组成的时间格式，中间以冒号:分割。例如$n=3600$，输出1:0:0，因为$3600$秒恰好为一小时。",
        "function_declaration": "string convertToTimeFormat(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// Function to convert seconds to time format\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    //calling start\n    string timeFormat = convertToTimeFormat(n);\n    //calling end\n    cout << timeFormat << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"100\", \"output\": \"0:1:40\"}, {\"input\": \"3601\", \"output\": \"1:0:1\"}, {\"input\": \"35999999\", \"output\": \"9999:59:59\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2241,
        "problem_description": "请你计算组合数 $C_n^m$ 的值，由于结果可能很大，你只需要输出结果 mod 19260817 的值。",
        "function_declaration": "int calculate(int n, int m)",
        "code_context": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint n, m;\nint c[3010][3010];\n\n// function start\n\n// function end\n\nint main() {\n    cin >> n >> m;    \n    // calling start\n    int result = calculate(n, m);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"514 114\", \"output\": \"12230097\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2127,
        "problem_description": "今天小万同学又来帮小橙同学买零食啦！小橙同学给了他一个清单，他从前向后阅读，每当阅读到一种零食时，小万都想知道这种零食他已经看到了多少次。形式化的，设第 $i$ 个零食的种类为 $a_i$，对 $i=1,2\\dots n$，小万同学想知道有多少个 $0\\le j\\le i$ 满足 $a_j=a_i$，返回每次阅读到一种零食时，这种零食看到的次数。",
        "function_declaration": "vector<int> countSnacks(vector<int>& snacks)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> snacks(n);\n    for (int i = 0; i < n; i++) {\n        cin >> snacks[i];\n    }\n\n     //calling start\n    vector<int> result = countSnacks(snacks);\n   //calling end\n    for (int i = 0; i < n; i++) {\n        cout << result[i] << '\\n';\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 2 1 2 1\\n\", \"output\": \"1\\n1\\n2\\n2\\n3\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1797,
        "problem_description": "编写一个函数char *substr(char *s,int begin,int end)，用于取得字符串s中从begin位置开始到end位置（不包含end处的字符）结束的子字符串，字符串的长度不超过30个字符。",
        "function_declaration": "char *substring(const char *s, int begin, int end)",
        "code_context": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    char s[35];\n    int b, e;\n    cin >> s >> b >> e;\n    // calling start\n    char* result = substring(s, b, e);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"1234567890\\n1 5\", \"output\": \"2345\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2206,
        "problem_description": "给定 $n$ 个人的出生日期，请找出其中年龄最大的，并输出他的出生日期。出生日期格式如下：首先有一个四位数 $y$ 表示年份；接下来有一个两位数 $m$ 表示月份；最后有一个两位数 $d$ 表示日期；年月日之间以一个减号 $-$ 隔开。数据范围对于 50%的数据，1≤n≤1,000；对于 100%的数据，1≤n≤1,000,000；1900≤y≤2020；保证月份和日期都是两位数且是合理的日期。返回一行字符串：表示最早的出生日期，格式同输入。",
        "function_declaration": "string findEldest(int n, vector<string> dates) ",
        "code_context": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n int n;\n cin >> n;\n vector<string> dates(n);\n for(int i = 0; i < n; ++i) {\n  cin >> dates[i];\n }\n // calling start\n string eldest = findEldest(n, dates);\n // calling end\n cout << eldest;\n}",
        "example": "[{\"input\": \"4\\n2008-08-08\\n1953-06-15\\n1949-10-01\\n1926-08-18\", \"output\": \"1926-08-18\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1764,
        "problem_description": "给定两个数列，检查第二个数列中的数字是否在第一个数列中出现。返回同时出现在两个数列中的数字，由小到大排序。",
        "function_declaration": "vector<int> findCommonElements(vector<int>& nums1, vector<int>& nums2)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> nums1(n), nums2(m);\n    for (int i = 0; i < n; i++) {\n        cin >> nums1[i];\n    }\n    for (int i = 0; i < m; i++) {\n        cin >> nums2[i];\n    }\n    // calling start\n    vector<int> result = findCommonElements(nums1, nums2);\n    // calling end\n    for (int num : result) {\n        cout << num << \" \";\n    }\n}",
        "example": "[{\"input\": \"4 5\\n1 10 6 7\\n2 3 6 10 1\", \"output\": \"1 6 10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2086,
        "problem_description": "小A希望你帮他解决一道难题：输入一个数，输出它本身。",
        "function_declaration": "string process_string(string a)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    string a;\n    cin>>a;\n    // calling start\n    string result = process_string(a);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"7\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2020,
        "problem_description": "现在有 n(n <= 1000) 位评委给选手打分，分值从 0 到 10。需要去掉一个最高分，去掉一个最低分（如果有多个最高或者最低分，也只需要去掉一个），剩下的评分的平均数就是这位选手的得分。现在输入评委人数和他们的打分，请输出选手的最后得分，精确到 2 位小数。",
        "function_declaration": "double calculateAverage(int n, int arr[])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main()\n{\n    int n;\n    cin >> n;\n    int arr[n];\n    for(int i = 0; i < n; ++i)\n    {\n        cin >> arr[i];\n    }\n    //calling start\n    double result = calculateAverage(n, arr);\n    //calling end\n    printf(\"%.2lf\\n\", result);\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n9 5 6 8 9\", \"output\": \"7.67\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1777,
        "problem_description": "四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多 4 个正整数的平方和。如果把 0 包括进去，就正好可以表示为 4 个数的平方和。比如：则对于一个给定的正整数 n，可以表示为：你需要求出字典序最小的一组解a、b、c、d 。字典序大小：从左到右依次比较，如果相同则比较下一项，直到有一项不同，较小的一方字典序更小，反之字典序更大，所有项均相同则二者字典序相同。",
        "function_declaration": "vector<int> findNumbers(long long N)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nlong long N;\nint a, b, c, d;\n\n// function start\n\n// function end\n\nint main(){\n    cin >> N;\n    // calling start\n    vector<int> result = findNumbers(N);\n    // calling end\n    if (!result.empty()) {\n        for (int i = 0; i < result.size(); ++i) {\n            cout << result[i] << \" \";\n        }\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"5\", \"output\": \"0 0 1 2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1730,
        "problem_description": "给出一个正整数a，要求分解成若干个正整数的积，即a=a1*a2*a3*.……*an,并且1< a1 <= a2 <= a3 <= …<=an，问这样的分解的种数有多少，注意到a=a也是一种分解。",
        "function_declaration": "int calculateDecomposition(int a)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    while(n--){\n        int a;\n        cin>>a;\n        // calling start\n        int result = calculateDecomposition(a);\n        // calling end\n        cout<<result<<endl;\n    }\n}",
        "example": "[{\"input\": \"2\\n2\\n20\", \"output\": \"1\\n4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2021,
        "problem_description": "C 国的 Dark 教授来访华了！这次，他听说你学过了循环，决定再出一道难题来考验你思考的能力。斐波那契数列，是这样的一个数列，满足其中任何一项等于前面两项的和。只需给定最前面的两项，即可确定其中任何一项。例如假设前两项为 1 和 2 ，那么这个数列将是: 1 , 2 , 3 , 5 , 8 , 13 , 21 ...为了增加点趣味性，Dark 教授增加了一个特殊的规则: 偶数项等于前两项之和加一，奇数项则和之前一样，依然等于前两项的和。例如假设前两项为 1 和 2 ，那么这个数列将是: 1 , 2 , 3 , 6 , 9 , 16 , 25 ...现在，Dark 教授要求你求出其中特定一项的值，你能完成他的挑战吗?输入三个整数，分别表示数列的前两项 a,b ，以及要求的特定一项的项数 n。保证 a,b 的绝对值不超过 int 的范围，n 不超过 10000。",
        "function_declaration": "long long calculate_sequence(long long a, long long b, long long n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    long long a,b,n;\n    cin >> a >> b >> n;\n    // calling start\n    long long result = calculate_sequence(a, b, n);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"1 2 7\", \"output\": \"25\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2185,
        "problem_description": "给定一个正整数 n，找到不小于 n 的最小质数。",
        "function_declaration": "long long findNextPrime(long long n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    long long n;\n    cin>>n;\n    // calling start\n    long long result = findNextPrime(n);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"10000\", \"output\": \"10007\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2311,
        "problem_description": "在一个社交聊天软件里，有$n$名用户，一开始，所有用户之间都不存在好友关系，接下来有$m$条关于用户的操作记录：第一种记录形式为+ x y，表示两名用户$x$与$y$结成了朋友关系；第二种记录形式为- x y，表示两名用户$x$与$y$解除了朋友关系；第三种记录形式为! x，表示用户$x$群发了一张照片，与$x$为好友的用户可以收到这张照片。若某人在照片发出后才成为$x$的好友，是收不到这张照片的。经过这些操作之后，请统计并输出每一名用户收到了多少张照片。为了化简问题，特别保证：当输入记录中出现+ x y时，$x$与$y$一定尚未结成好友关系当输入记录中出现- x y时，$x$与$y$一定已经结成好友关系也就是说，这两类记录永远不是冗余的。",
        "function_declaration": "vector<int> countPhotos(int n, vector<pair<char, pair<int, int>>>& operations)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// Function to find the number of photos received by each user\n// function start\n\n// function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<char, pair<int, int>>> operations(m);\n    for (int i = 0; i < m; i++) {\n        cin >> operations[i].first >> operations[i].second.first >> operations[i].second.second;\n    }\n\n    // Calling the function to find the number of photos received by each user\n    // calling start\n    vector<int> receivedPhotos = countPhotos(n, operations);\n    // calling end\n\n    for (int i = 0; i < n; i++) {\n        cout << receivedPhotos[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"3 5\\n+ 1 2\\n! 1\\n- 1 2\\n! 1\\n! 3\", \"output\": \"0 1 0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1785,
        "problem_description": "给你一个非负整数x (0 ≤ x ≤ 2^31 - 1)，计算并返回x的算术平方根。由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。注意：不允许使用任何内置指数函数和算符，例如pow(x, 0.5)或者x ** 0.5。",
        "function_declaration": "int mySqrt(int x)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a;\n    cin >> a;\n    // calling start\n    int result = mySqrt(a);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"x = 4\", \"output\": \"2\"}, {\"input\": \"x = 8\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1556,
        "problem_description": "输入三个整数，表示一个三角形的三条边长，请输出该三角形的类型。说明：直角三角形（含等腰直角）输出\"right\"；等腰三角形输出\"isosceles\"；等边三角形输出\"equilateral\"；没有特殊形状输出\"normal\"；若无法组成三角形则输出\"no\"。",
        "function_declaration": "void checkTriangle(int a, int b, int c)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    // calling start\n    checkTriangle(a, b, c);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"2 3 4\", \"output\": \"normal\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1908,
        "problem_description": "猴子第一天摘了若干个桃子，当即吃了一半，还不解馋，又多吃了一个；第二天，吃剩下的桃子的一半，还不过瘾，又多吃了一个；以后每天都吃前一天剩下的一半多一个，到第10天想再吃时，只剩下一个桃子了。问第一天共摘了多少个桃子？请用递归求出第一天摘的桃子数目。",
        "function_declaration": "int peachDay(int day)",
        "code_context": "#include <iostream> \nusing namespace std; \n\n//function start\n\n//function end\n\nint main(){\n    //calling start\n    cout << peachDay(1);\n    //calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"1534\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1750,
        "problem_description": "现有一个由1~N依次排列构成的数列，我们可以随意在空白处填入加号或者减号，如果不填的话两个数字就会按照前后顺序构成一个新的数字。请你找出算式结果为零的方案数量。输入一个整数N (3 ≤ N ≤ 9)。输出若干行，每行一个方案，如果不需要加符号那么必须有一个空格。如果有多个方案，那么按照'+' > '-' > ' '的顺序，字典序排序。",
        "function_declaration": "void findZeroEquation(int N)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int N;\n    cin >> N;\n    // calling start\n    findZeroEquation(N);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"7\", \"output\": \"1+2-3+4-5-6+7\\n1+2-3-4+5+6-7\\n1-2 3+4+5+6+7\\n1-2 3-4 5+6 7\\n1-2+3+4-5+6-7\\n1-2-3-4-5+6+7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2205,
        "problem_description": "IP地址是一个长度固定为 32 位 的 01 序列，给定一个IP地址，请将它转成点分十进制后输出。点分十进制的转化方法如下：首先将IP地址分割成长度相等的四个二进制数字（每个二进制数字的长度为 8），然后将这些数字用十进制表示，中间用.分割。例如某个IP地址为：11000000101010000000000101100100，那么11000000对应十进制数字为19210101000对应十进制数字为16800000001对应十进制数字为101100100对应十进制数字为100这个IP地址的点分十进制表示为192.168.1.100。",
        "function_declaration": "string binaryToDecimalIP(const string& binaryIP)",
        "code_context": "#include <iostream>\n#include <bitset>\n#include <sstream>\n#include <string>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    string binaryIP;\n    cin >> binaryIP;\n    // calling start\n    string decimalIP = binaryToDecimalIP(binaryIP);\n    // calling end\n    cout << decimalIP << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"11000000101010000000000101100100\", \"output\": \"192.168.1.100\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1968,
        "problem_description": "在学习了简单的运算符之后，相信你们已经可以学会了用计算机来做许多有用的数学运算。这次你需要判定一个一元二次方程是否有解。输入a, b , c三个整数，代表一元二次方程ax^2 +bx +c = 0，如果有两个解请返回2，如果只有一个解，请返回1，如果无解，请返回0.",
        "function_declaration": "int calculateSolutions(int a, int b, int c)",
        "code_context": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n\tint a, b, c;\n\tcin>>a>>b>>c;\n\t// calling start\n\tint result = calculateSolutions(a, b, c);\n\t// calling end\n\tif(result == 1)\n\t\tcout<<\"Only one solution\"<<endl;\n\telse if(result == 0)\n\t\tcout<<\"No solution\"<<endl;\n\telse cout<<\"Two solutions\"<<endl;\n\treturn 0;\n}",
        "example": "[{\"input\": \" 1 2 1\", \"output\": \" Only one solution\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1690,
        "problem_description": "给定整数N (1 ≤ N ≤ 10)，返回前N个大写字母的有重复全排列列表。",
        "function_declaration": "vector<string> getPermutations(int N) ",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n// function start\n\n// function end\n\nint main() {\n    int N;\n    cin >> N;\n    // calling start\n    vector<string> permutations = getPermutations(N);\n    // calling end\n    for (string permutation : permutations) {\n        cout << permutation << endl;\n    }\n}",
        "example": "[{\"input\": \"2\", \"output\": \"AA\\nAB\\nBA\\nBB\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1753,
        "problem_description": "给定一张无向图，请你从已知的起点开始，进行广度优先的方法对这张图进行遍历，对于同一节点的后继，按照标号更小的优先，请你返回遍历结果。遍历结果是若干个整数，表示搜寻的顺序，地图保证连通。",
        "function_declaration": "vector<int> bfs(vector<vector<int>>& graph, int start)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n, m, s;\n    cin>>n>>m>>s;\n    vector<vector<int>> graph(n+1);\n    for(int i=0; i<m; i++){\n        int u, v;\n        cin>>u>>v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    // calling start\n    vector<int> result = bfs(graph, s);\n    // calling end\n    for(int i=0; i<result.size(); i++){\n        cout<<result[i]<<\" \";\n    }\n}",
        "example": "[{\"input\": \"4 5 1\\n1 2\\n1 4\\n2 3\\n2 4\\n3 4\", \"output\": \"1 2 4 3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1679,
        "problem_description": "在一个有序序列（下标从1开始）中查找一个给定的值x，返回第一次出现的位置。若序列中存在x，返回x第一次出现的下标；否则返回-1。",
        "function_declaration": "int findFirstOccurrence(vector<int>& nums, int target)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n, m;\n    cin>>n>>m;\n    vector<int> nums(n);\n    for(int i=0; i<n; i++){\n        cin>>nums[i];\n    }\n    vector<int> targets(m);\n    for(int i=0; i<m; i++){\n        cin>>targets[i];\n    }\n    // calling start\n    for(int i=0; i<m; i++){\n        int result = findFirstOccurrence(nums, targets[i]);\n        cout<<result<<endl;\n    }\n    // calling end\n}",
        "example": "[{\"input\": \"5 1\\n2 3 5 6 7 \\n3\", \"output\": \"2\"}]",
        "time_limit": 5000,
        "memory_limit": 256
    },
    {
        "id": 294,
        "problem_description": "国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：WWWWWWWWWWWWWWWWWWWWWWLW在11分制下，此时比赛的结果是华华第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。而在21分制下，此时比赛结果是华华第一局21比0获胜，正在进行第二局，比分2比1。如果一局比赛刚开始，则此时比分为0比0。你的程序就是要对于一系列比赛信息的输入（WL形式），输出正确的结果。输入包含若干行字符串（每行至多20个字母），字符串有大写的W、L和E组成。其中E表示比赛信息结束，程序应该忽略E之后的所有内容。win_mark=11表示11分制，win_mark=21表示21分制。",
        "function_declaration": "void match(int win_mark, char line[2510][30], int n)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#define N 7510\nusing namespace std;\n\nint n;\nchar line[2510][30];\n\n// function start\n\n// function end\n\nint main() {\n    for (n = 0; scanf(\"%s\", line[n]) != EOF; ++n);\n    // calling start\n    match(11, line, n);\n    puts(\"\");\n    match(21, line, n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"WWWWWWWWWWWWWWWWWWWW\\nWWLWE\", \"output\": \"11:0\\n11:0\\n1:1\\n\\n21:0\\n2:1\"}]",
        "time_limit": 1000,
        "memory_limit": 125
    },
    {
        "id": 1946,
        "problem_description": "求 1+2+3+...+N 的值",
        "function_declaration": "int calculateSum(int N)",
        "code_context": "#include<cstdio>\n\n// function start\n\n// function end\n\nint main(){\n    int N;\n    scanf(\"%d\",&N);\n    \n    // calling start\n    int result = calculateSum(N);\n    // calling end\n    \n    printf(\"%d\",result);\n}",
        "example": "[{\"input\": \"3\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2085,
        "problem_description": "珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？最近老师出了一些测验题，请你帮忙求出答案。",
        "function_declaration": "int countSumEqualsTwoOthers(vector<int>& nums) ",
        "code_context": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    //calling start\n    int count = countSumEqualsTwoOthers(nums);\n    cout << count << endl;\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"4\\n1 2 3 4\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1847,
        "problem_description": "在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。共两行。输入一个整数n (1 ≤ n ≤ 10000)，表示果子的种类数。输入n个整数，第i个整数a_i (1 ≤ a_i ≤ 20000)是第i种果子的数目。对于全部的数据，保证有n < 10000。返回一个整数，也就是最小的体力耗费值。输入数据保证这个值小于2^{31}。",
        "function_declaration": "int mergeFruits(int n, vector<int>& fruits)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> fruits(n);\n    for(int i=0; i<n; i++){\n        cin>>fruits[i];\n    }\n    // calling start\n    int result = mergeFruits(n, fruits);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"3 \\n1 2 9\", \"output\": \"15\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2137,
        "problem_description": "给定 n 个非负整数（n为奇数），输出中位数（即排序后位于最中间位置的那个数）。",
        "function_declaration": "void sortAndPrintMedian(int a[], int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nint a[1000];\n\n// function start\n\n// function end\n\nint main()\n{\n    int n;\n    cin>>n;\n    for(int i=0;i<n;++i) cin>>a[i];\n    \n    // calling start\n    sortAndPrintMedian(a, n);\n    // calling end\n}",
        "example": "[{\"input\": \"5\\n3 4 7 0 7\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1825,
        "problem_description": "有一种兔子，出生后一个月就可以长大，然后再过一个月，到第3个月时就长成了老兔子，一对老兔子此时会生育一对小兔子，且以后每个月都能继续保持生育一对小兔子。每对小兔子长到第3个月也会变成老兔子生育小兔子。现在，我们有一对刚出生的这种兔子，那么到了第n个月的时候，我们会有多少对兔子呢？（假设所有的兔子都不会死亡）",
        "function_declaration": "long long fibonacci(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\nlong long a[60];\n\n// function start\n\n// function end\n\nint main() { \n    int n;\n    cin >> n;\n    // calling start\n    long long result = fibonacci(n);\n    // calling end\n    cout << result;\n    return 0; \n}",
        "example": "[{\"input\": \"5\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1999,
        "problem_description": "给定 n 个非负整数，输出最大的数",
        "function_declaration": "int findMax(int n, vector<int> arr)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int n, b;\n    cin>>n;\n    vector<int> arr(n);\n    for(int i=0; i<n; i++){\n        cin>>arr[i];\n    }\n    // calling start\n    int max = findMax(n, arr);\n    // calling end\n    cout<<max;\n}",
        "example": "[{\"input\": \"4\\n16 27 23 19 \", \"output\": \"27\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2133,
        "problem_description": "输入两个整数，交换它们的值并输出（要求实现真正的交换而不是仅仅改变输出顺序，并且使用自定义函数，即不使用std::swap或是在main函数中交换）。",
        "function_declaration": "void my_swap(int &a, int &b)",
        "code_context": "#include<iostream>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tint a, b;\n\tcin >> a >> b;\n\t// calling start\n\tmy_swap(a, b);\n\t// calling end\n\tcout << a << ' ' << b;\n}",
        "example": "[{\"input\": \"114514 1919810\", \"output\": \"1919810 114514\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2123,
        "problem_description": "输入一个整数n（n>=1），输出该层数的汉诺塔移动次数。",
        "function_declaration": "long long calculate(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    // calling start\n    long long result = calculate(n);\n    // calling end\n    cout << result;\n\n    return 0;\n}",
        "example": "[{\"input\": \"7\", \"output\": \"127\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1644,
        "problem_description": "医药公司骡德岛在进行干员招募，负责招募的刀客塔将每位干员的简历都标上了优先级，数字越大优先级也越高。可是骡德岛的需求有限，所以招募时会优先录用优先级最高的干员。你叫艾拉法雅，作为人力资源联络员的你，现在将接受刀客塔的指令，协助刀客塔完成招募工作。刀客塔只会有两种行动：递给你一份标有优先级的简历，你将这份简历放到你的办公桌上。告诉你招募一个干员，这时，你需要在你的办公桌上找到优先级最高的一份简历递出去，并且同时记录这份简历的优先级。输入一个整数m (1 ≤ m ≤ 10^5)，表示依次插入刀客塔行动的次数。读入m行，每行表示刀客塔的一次行动。若该行为1 x，则表示刀客塔递给你一份简历，并且其优先级为x。若该行为2，则表示招募干员。输出若干行，每行一个整数，表示依次递出简历的优先级。若没有简历，则输出0。",
        "function_declaration": "void manageRecruitment(int m)",
        "code_context": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n// Function to manage recruitment and resumes\n//function start\n\n//function end\n\nint main() {\n    int m;\n    cin >> m;\n\n    //calling start\n    manageRecruitment(m);\n    //calling end\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"5\\n1 1\\n1 10\\n1 2\\n2\\n2\", \"output\": \"10\\n2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1920,
        "problem_description": "给定一个数列 $a_1$, $a_2$,?,$a_n$，若有一个区间 [l,r] 满足$a_l + a_{l+1} +...+ a_{r-1} + a_r$ 为 k 的倍数，则称 [l,r] 为 k 的倍数区间 。给定k，请统计在给定的数列中，有多少个区间是 k 的倍数区间。对于 30%的数据，n ≤ 200； 对于 60%的数据，n ≤ 5000； 对于 100%的数据，1 ≤ n ≤ 200000；  1 ≤ k ≤ 100000，0 ≤ $a_i$≤10000。",
        "function_declaration": "long long calculate_ans(int n, int k, int t[]) ",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint cnt[100010];\n\n// function start\n\n// function end\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    int t[n+1];\n    for (int i = 0; i < n; i++) {\n        cin >> t[i];\n    }\n    // calling start\n    long long ans = calculate_ans(n, k, t);\n    // calling end\n    cout << ans << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"4 20\\n30 20 40 10\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2343,
        "problem_description": "Dark 教授听说你学会了字符串，她决定出一道题来考察你的掌握程度。现在你面前有一串随机字符串，其中有一些数字串，表示一个正整数(即不用处理负号)。你需要把这些数字逐一输出，最后输出删除了所有数字串之后的字符串。输出格式为每行一个正整数，对应原始字符串中的每个数字。最后输出删除了所有数字串之后的字符串。",
        "function_declaration": "void processStr(char* str)",
        "code_context": "#include <iostream>\n#include <cstring>\nusing namespace std;\nconst int N = 1024;\nchar str[N];\n\n// function start\n\n// function end\n\nsigned main() {\n    scanf(\"%s\",str);\n    // calling start\n    processStr(str);\n    // calling end\n    puts(str);\n    return 0;\n}",
        "example": "[{\"input\": \"1DarkSharpness123.github456.io789\\n\", \"output\": \"1\\n123\\n456\\n789\\nDarkSharpness.github.io\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2314,
        "problem_description": "给定一个整数 $n$，请统计从 1 开始，到 $n$ 为止的所有整数的十进制表示中，一共出现了多少个 0？例如 n=100 时，1 到 100 中，只有以下数字出现过 0：$$10, 20, 30, 40, 50, 60, 70, 80, 90, 100$$所以总计出现 11 次。",
        "function_declaration": "long long calculateSum(long long n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n\tlong long n;\n\tcin >> n;\n\t// calling start\n\tlong long result = calculateSum(n);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"100\", \"output\": \"11\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2247,
        "problem_description": "扫雷是一款经典的休闲小游戏。游戏规则很简单：棋盘上有许多方格，方格中随机分布着一些雷。你的目标是避开雷，打开其他所有格子。一个非雷格中的数字表示其相邻8格中的雷数，你可以利用这个信息推导出安全格和雷的位置。你可以用右键在你认为是雷的地方插旗。你可以用左键打开安全的格子，左键打开雷将被判定为失败。当全部安全的格子都被打开时，游戏胜利。现在给定棋盘的大小以及所有雷的位置，请你画出游戏胜利时的棋盘，输出 n 行 m 列（n 行，每行输出 m 个字符然后换行），表示游戏胜利时的棋盘。对于每个位置，如果该位置是雷，输出大写字母 P，否则输出 0 到 8 之间的一个数，表示相邻8格中的雷数。",
        "function_declaration": "void processGrid(int n, int m, bool s[110][110])",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\nbool s[110][110];\n\n// function start\n\n// function end\n\nint main(){\n    int n,m,k,x,y;\n    cin>>n>>m>>k;\n    while(k--) cin>>x>>y, s[x][y]=true;\n\n    // calling start\n    processGrid(n, m, s);\n    // calling end\n}",
        "example": "[{\"input\": \"5 8 3\\n1 3\\n2 3\\n3 5\", \"output\": \"02P20000\\n02P31100\\n0112P100\\n00011100\\n00000000\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1975,
        "problem_description": "凯撒密码是一种最简单且最广为人知的加密技术，它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。特别地，我们规定Z（或z）的后一个字母是A（或a），A（或a）的前一个字母为Z（或z），且大写字母被替换成大写字母，小写字母为替换为小写字母。例如，当偏移量是3的时候，所有的字母A将被替换成D，B将被替换成E，z将被替换成c，以此类推。这种加密方式最早由古罗马军事统帅盖乌斯·尤利乌斯·凯撒在军队中用来传递加密信息，故称凯撒密码。在本题中，你需要实现一个凯撒密码翻译器，即给定密文和偏移量，翻译出明文。输入包含一个字母c（大写或小写），表示密文。一个整数x，表示明文替换为密文的偏移量。x为正时表示向后偏移，偏移量为x；x为负时表示向前偏移，偏移量为-x。",
        "function_declaration": "int calculatePosition(char c, int x)",
        "code_context": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nchar c;\nint x;\n\n// function start\n\n// function end\n\nint main()\n{\n\tcin >> c >> x;\n\t// calling start\n\tchar result = calculatePosition(c, x);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"a\\n2\", \"output\": \"y\"}, {\"input\": \"K\\n-1000\", \"output\": \"W\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1850,
        "problem_description": "一个由数对组成的序列，每组数对两个整数Ai Bi，Ai表示该组数对的权重，Bi表示该组数对的值。现在我们要在权重不变的情况下，重新计算每一组的值，其计算规则如下：对于每个数对，自身的初始值Bi将累加到两侧第一个权重比他高的数对（可能两侧都存在比自身权重高的数对，可能仅有一侧有，也可能没有权重更高的数对），并清除自身的初始值Bi。根据上述规则，请你求出重新计算后，数对中最高的值是多少。",
        "function_declaration": "int getMaxValue(vector<pair<int, int>>& pairs)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> pairs(n);\n\n    // Input weight-value pairs\n    for (int i = 0; i < n; i++) {\n        cin >> pairs[i].first >> pairs[i].second;\n    }\n\n    //calling start\n    int maxVal = getMaxValue(pairs);\n    //calling end\n\n    cout << maxVal << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"3\\n10 1\\n1 5\\n2 5\", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2019,
        "problem_description": "计算出 S = 1! + 2! + 3! + ... + n!（n <= 20）。其中 `!` 表示阶乘，定义为 n!=n * (n-1) * (n-2) * ... * 1。例如，5! = 5 * 4 * 3 * 2 * 1=120。",
        "function_declaration": "long long calculateSum(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\t// calling start\n\tlong long result = calculateSum(n);\n\t// calling end\n\tcout << result;\n\treturn 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"9\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1589,
        "problem_description": "给定一个长度为N的数列，先将输入的一系列整数中的最小值与第一个数交换，然后将最大值与最后一个数交换，最后输出交换后的序列。（保证最大和最小值都是唯一的。）在一行中顺序输出交换后的序列，每个整数后跟一个空格。",
        "function_declaration": "void swapMinMax(int n, int nums[])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    int nums[1001];\n    \n    cin >> n;\n    for (int i=0; i<n; i++)\n        cin >> nums[i];\n    \n    // calling start\n    swapMinMax(n, nums);\n    // calling end\n    \n    return 0;\n}",
        "example": "[{\"input\": \"5\\n8 2 5 1 4\", \"output\": \"1 2 5 4 8\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1897,
        "problem_description": "小博准备开始存钱啦。他准备定个小目标，先存5天！小博有个存钱罐，里面一开始是空的，第1天投1元，第2天投2元，第3天投3元……请输出前5天每天存钱罐里分别有多少钱，输出多行，每行一个整数表示当天存钱罐里的钱。",
        "function_declaration": "void calculateSavings()",
        "code_context": "#include <iostream>\n\n//function start\n\n//function end\n\nint main() {\n    //calling start\n    calculateSavings();\n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \" \", \"output\": \"1\\n3\\n6\\n10\\n15\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1747,
        "problem_description": "现有一个等式：S = a0 + a1 + a2 + ... + an (n ≥ 1)，其中满足a1 = k1 * a0, a2 = k2 * a1, ..., an = kn * a[n-1]  (2 ≤ k ≤ 7)以此类推。现在给定S，请你自由决定a0和所有k的值，使得上述等式成立并且n尽可能的小。输入一个整数S (10 ≤ S ≤ 10^8)。输出一个整数，表示最小的n；若无法找到，返回-1。",
        "function_declaration": "int calculateN(int S)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int S;\n    cin>>S;\n    // calling start\n    int result = calculateN(S);\n    // calling end\n    if(result == -1){\n        cout<<\"Tomimi\";\n    }else{\n        cout<<result;\n    }\n}",
        "example": "[{\"input\": \"10\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2082,
        "problem_description": "通常，人们习惯将所有 $n$ 位二进制串按照字典序排列，例如所有 2 位二进制串按字典序从小到大排列为：00，01，10，11。格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间**恰好**有一位**不同**，特别地，第一个串与最后一个串也算作相邻。所有 2 位二进制串按格雷码排列的一个例子为：00，01，11，10。$n$ 位格雷码不止一种，下面给出其中一种格雷码的生成算法：1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \\sim 2^n - 1$ 编号。按该算法，2 位格雷码可以这样推出：1. 已知 1 位格雷码为 0，1。2. 前两个格雷码为 00，01。后两个格雷码为 11，10。合并得到 00，01，11，10，编号依次为 0 ~ 3。同理，3 位格雷码可以这样推出：1. 已知 2 位格雷码为：00，01，11，10。2. 前四个格雷码为：000，001，011，010。后四个格雷码为：110，111，101，100。合并得到：000，001，011，010，110，111，101，100，编号依次为 0 ~ 7。现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的 $k$ 号二进制串并输出。",
        "function_declaration": "void dg(int n, unsigned long long k)",
        "code_context": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nint n;\nunsigned long long k, pow2[65];\n\n// function start\n\n// function end\n\nint main()\n{\n pow2[0] = 1;\n for (int i = 1; i <= 64; ++i) pow2[i] = pow2[i-1] * 2;\n cin >> n >> k;\n // calling start\n dg(n, k);\n // calling end\n}",
        "example": "[{\"input\": \"2 3\", \"output\": \"10\"}, {\"input\": \"3 5\", \"output\": \"111\"}, {\"input\": \"44 1145141919810\", \"output\": \"00011000111111010000001001001000000001100011\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2315,
        "problem_description": "给定一个序列 $a_1,…,a_n$，小爱可以修改这个序列，每步修改只能修改一个数字，且只能将这个数字增加一个单位或减少一个单位。请问，最少需要几步修改，才能将序列调整成一个上升且连续的整数序列。所谓上升且连续，就是指每一个数字恰好比前一个数大 1。",
        "function_declaration": "long long calculateCost(long long a[], int n)",
        "code_context": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    long long a[500000];\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    // calling start\n    long long cost = calculateCost(a, n);\n    // calling end\n    cout << cost;\n}",
        "example": "[{\"input\": \"5\\n2 3 3 3 3\", \"output\": \"5\"}, {\"input\": \"5\\n-3 3 0 2 4\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2106,
        "problem_description": "卡特兰数是组合数学中一种常出现于各种计数问题中的数列，又称卡塔兰数、明安图数。它以比利时的数学家欧仁·查理·卡特兰（1814–1894）命名。历史上，清朝数学家明安图（1692年－1763年）在其《割圜密率捷法》中最先发明这种计数方式，远远早于卡特兰。比如，我们有以下问题：> 有 2n 个人排成一行进入剧场。入场费 5 元。其中只有 n 个人有一张 5 元钞票，另外 n 人只有 10 元钞票，剧院无其它钞票，问有多少种方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？其答案序列 $H_n$ 就是卡特兰数。卡特兰数的前几项为 $H_0=1,H_1=1,H_2=2,H_3=5,H_4=14,H_5=42$。计算卡特兰数的一种方法如下：$H_n=\\sum_{i=1}^{n}H_{i-1}H_{n-i}$，即 $H_n=H_0*H_{n-1}+H_1*H_{n-1}+\\cdots+H_{n-1}*H_0$；如 $H_4$ 的计算方法为 $H_4=H_0*H_3+H_1*H_2+H_2*H_1+H_3*H_0=1*5+1*2+2*1+5*1=14$。现在请你求出卡特兰数的第 $n$ 项，即 $H_n$。由于 $H_n$ 的值可能很大，**你只需要输出它模 $998244353$ 的结果**。",
        "function_declaration": "long long calculate_h(int n)",
        "code_context": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst long long mod = 998244353;\n\nint n;\nlong long h[3010];\n\n// function start\n\n// function end\n\nint main(){\n    cin >> n;\n    // calling start\n    long long result = calculate_h(n);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"6\", \"output\": \"132\"}, {\"input\": \"1000\", \"output\": \"346517073\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2084,
        "problem_description": "某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,...,l$，都种有一棵树。由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。输入有分别表示马路的长度 $l$ 和区域的数目 $m$和表示一个区域的起始点和终止点的坐标数组a 和 b，输出一个整数，表示将这些树都移走后，马路上剩余的树木数量。",
        "function_declaration": "int calculate(int l, int m, int a[], int b[])",
        "code_context": "#include<iostream>\nusing namespace std;\nint x[10001];\n\n// function start\n\n// function end\n\nint main(){\n    int n,a[10001],b[10001],l,m,s=0;\n    cin>>l>>m;\n    for(int z=1;z<=m;z++){\n        cin>>a[z]>>b[z];\n    }\n    // calling start\n    s = calculate(l, m, a, b);\n    // calling end\n    cout<<s;\n}",
        "example": "[{\"input\": \"500 3\\n150 300\\n100 200\\n470 471\", \"output\": \"298\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1861,
        "problem_description": "竞选班长的条件是：语文、数学、英语三门成绩中，至少两门大于或等于90分，而且思想品德不能低于85分。给定小爱的语文、数学、英语和思想品德成绩，请问她能否竞选班长？?整数a表示语文成绩；整数b表示数学成绩；整数c表示英语成绩；整数d表示思想品德成绩。如果可以竞选班长，输出Qualified；否则，输出Not qualified。",
        "function_declaration": "string qualification(int a, int b, int c, int d)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n    // calling start\n    string result = qualification(a, b, c, d);\n    // calling end\n    cout << result << \"\\n\";\n    return 0;\n}",
        "example": "[{\"input\": \"91\\n96\\n99\\n89\", \"output\": \"Qualified\"}, {\"input\": \"84\\n91\\n85\\n95\", \"output\": \"Not qualified\"}, {\"input\": \"94\\n98\\n97\\n80\", \"output\": \"Not qualified\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2211,
        "problem_description": "小爱正在编写一个扫雷游戏的出题模块。这个模块的输入是一张地图，标记了每个地雷的位置，地雷以*表示，空地以.表示。这个模块的输出是一个表格，统计了每个空地周围八个方格内的地雷数量。例如，给定一个初始地图：*.*\n...\n*..\n则应输出：*2*\n231\n*10\n请你帮助小爱来完成这个程序，输入为 $n×m$ 个字符表示的地图，输出 $n×m$ 个字符，表示每个方格周围地雷统计信息，若原本这个位置就有地雷，输出* ,  否则输出周围8个方格中的地雷数目。",
        "function_declaration": "void processGrid(int n, int m, char a[100][100])",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    char a[100][100];\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j) \n            cin >> a[i][j];\n\n    // calling start\n    processGrid(n, m, a);\n    // calling end\n}",
        "example": "[{\"input\": \"3 4\\n*..*\\n.**.\\n.*.*\", \"output\": \"*33*\\n3**3\\n2*4*\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1569,
        "problem_description": "输入n个学生的信息，包括姓名、性别、年龄，再输出其中年龄最大的学生的信息。（保证最大年龄不重复）1 <= n <= 10。 姓名长度小于等于20性别为M或F，输入第一行一个整数n，接下来n行，依次是学生的姓名、性别、年龄。输出一行，依次是姓名、性别、年龄，中间用空格隔开。",
        "function_declaration": "void findOldestStudent(int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    // calling start\n    findOldestStudent(n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"2\\nKal'tsit F 1000\\nAmiya F 14\", \"output\": \"Kal'tsit F 1000\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2222,
        "problem_description": "如果一个十进制整数能够被它的每一个非零数码整除，则称它为巧妙的数，譬如102是一个巧妙的数，因为102能被1与2整除，而2021不是，因为它不能被2整除。给定一个 $n$，请判定它是否为巧妙的数。",
        "function_declaration": "bool isCleverNumber(int n)",
        "code_context": "#include <iostream>\n#include <string>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    //calling start\n    bool clever=isCleverNumber(n);\n    //calling end\n    if (clever)\n   cout << \"clever\";\n else\n   cout << \"not clever\";\n}",
        "example": "[{\"input\": \"102\", \"output\": \"clever\"}, {\"input\": \"2050\", \"output\": \"clever\"}, {\"input\": \"13\", \"output\": \"not clever\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1774,
        "problem_description": "已知一个长度为n的数列，现在需要按照以下规则将其重新排列。奇数排在偶数的前面；奇数按照由小到大的顺序排列；偶数按照由大到小的顺序排列。请你返回重新排列后的数组。",
        "function_declaration": "void sortArray(int a[], int n)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, a[100010];\n\n// function start\n\n\n// function end\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    // calling start\n    sortArray(a, n);\n    // calling end\n    for (int i = 0; i < n; i++)\n        cout << a[i] << ' ';\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 2 3 4 5\", \"output\": \"1 3 5 4 2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1755,
        "problem_description": "给定n个整数，从小到大输入，统计数x在该数组中出现的次数。",
        "function_declaration": "int countX(int a[], int n, int x)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define N 1000005\nusing namespace std;\nint a[N]; \n\n//function start\n\n//function end\n\nint main() {\n    int n, x, cnt;\n    cin >> n >> x;\n    for (int i = 0; i < n; ++i) \n        cin >> a[i];\n    //calling start\n    cnt = countX(a, n, x);\n    //calling end\n    cout << cnt;\n    \n    return 0;\n}",
        "example": "[{\"input\": \"1?0 2\\n1 2 2 2 3 5 7 7 10 20\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2303,
        "problem_description": "给定一个十进制正整数 $n$，请问可以从 $n$ 中截取多少种不同的子串，使得子串构成的数字是 $3$ 的倍数。例如：当 $n=1234$ 时，有且仅有 $3，12，123，234$ 这四个子串是 $3$ 的倍数。",
        "function_declaration": "int countSubstringsDivisibleBy3(int n)",
        "code_context": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\n// Function to count the number of substrings divisible by 3\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    // Calling the function to count the number of substrings divisible by 3\n    //calling start\n    int result = countSubstringsDivisibleBy3(n);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"95764\", \"output\": \"6\"}, {\"input\": \"1111\", \"output\": \"2\"}]",
        "time_limit": 4000,
        "memory_limit": 256
    },
    {
        "id": 2168,
        "problem_description": "给定正整数$s$和$t$，我们希望利用增长与翻倍的操作，让$s$变成$t$。一步增长可以让数字加一，一步翻倍可以让数字翻倍。最少需要用多少步操作才能将$s$变成$t$？，保证$s<t$。",
        "function_declaration": "int calculateSteps(int s, int t)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int s, t;\n    cin >> s >> t;\n    // calling start\n    int result = calculateSteps(s, t);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"1 4\", \"output\": \"2\"}, {\"input\": \"2 10\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1692,
        "problem_description": "一个特别的单行街道在每公里处有一个汽车站。顾客根据他们乘坐汽车的公里数来付费。每辆汽车仅会行驶整数的公里数且最大不会超过10，行驶不同的公里数所需的金额也不同（注意这些金额并无实际的经济意义，即行驶10公里费用可能比行驶一公里少）。现在阿晓打算坐车行驶n公里，当然，可以随意通过无限次的换车来完成旅程，请你帮助算出完成旅程最少的费用。",
        "function_declaration": "int calculateMinCost(int n)",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[20], f[101];\n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin >> n;\n    // calling start\n    int result = calculateMinCost(n);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"12 21 31 40 49 58 69 79 90 101\\n15\", \"output\": \"147\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1829,
        "problem_description": "在阿晓新开业的餐厅里，有n位顾客在一个等待他们美味的晚餐，其中，每个人点的菜的烹饪时间是不同的，但是阿晓可以决定先做谁的晚餐，请你帮她找出一个合理的烹饪顺序，能够使所有顾客的总等待时间最短，并求出这个最短时间。一个顾客的等待时间是从最开始到他的晚餐烹饪完毕。",
        "function_declaration": "long long calculateSum(long long n, long long a[])",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, ans, a[100010];\n\n// function start\n\n// function end\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    // calling start\n    ans = calculateSum(n, a);\n    // calling end\n    cout << ans << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n100 1 2\", \"output\": \"107\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1751,
        "problem_description": "网格图上，给定目标点(a, b)，随后我们从(1, 1)出发，每次可以走田字或日字，最少几次可以到达目标点位。",
        "function_declaration": "int calculate(int a, int b)",
        "code_context": "#include <bits/stdc++.h>\n#define N 1010\nusing namespace std;\n\nint vis[N][N], movx[12] = {-2, -2, -1, -1, 1, 1, 2, 2, -2, -2, 2, 2}, movy[12] = {1, -1, 2, -2, 2, -2, 1, -1, 2, -2, 2, -2};\nqueue<int> x, y;\n\n//function start\n\n//function end\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n    //calling start\n    int result = calculate(a, b);\n    //calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"12 16\", \"output\": \"8\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2318,
        "problem_description": "给定 $n$ 个数轴上的闭区间，请统计有多少对区间的交集不是空集。",
        "function_declaration": "int countIntersections(int n, vector<pair<int, int>>& intervals)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to count the number of non-empty intersections between intervals\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<pair<int, int>> intervals(n);\n    for (int i = 0; i < n; i++) {\n        cin >> intervals[i].first >> intervals[i].second;\n    }\n\n    // Calling the function to count the number of non-empty intersections between intervals\n    //calling start\n    int result = countIntersections(n, intervals);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"3\\n1 10\\n1 4 \\n5 12\", \"output\": \"2\"}, {\"input\": \"2\\n1 2\\n2 3\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1928,
        "problem_description": "小爱有 n 只苹果，每只苹果都有各自的保质期，第 i  只的保质期为 $ a_i $，若  $ a_i $ =0 意味着它必须在当天吃掉，不然就变质了，若  $ a_i $ >0 意味着它可以保存  $ a_i $ 天，超过这个期限就会变质。小爱每天最多只能吃一只苹果，她应该如何安排吃苹果的顺序，才能吃到最多的苹果？对于 30% 的数据，1 ≤n≤ 10；对于 60% 的数据，1 ≤n≤ 1,000；对于 100% 的数据，1 ≤n≤ 1,000,000，0 ≤ $ a_i $ <n。",
        "function_declaration": "int calculateDays(int n, int apples[])",
        "code_context": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n, apples[1000010];\n\n// function start\n\n// function end\n\nint main()\n{\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> apples[i];\n    }\n    \n    // calling start\n    int result = calculateDays(n, apples);\n    // calling end\n\n    cout << result;\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n4 1 0 2 1\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1592,
        "problem_description": "给定1个整数，求出它的阶乘。",
        "function_declaration": "long long factorial(int num)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, num;\n    cin >> n;\n    \n    // calling start\n    for (int i=0; i<n; i++) {\n        cin >> num;\n        cout << factorial(num) << endl;\n    }\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"2\\n2\\n3\", \"output\": \"2\\n6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2346,
        "problem_description": "这一天，小万学到了unix系统中，软件接受参数的常见格式：program -a AAAA -d EEEE -b BBBB\n这是一条命令，表示调用名为program的程序，并且设置了三个选项。选项-a的值为AAAA，选项-b的值为BBBB，选项-d的值为EEEE。为了简化，选项-x中的x是一个小写英文字母，且不会重复出现。选项的值只包含可见字符。命令可以没有选项。选项名与选项的值之间只有一个空格。小橙请小万模仿计算机。小橙会丢给小万一条命令，小万负责解析这条命令，并分别将程序名、选项值告诉小橙，请输出若干行。第一行为程序名。以下每一行先输出选项名，然后是选项的值，中间用空格隔开。选项名需要升序排序。",
        "function_declaration": "void parseCommand(const string& command) ",
        "code_context": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    string command;\n    getline(cin, command);\n\n    //calling start\n    parseCommand(command);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"add_user -u Xiao-Cheng -c Xiao-Wan\\n\", \"output\": \"add_user\\n-c Xiao-Wan\\n-u Xiao-Cheng\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2061,
        "problem_description": "近年来，外卖骑手的生存状态和劳动权益保障情况，引起了全国人大代表、广西林业集团有限公司副总经理黄超的关注。黄超代表认为，外卖骑手之所以超负荷工作，每天让自己这么劳累，主要的原因是现在外卖单子的价格还不错，才导致了外卖骑手不顾身体劳累，也要多跑单多赚钱。所以在刚刚结束的全国两会上，黄超代表给出了下面的提案：当外卖骑手跑到了相应的单子后，就把单子的价格降下来。这样外卖骑手就会觉得，再花费时间去跑单，也得不到多少利益，干脆就不跑了。这样就能从根本上解决外卖骑手超负荷工作的问题。小A是一个外卖骑手，每个月为了维持家里日常开支他需要挣到 m 元钱。骑手送一单外卖可以挣 a 元。如果黄超代表的提案通过，那么骑手将在送了 b 单后，之后送的每一单只能挣 c 元（c<a）。小A看到黄超代表的提案后非常感动，心想终于有人代表自己发声了。小A想请你帮他算算，如果采纳黄超代表的提案，自己每个月可以减少多少工作量（即每月可以少送多少单）？输入包含四个正整数 m，a，b，c。对于 100% 的数据，$m,a,b,c \\le 10^9$，输出一个整数，表示小A每个月比原来可以少送多少单。",
        "function_declaration": "long long calculateResult(long long m, long long a, long long b, long long c)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    long long m, a, b, c;\n    cin >> m >> a >> b >> c;\n    // calling start\n    long long result = calculateResult(m, a, b, c);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"10000 7 1000 5\", \"output\": \"-171\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1591,
        "problem_description": "将一个给定的整数x插到原本有序的整数序列nums中，使结果序列仍然有序。",
        "function_declaration": "void insertNum(int n, int x, int nums[])",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, x;\n    int nums[1001];\n    \n    cin >> n;\n    for (int i=0; i<n; i++)\n        cin >> nums[i];\n    cin >> x;\n    \n    // calling start\n    insertNum(n, x, nums);\n    // calling end\n    \n    for (int i=0; i<(n+1); i++)\n        cout << nums[i] << \" \";\n    \n    return 0;\n}",
        "example": "[{\"input\": \"3\\n1 3 4\\n2\", \"output\": \"1 2 3 4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1894,
        "problem_description": "打印出1～10之间的所有偶数（包含1和10），用空格隔开。输入：无输出：2 4 6 8 10",
        "function_declaration": "void printEvenNumbers()",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    // calling start\n    printEvenNumbers();\n    // calling end\n}",
        "example": "[{\"input\": \" \", \"output\": \"2 4 6 8 10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2138,
        "problem_description": "一个班级里，男生比女生多$a$人，当男生和女生同时调走 $b$个人后，男生数量是女生的两倍，问原来男生女生各有多少人？输出第一行：一个整数，表示原来有多少男生；第二行：一个整数，表示原来有多少女生。",
        "function_declaration": "void findOriginalNumbers(int a, int b)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// Function to find the original numbers of boys and girls in the class\n//function start\n\n//function end\n\nint main() {\n    int a, b;\n    cin >> a >> b;\n\n    // Call the function to find the original numbers of boys and girls\n    //calling start\n    findOriginalNumbers(a, b);\n    //calling end\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"1\\n1\", \"output\": \"3\\n2\"}, {\"input\": \"7\\n5\", \"output\": \"19\\n12\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2184,
        "problem_description": "给定一个非负整数 a，判断 a 是否是 9 的倍数。",
        "function_declaration": "bool isDivisibleByNine(string a)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        string a;\n        cin >> a;\n        // calling start\n        bool result = isDivisibleByNine(a);\n        // calling end\n        cout << (result ? \"Yes\" : \"No\") << endl;\n    }\n}",
        "example": "[{\"input\": \"3\\n0\\n1000000000000\\n999999999999999999999999999999999999999\", \"output\": \"Yes\\nNo\\nYes\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2103,
        "problem_description": "Darksharpless 在学会循环结构后，便在 Hastin 面前一展神通。他能够用他的代码轻松地将一个数 n 分解成它的所有质因数。Hastin 看到之后非常羡慕，你能帮帮他吗？输出一行若干个数，为 n 分解质因数后的所有质数（从小到大排列，用空格分开）。",
        "function_declaration": "void primeFactors(int &n)",
        "code_context": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n = 0;\n    cin >> n;\n    // calling start\n    primeFactors(n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"60\", \"output\": \"2 2 3 5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2057,
        "problem_description": "快要开学了，Dark 教授决定到小朋友们家去家访。现在，她已经知道了 小朋友们的住址 和 自己住址 的距离。为了合理的安排路线、规划时间，她需要知道这些距离中最远的两个，最近的两个，以及距离的总和。简单来说，她会给你一些数字，你需要求出里面最大的两个，最小的两个，以及所有数字的和。输出第一行两个数，分别是 最远的距离 和 第二远的距离，中间用空格隔开。第二行两个数，分别是 最近的距离 和 第二近的距离，中间用空格隔开。第三行一个数，表示距离的总和。",
        "function_declaration": "void calculateDistances(const vector<int>& distances)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> distances(n);\n    for (int i = 0; i < n; i++) {\n        cin >> distances[i];\n    }\n\n    //calling start\n    calculateDistances(distances);\n    //calling end\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 2 3 5 5\", \"output\": \"5 5\\n1 2\\n16\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1867,
        "problem_description": "一只青蛙一次可以跳上1级台阶，也可以跳上2级。输入整数n，求该青蛙跳上一个n级的台阶总共有多少种跳法。",
        "function_declaration": "int fun(int n)",
        "code_context": "#include <iostream>  \nusing namespace std; \n\n// function start\n\n// function end\n\nint main(){\n    int n;\n    cin >> n;\n    // calling start\n    cout << fun(n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2289,
        "problem_description": "有一家牧场每天都会产出牛奶，在第 $i$ 天，牛奶的产量为 $p_i$。生产的牛奶可以卖到市场上，在第 $i$ 天，市场需求为 $c_i$。如果市场需求不大，卖不掉牛奶，则多余的牛奶就会放进冷库保存。牛奶有一个保鲜期，如果超过了 $m$ 天 （$m$ 为一个给定的整数），就必须倒掉了。卖牛奶时，应先卖冷藏时间长的。给定天数 $n$ 以及每天的产量和收购量，请求出牧场一共可以卖出多少牛奶。",
        "function_declaration": "int calculate(int n, int m, int arr[][2])",
        "code_context": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 100000;\nint q[maxn]; \n\n// function start\n\n// function end\n\nint main() \n{\n    int n, m;\n    cin >> n >> m;\n    int arr[n][2];\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i][0] >> arr[i][1];\n    }\n    // calling start\n    int result = calculate(n, m, arr);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"5 2\\n50 0\\n100 0\\n250 0\\n300 0\\n1000 5000\", \"output\": \"1550\"}, {\"input\": \"5 5\\n0 2\\n2 3\\n5 0\\n3 0\\n2 0\", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1926,
        "problem_description": "在一个国家的各个城市之间，需要进行粮食的运输。给定一个整数n，表示这个国家的城市数量。再给定一列整数$a_1$, $a_2$,?,$a_n$，表示每个城市生产或者消费粮食的数量：正数表示对应的城市是生产粮食的，其绝对值代表该城市的粮食生产量；负数表示对应的城市是消费粮食的，其绝对值代表该城市的粮食消费量。输入数据保证生产总量和消费总量是相等的，这个国家的城市之间的公路网络是一条直线。只有编号相邻的城市之间是存在道路可以通行的，搬运一个单位的粮食到某一个相邻的城市，需要一个单位的工作量，若想将3个单位的粮食从4号城市搬运到6号城市，需要3×(6-4) = 6个单位的工作量。请设计一个方案，使得所有消费城市的需要能得到满足，且搬运的总工作量达到最小，返回最优运输方案产生的最少工作总量。。100,000 ≤ $a_i$ ≤ 100,000； 对于30%的数据，1 ≤ n ≤ 10； 对于60%的数据，1 ≤ n ≤ 100； 对于100%的数据，1 ≤ n ≤ 100,000。",
        "function_declaration": "long long findMinWork(int n, vector<int>& cities)",
        "code_context": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> cities(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> cities[i];\n    }\n    //calling start\n    long long result = findMinWork(n, cities);\n    //calling end\n    cout << result << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"4\\n-10 10 20 -20\", \"output\": \"30\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1903,
        "problem_description": "检查用户输入的用户名和密码的长度限制是否在6～16之间。",
        "function_declaration": "bool checkLength(char userName[], char passWord[])",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  char userName[30];\n  char passWord[30];\n\n  printf (\"请输入你的用户名\\n\");\n  scanf (\"%s\", userName);\n  printf (\"请输入你的密码\\n\");\n  scanf (\"%s\", passWord);\n\n  // calling start\n  if(!checkLength(userName, passWord)) {\n    printf (\"用户名或密码长度必须在6～16之间\");\n  }\n  // calling end\n  return 0;\n}",
        "example": "[{\"input\": \"Akatsuki\\n123456789\", \"output\": \"请输入你的用户名\\n请输入你的密码\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2207,
        "problem_description": "2017年起，上海高考正式从3+1模式，改变为3+3模式，即语文、数学、外语三门科目必考，物理、化学、生物、历史、地理、政治这6门科目中任意选择三门考试，不再区分文理科。即将面临选科的小爱收到了最近一次考试的成绩，并以此为依据进行选科。已知小爱物理、化学、生物、历史、地理、政治成绩分别为$a$分，$b$分，$c$分，$d$分，$e$分，$f$分。请问按此成绩，小爱选择高考三门科目所能得到的最高分为多少分？",
        "function_declaration": "int getMaxTotalScore(int a, int b, int c, int d, int e, int f)",
        "code_context": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n//function start\n//function end\n\nint main() {\n    int a, b, c, d, e, f;\n    cin >> a >> b >> c >> d >> e >> f;\n    //calling start\n    int maxTotalScore = getMaxTotalScore(a, b, c, d, e, f);\n    //calling end\n    cout<<maxTotalScore;\n    return 0;\n}",
        "example": "[{\"input\": \"90 88 85 93 75 87\", \"output\": \"271\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 256,
        "problem_description": "在我们参加的各种竞赛中，允许并列的排名方式是经常遇到的。 例如有四名选手的成绩分别为50、80、50、30分，则80分的选手为第一名，50分的两名选手均为第二名，30分的选手为第四名。 请编写一个程序，计算一个选手在这种排名方式之下的名次（分数高的选手排前面）。一个整数n，表示参赛的选手数。n个整数，表示每位选手的成绩，一个整数x ，表示要查询名次的选手的成绩。",
        "function_declaration": "int count_greater(int n, int a[], int x)",
        "code_context": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main () {\n    int n = 0;\n    int a[105] = {0};\n    cin >> n;\n    for (int i = 1; i <= n; ++i) cin >>a[i];\n    int x = 0;\n    cin >> x;\n    // calling start\n    int result = count_greater(n, a, x);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"4\\n50 80 50 30\\n50\", \"output\": \"2\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 128
    },
    {
        "id": 2165,
        "problem_description": "如果一个偶数位的十进制数字是一个回文，则称它为偶位回文数。例如：1221是一个偶位回文数，而121和1234都不是，因为前者是回文但不是偶位，后者是偶位但不是回文。给定一个整数$n$，请找出正整数中前$n$个偶位回文数，计算并输出它们的和。",
        "function_declaration": "long long calculateSum(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\t// calling start\n\tlong long result = calculateSum(n);\n\t// calling end\n\tcout << result;\n}",
        "example": "[{\"input\": \"2\", \"output\": \"33\"}, {\"input\": \"5\", \"output\": \"165\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1985,
        "problem_description": "公元60年，古希腊的数学家海伦发现了一个可以求三角形面积的公式，假设一个三角形的三边长分别为 $a, b, c$, 则三角形的面积 $A$可由以下公式求得：$$A =\\sqrt{s(s-a)(s-b)(s-c)}$$其中， $s =\\frac{a + b + c}{2}$海伦公式与我国南宋末年的数学家秦九韶发现的公式等价，公式如下：$$A =\\sqrt{\\frac{1}{4}[a^2c^2- (\\frac{a^2+ c^2- b^2}{2})^2]}$$其中， $a\\geqb\\geqc$下面博小鱼将给你某个三角形的三边长$a, b, c$, 你需要计算出这个三角形的面积并输出（四舍五入精确到1位小数）。",
        "function_declaration": "double calculateArea(double a, double b, double c)",
        "code_context": "#include <iostream>\n#include <cmath>\nusing namespace std;\ndouble a, b, c, p, ans;\n\n//function start\n\n//function end\n\nint main(){\n    //freopen(\"5.in\", \"r\", stdin);\n    //freopen(\"5.out\", \"w\", stdout);\n    cin >> a >> b >> c;\n    //calling start\n    ans = calculateArea(a, b, c);\n    //calling end\n    printf(\"%.1lf\", ans);\n    return 0;\n}",
        "example": "[{\"input\": \"3 4 5\", \"output\": \"6.0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1590,
        "problem_description": "从输入的N个整数中查找给定的X。如果找到，输出X第一次出现的位置（从1开始计数）； 输入为一个正整数N（≤100），表示一共有N整数。给出N个整数。数字均不超过长整型，输入一个整数，表示待查找的整数X。 输出为若找到则输出X的位置（即在数列中的排序），否则返回-1。",
        "function_declaration": "int findXPosition(int N, vector<int> nums, int X)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int N;\n    cin>>N;\n    vector<int> nums(N);\n    for(int i=0; i<N; i++){\n        cin>>nums[i];\n    }\n    int X;\n    cin>>X;\n    // calling start\n    int result = findXPosition(N, nums, X);\n    // calling end\n    if(result == -1){\n        cout<<\"Not Found\";\n    }else{\n        cout<<result;\n    }\n}",
        "example": "[{\"input\": \"5\\n1 4 2 3 5\\n3\", \"output\": \"4\"}, {\"input\": \"5\\n1 2 3 4 5\\n6\", \"output\": \"Not Found\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1703,
        "problem_description": "给定一个长度为n (1 ≤ n ≤ 10000)且由小到大排序的序列，查找数字x在该序列中的位置。",
        "function_declaration": "int findPosition(int n, int x, int a[])",
        "code_context": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[100010];\n\n// function start\n\n// function end\n\nint main() {\n    int n, x;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    cin >> x;\n    // calling start\n    int pos = findPosition(n, x, a);\n    // calling end\n    if (a[pos] != x)\n        cout << \"not find\" << endl;\n    else\n        cout << pos << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1\\n2\\n3\\n4\\n5\\n3\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2306,
        "problem_description": "给定一个长度为 $n$ 的环状数列 $a_1,a_2,...,a_n$，所谓环状，是指在考虑相邻关系时，需要把 $a_1$ 和 $a_n$ 也看做是一对邻居。数列的每个位置上都有一堆物资，数列上的每个数字表示该堆物资的数量。我们希望从 $n$ 个位置中挑选一个位置，使得所有物资能聚集到一起，而且运费总和达到最小。物资只能沿着相邻位置搬运，每当一个单位物资的移动一个单位距离时，需要支付一个单位的运费。请问如何选择一个聚集点，使得运费总和达到最小？输出将所有物资移动到一起的最小总运费。",
        "function_declaration": "int findMinTransportationCost(vector<int>& nums) ",
        "code_context": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n// Function to find the minimum transportation cost\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    // Calling the function to find the minimum transportation cost\n    //calling start\n    int result = findMinTransportationCost(nums);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n1 2 3 4 5\", \"output\": \"14\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2169,
        "problem_description": "感应门会在有人经过的时候自动打开，冷却$d$秒后自动关闭。如果有人在感应门打开的状态下通过，那么冷却时间会重置，重新冷却$d$秒后再关闭。在一段时间内，有$n$个人陆续通过了感应门，他们通过感应门的时间点分别是$t_1,t_2,...,t_n$，请计算感应门一共开放了多少时间。",
        "function_declaration": "int calculateSum(int n, int d, int* arr)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() \n{\n  int n, d;\n  cin >> n >> d;  \n  int* arr = new int[n];\n  for (int i = 0; i < n; ++i) {\n  \t cin >> arr[i];\n  }\n  // calling start\n  int sum = calculateSum(n, d, arr);\n  // calling end\n  cout << sum;\n  delete[] arr;\n}",
        "example": "[{\"input\": \"7 3\\n1 2 7 10 15 17 22\", \"output\": \"18\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1726,
        "problem_description": "给出一个由O和X组成的串，统计得分，每个O得分为目前连续出现的O的个数，X的得分为0。例如OOXXOXXOOO的得分为1+2+0+0+1+0+0+1+2+3=10。",
        "function_declaration": "int calculateScore(char s[])",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nchar s[85];\nint main() {\n    scanf(\"%s\", s);\n    // calling start\n    int score = calculateScore(s);\n    // calling end\n    printf(\"%d\\n\", score);\n    return 0;\n}",
        "example": "[{\"input\": \"OOXXOXXOOO\", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2336,
        "problem_description": "给定 $A$、$B$、$C$ 三根足够长的细柱，在 $A$ 柱上放有 $n$ 个中间有孔的圆盘，圆盘大小从上到下依次增大。现要将这些圆盘全部移到 $C$ 柱上，在移动过程中可放在 $B$ 柱上暂存。要求：（1）每次只能移动一个圆盘；（2）$A$、$B$、$C$三根细柱上的圆盘都要保持上小下大的顺序；现在请你输出移动的最优方案，使用$A->C$表示从$A$移动到$C$.",
        "function_declaration": "void movePillars(int n, char a, char c, char b)",
        "code_context": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n    int n;\n    cin >> n;\n    // calling start\n    movePillars(n, 'A', 'C', 'B');\n    // calling end\n}",
        "example": "[{\"input\": \"1\", \"output\": \"A->C\"}, {\"input\": \"3\", \"output\": \"A->C\\nA->B\\nC->B\\nA->C\\nB->A\\nB->C\\nA->C\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1616,
        "problem_description": "$A_1,A_2,...,A_n$是一个由$n$个自然数（非负整数）组成的数组。我们称其中$A_i,...,A_j$是一个非零段，当且仅当以下条件同时满足：$1\\leq i \\leq j\\leq n$；对于任意的整数$k$，若$i\\leq k \\leq j$，则$A_k>0$；$i=1$或$A_i-1=0$；$j=n$或$A_j+1=0$。下面展示了几个简单的例子：$A=[3,1,2,0,0,2,0,4,5,0,2]$中的4个非零段依次为$[3,1,2]$、$[2]$、$[4,5]$和$[2]$；$A=[2,3,1,4,5]$仅有1个非零段；$A=[0,0,0]$则不含非零段（即非零段个数为0）。现在我们可以对数组$A$进行如下操作：任选一个正整数$p$，然后将$A$中所有小于$p$的数都变为$0$。试选取一个合适的$p$，使得数组$A$中的非零段个数达到最大。若输入的$A$所含非零段数已达最大值，可取$p=1$，即不对$A$做任何修改。输入包含一个正整数$n$和$n$个用空格分隔的自然数$A_1,A_2,...,A_n$。70%的测试数据满足$n\\leq 1000$；全部的测试数据满足$n\\leq 5×10^5$，且数组$A$中的每一个数均不超过$10^4$。 仅输出一个整数，表示对数组$A$进行操作后，其非零段个数能达到的最大值。",
        "function_declaration": "int calculateMaxSegments(int n, vector<int>& A)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int n;\n    cin>>n;\n    vector<int> A(n);\n    for(int i=0; i<n; i++){\n        cin>>A[i];\n    }\n    // calling start\n    int result = calculateMaxSegments(n, A);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"11\\n3 1 2 0 0 2 0 4 5 0 2\", \"output\": \"5\"}, {\"input\": \"14\\n5 1 20 10 10 10 10 15 10 20 1 5 10 15\", \"output\": \"4\"}, {\"input\": \"3\\n1 0 0\", \"output\": \"1\"}, {\"input\": \"3\\n0 0 0\", \"output\": \"0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1677,
        "problem_description": "输入10个升序的整数，数字范围是1～100，再输入一个数x，在这10个数字中找到数字x的位置，输出它是第几个数，如果找不到输出-1。",
        "function_declaration": "int findFirstGreaterOrEqual(int a[], int n, int x)",
        "code_context": "#include <iostream>\nusing namespace std;\n\nint n = 10;\nint a[10];\nint x;\n\n// function start\n\n// function end\n\nint main() {\n    // 输入数组\n    for( int i = 0; i < n; ++i ) \n        cin >> a[i];\n    cin >> x;\n    \n    // calling start\n    int result = findFirstGreaterOrEqual(a, n, x);\n    // calling end\n\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"2 6 7 9 11 13 14 23 26 31\\n9\", \"output\": \"4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2208,
        "problem_description": "有很多合成类的游戏都有如下的玩法：玩家会得到很多数字，每个数字都是2的幂，玩家可以挑选两个一样大的数字，将它们合成一个新的数字，新数字为原数字的两倍大小。如果这种合成操作可以不断地进行，给定小爱在最初获得的数字集合，请帮她算一下能够获得的最大数字。2的幂是指只有2作为素因子的正整数。如4、256等等。但60不是，因为它有素因子3。",
        "function_declaration": "long long getMaxNumber(vector<long long>& numbers)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<long long> numbers(n);\n    for (int i = 0; i < n; i++) {\n        cin >> numbers[i];\n    }\n    //calling start\n    long long maxNumber = getMaxNumber(numbers);\n    //calling end\n    cout << maxNumber << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"5\\n4 1 2 1 1\", \"output\": \"8\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1838,
        "problem_description": "某海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。出于分析目的，分析人员在日志中随机插入了若干第三类操作――查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。 输入N个日志操作，分别属于以下三种格式之一：0 X一次集装箱入库操作，正整数X表示该次入库的集装箱的重量，1一次集装箱出库操作，（就当时而言）最后入库的集装箱出库，2一次查询操作，要求分析程序输出当前仓库内最大集装箱的重量，当仓库为空时你应该忽略出库操作，当仓库为空查询时输出0。全部数据均满足N≤200000, X≤10^8。 输出日志中查询操作的结果。",
        "function_declaration": "vector<int> calculateMaxWeight(vector<pair<int, int>>& logs)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int N;\n    cin>>N;\n    vector<pair<int, int>> logs;\n    for(int i=0;i<N;i++){\n        int operation, weight;\n        cin>>operation;\n        if(operation == 0){\n            cin>>weight;\n        }\n        logs.push_back(make_pair(operation, weight));\n    }\n    // calling start\n    vector<int> result = calculateMaxWeight(logs);\n    // calling end\n    for(int i=0;i<result.size();i++){\n        cout<<result[i]<<endl;\n    }\n}",
        "example": "[{\"input\": \"13\\n0 1\\n0 2\\n2\\n0 4\\n0 2\\n2\\n1\\n2\\n1\\n1\\n2\\n1\\n2\", \"output\": \"2\\n4\\n4\\n1\\n0\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2134,
        "problem_description": "Dark 教授是一个 ASCII 画狂热爱好者者。这次，他希望你打印一个 n 阶的 ASCII 画。n 阶的 ASCII 画由连续 n 个 字符 + 构成。特别地，Dark 教授规定不能使用循环，必须使用函数实现。你能完成他的挑战吗?(提示: 函数可以调用自身，即递归 ；void 函数可以用 return; 语句直接结束函数，类似循环中的 break; )",
        "function_declaration": "void print(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    int n;\n    cin >> n;\n    // calling start\n    print(n);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"+++\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2349,
        "problem_description": "给定一段英文文本，请调整格式，每行依次输出原文的一句话。输入仅一行，包含一段英文文本，由若干个以'.'结尾的句子组成。对于 100% 的数据，文本长度（即包含的字符数量）不超过1000。输出若干行，每行一个句子。",
        "function_declaration": "void formatText(const string& text) ",
        "code_context": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    string text;\n    getline(cin, text);\n\n    //calling start\n    formatText(text);\n    //calling end\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"This is the first sentence. This is the second sentence.\", \"output\": \"This is the first sentence.\\nThis is the second sentence.\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1626,
        "problem_description": "输入三个整数a，b，c，输出a与b或运算的值，再与c与运算的结果。",
        "function_declaration": "int calculate(int a, int b, int c)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    // calling start\n    int result = calculate(a, b, c);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"1 2 3\", \"output\": \"3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1913,
        "problem_description": "如果一个偶数位的十进制数字是一个回文，则称它为偶位回文数。例如：1221 是一个偶位回文数，而 121 和 1234 都不是，因为前者是回文但位数不是偶数，后者位数为偶数 但不是回文。 给定一个整数 n ，请找出正整数中前 n 个偶位回文数，计算并输出它们的和。对于 30% 的数据，1 ≤n≤ 100； 对于 60% 的数据，1 ≤n≤ 5000； 对于 100% 的数据，1 ≤n≤ 100,000。",
        "function_declaration": "long long calculateSum(long long n)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    long long n;\n    cin >> n;\n    // calling start\n    long long result = calculateSum(n);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"2\", \"output\": \"33\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1839,
        "problem_description": "给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。",
        "function_declaration": "long long calculate(string x)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring x;\nstack<char> s;\nstack<long long> n;\nlong long ans;\n\n// function start\n\n// function end\n\nint main() {\n    getline(cin, x);\n    // calling start\n    long long result = calculate(x);\n    // calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"1+1*3+4\\n1+1234567890*1\\n1+1000000003*1\", \"output\": \"8\\n7891\\n4\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1719,
        "problem_description": "给定一个长度为n的字符串，输出共有多少个回文子串(长度大于1)。回文子串即从左往右输出和从右往左输出结果是一样的字符串，比如：`abba`，`cccdeedccc`都是回文字符串。",
        "function_declaration": "int countPalindromeSubstrings(char a[], int n)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main(){ \n    char a[505]; \n    int n; \n    scanf(\"%s\",a); \n    n=strlen(a);\n    //calling start\n    int cnt = countPalindromeSubstrings(a, n);\n    //calling end\n    cout << cnt;\n    return 0;\n}",
        "example": "[{\"input\": \"123321125775165561\", \"output\": \"10\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2094,
        "problem_description": "某商场的仓库中有 n 种商品，每件商品按 1~n 依次编号。现在商场经理突发奇想，决定将编号为素数（质数）的所有商品拿出来搞优惠酬宾活动。请编程帮助仓库管理员将编号为素数的商品选出来。",
        "function_declaration": "bool isPrime(int n)",
        "code_context": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main ( ) { \n    int n;\n    cin >> n;\n    // calling start\n    for (int i = 2; i <= n; i++) {\n        if (isPrime(i)) {\n            cout << i << \" \";\n        }\n    }\n    // calling end\n    return 0; \n}",
        "example": "[{\"input\": \"20\", \"output\": \"2 3 5 7 11 13 17 19\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2359,
        "problem_description": "在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。本题中介绍的瑞士轮赛制，因最早使用于$1895$年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长$2 \\times N$ 名编号为 $1\\sim 2N$ 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。每轮比赛的对阵安排与该轮比赛开始前的排名有关：第$1$ 名和第$2$ 名、第 $3$ 名和第 $4$名、……、第$2K - 1 $名和第$ 2K$名、…… 、第$2N - 1 $名和第$2N$名，各进行一场比赛。每场比赛胜者得$1 $分，负者得 $0 $分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第$ Q$ 的选手编号是多少。我们假设每场比赛中实力值较高的总能获胜，若实力值相同则编号小的获胜。输入三个正整数 $N,R ,Q$,表示有 $2 \\times N $名选手、$R$ 轮比赛，以及我们关心的名次 $Q$。输入$2 \\times N$ 个非负整数$s_1, s_2, …, s_{2N}$，其中$ s_i $表示编号为$i$ 的选手的初始分数。输入$2 \\times N$ 个正整数$w_1 , w_2 , …, w_{2N}$，其中 $w_i$ 表示编号为$i$ 的选手的实力值。输出一个整数，即$R$ 轮比赛结束后，排名第$ Q$ 的选手的编号。",
        "function_declaration": "int SwissTournament(int N, int R, int Q, vector<int> initialScores, vector<int> strengths) ",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\n//function start\n\n//function end\n\nint main() {\n    int N, R, Q;\n    cin >> N >> R >> Q;\n\n    vector<int> initialScores(2 * N);\n    for (int i = 0; i < 2 * N; ++i) {\n        cin >> initialScores[i];\n    }\n\n    vector<int> strengths(2 * N);\n    for (int i = 0; i < 2 * N; ++i) {\n        cin >> strengths[i];\n    }\n    //calling start\n    int result = SwissTournament(N, R, Q, initialScores, strengths);\n    //calling end\n    cout << result << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"2 4 2 \\n7 6 6 7 \\n10 5 20 15\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2183,
        "problem_description": "给定一个整数 a，如果 $a > 2147483647$，输出$2147483647$；如果 $a < -2147483648$，输出$-2147483648$；否则输出 a 本身。",
        "function_declaration": "int process(int a)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int a;\n    cin>>a; // 其实读入int时题面要求的操作会自动完成\n    // calling start\n    int result = process(a);\n    // calling end\n    cout<<result;\n}",
        "example": "[{\"input\": \"10000000000\", \"output\": \"2147483647\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2293,
        "problem_description": "一条直线上有 $n$ 个点，第 $i$ 个点的坐标为 $x_i$。给定一个限制 $d$，若两点距离不超过 $d$，那么它们可以直接通讯。请统计有多少对点可以直接通讯。",
        "function_declaration": "long long calculatePairs(int n, int d, int x[])",
        "code_context": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint x[100000];\n\n// function start\n\n// function end\n\nint main() {\n    int n, d;\n    cin >> n >> d;\n    for (int i = 0; i < n; ++i)\n        cin >> x[i];\n    // calling start\n    long long result = calculatePairs(n, d, x);\n    // calling end\n    cout << result;\n}",
        "example": "[{\"input\": \"4 25\\n30 40 10 20\", \"output\": \"5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1720,
        "problem_description": "从键盘输入由5个字符组成的单词，判断此单词是不是hello。",
        "function_declaration": "bool isHello(char* str)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    char str[6];\n    scanf(\"%s\",&str); \n\n    // calling start\n    bool flag = isHello(str);\n    // calling end\n\n    if(flag == 0)\n        printf(\"this word is not hello!\");\n    else\n        printf(\"this word is hello!\");\n    return 0;\n}",
        "example": "[{\"input\": \"hello\", \"output\": \"this word is hello!\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1560,
        "problem_description": "给定一个大于1的整数n，求 [1,n] 区间上的所有数字之和。",
        "function_declaration": "int calculateSum(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    cin >> n;\n    \n    // calling start\n    int result = calculateSum(n);\n    // calling end\n    \n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"3\", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2232,
        "problem_description": "小A想检验你对乘除法运算掌握的熟练程度。首先小A给了你一个正整数 n，然后小A会给你 q 个操作，每个操作为两个正整数 a,b。如果 a=1，表示将 n 乘以 b（即把 n 的值变成 n*b）；如果 a=2，表示将 n 除以 b（即把 n 的值变成 n/b，保留小数部分）。全部操作结束后，请你输出 n 的值，四舍五入到整数。特别的，小A会保证全部操作结束后 n 的值不大于 10000，以方便你输出。",
        "function_declaration": "double calculateLog(int n, int q, vector<pair<int, int>> operations)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n int n,q,a,b;\n cin>>n>>q;\n vector<pair<int, int>> operations(q);\n for(int i=0; i<q; i++){\n  cin>>a>>b;\n  operations[i] = make_pair(a, b);\n }\n // calling start\n double c = calculateLog(n, q, operations);\n // calling end\n printf(\"%.0lf\",c);\n}",
        "example": "[{\"input\": \"1 3\\n1 1000\\n2 7\\n1 50\", \"output\": \"7143\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2152,
        "problem_description": "逢七必过的游戏规则如下：对一个区间内的整数进行报数，若遇到的数字是7的倍数或个位数是7，则不报数，输出pass。给定开始游戏的第一个整数$a$，及结束游戏时的最后一个整数$b$，请输出整个报数过程。输出若干行：每行一个数字或者一个单词。",
        "function_declaration": "void checkNumber(int a, int b)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a, b;  \n    cin >> a >> b;\n    // calling start\n    checkNumber(a, b);\n    // calling end\n}",
        "example": "[{\"input\": \"1 10\", \"output\": \"1\\n2\\n3\\n4\\n5\\n6\\npass\\n8\\n9\\n10\"}, {\"input\": \"41 50\", \"output\": \"41\\npass\\n43\\n44\\n45\\n46\\npass\\n48\\npass\\n50\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2345,
        "problem_description": "小橙向小万同学借课本书来抄笔记。小万在重点语句前后加入了星号 \"*\"。两个 \"*\" 之间的内容表示重点。小橙同学觉得这样不够直观，因此她想在自己本子上记录时，用尖括号\"<\"、\">\"来表示重点语句。请你帮小橙同学转换一下吧！注意，重点语句可能跨越很多行。",
        "function_declaration": "void processStr(char* str)",
        "code_context": "#include <cstring>\n#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nchar str[10001];\n\nint main() {\n    cin.read(str, 10000);\n    // calling start\n    processStr(str);\n    // calling end\n    cout.write(str, strlen(str));\n    return 0;\n}",
        "example": "[{\"input\": \"hello, my name\\nis *XiaoWan*,\\nnice to meet *you*.\", \"output\": \"hello, my name\\nis <XiaoWan>,\\nnice to meet <you>.\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1795,
        "problem_description": "使用指针编写函数，将输入字符串反序输出。",
        "function_declaration": "void reversePrint(char* str, int len)",
        "code_context": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    char str[100];\n    cin >> str;\n    int len;\n    len = strlen(str);\n    // calling start\n    reversePrint(str, len);\n    // calling end\n    return 0;\n}",
        "example": "[{\"input\": \"ABCDEFGHIJK\", \"output\": \"KJIHGFEDCBA\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2016,
        "problem_description": "2048 是一款简单有趣的益智游戏，其规则如下 : 存在一些带有数字的方块，只有对于数字相同的两个方块，其会合并为一个方块，数字变为两个数字的和。例如两个数字为 1 的方块可以合成一个数字为 2 的方块，而数字为 1 和 数字为 2 的两个方块不能合并。现在，给定两个方块的数字，判断他们两个方块是否能够合并。特别地，数字可能不是整数。",
        "function_declaration": "bool isEqual(double x, double y)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nsigned main() {\n    double x,y;\n    cin >> x >> y;\n    // calling start\n    bool result = isEqual(x, y);\n    // calling end\n    if(result) cout << \"Yes\";\n    else       cout << \"No\";\n    return 0;\n}",
        "example": "[{\"input\": \"1.3 1.3\", \"output\": \"Yes\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1745,
        "problem_description": "现有一个n个数字的序列和一个长度为k的滑窗，开始时滑窗左侧和第一个数字重合，之后依次向右挪一格，直到滑窗右侧恰好盖住最后一个数字。请你求出每次滑窗中的最大值。返回n - k + 1个整数，表示每次滑窗中的最大值。",
        "function_declaration": "vector<int> slidingWindowMax(vector<int>& nums, int k)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n    // calling start\n    vector<int> result = slidingWindowMax(nums, m);\n    // calling end\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"5 2\\n1 4 3 5 2\", \"output\": \"4 4 5 5\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2187,
        "problem_description": "给定 n 个正整数，你可以从中任意选择两个数 a、b 进行合成，合成结果是 2*min(a,b)（即 a、b 中较小数的两倍）。用于合成的两个数 a、b 将在合成后消失，而合成得到的数 2*min(a,b) 可以继续参与其他合成。你可以进行任意次合成操作。返回你能得到的最大的数。",
        "function_declaration": "int findMaxNumber(int n, vector<int>& nums) ",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to find the maximum number that can be obtained\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n\n    // Calling the function to find the maximum number\n    //calling start\n    int result = findMaxNumber(n, nums);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"8\\n1 2 3 4 5 6 7 8\", \"output\": \"28\"}, {\"input\": \"2\\n7 3\", \"output\": \"7\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2288,
        "problem_description": "小爱和小艾两人组队打一只怪兽。一开始怪兽有 $n$ 点生命值，当 $n$ 变成 $0$ 或更低时，怪兽就被消灭了。他们两人是同时开始攻击的，小爱每分钟可以攻击 $a$ 下，小艾每分钟可以攻击 $b$ 下。若 $a=2, b=4$，则小爱发出攻击的时刻为$$0.5, 1, 1.5, 2, 2.5, ...$$，小艾发出攻击的时刻为$$0.25, 0.5, 0.75, 1, 1.25, 1.5, ...$$攻击分两种类型，普通攻击每次对怪兽造成 1 点伤害。若在某时刻，小爱和小艾恰好一同发出攻击，称为爆击，爆击将对怪兽造成成倍的伤害，共计 $(1+1)×2=4$ 点伤害。一旦攻击开始，就不会中断，直到怪兽被消灭为止，请问，对怪兽造成最后一点伤害的是哪一位玩家？若是小爱发出了最后一击，返回A；若是小艾发出了最后一击，返回B；若是两人的爆击为最后一击，返回C。",
        "function_declaration": "char lastAttacker(int n, int a, int b)",
        "code_context": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n// Function to determine the last attacker\n//function start\n\n//function end\n\nint main() {\n    int n, a, b;\n    cin >> n >> a >> b;\n\n    // Determine the last attacker and print the result\n    //calling start\n    char result = lastAttacker(n, a, b);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"40\\n3 5\", \"output\": \"C\"}, {\"input\": \"33\\n3 5\", \"output\": \"B\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1760,
        "problem_description": "将1~4按字典序从小到大排序，输入其中一个排列比如(3 2 1 4)，利用next_permutation函数，输出它的下一个排列（3 2 4 1）。如果没有下一个排列了，则输出“No”。输入为4个数字，代表1～4的某一个排列。输出4个数字，空格隔开，代表下一个排列。",
        "function_declaration": "void nextPermutation(vector<int>& nums)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    vector<int> nums(4);\n    for(int i=0; i<4; i++){\n        cin>>nums[i];\n    }\n    // calling start\n    nextPermutation(nums);\n    // calling end\n}",
        "example": "[{\"input\": \"1 2 3 4\", \"output\": \"1 2 4 3\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1832,
        "problem_description": "用顺序表表示静态查找表时，搜索函数可以采用顺序查找来实现。通常顺序查找的查找过程是从表中的最后一个记录开始，逐个将记录的关键字和给定的查找值进行比较，如果某个记录的关键字与给定的值比较相等，则说明查找成功；否则如果直到第一个记录，所有的关键字都与给定的值不相等，说明表中没有响应的记录，查找失败。读入一串整数，另外给定多次查询，判断每一次查询是否找到了相应的整数，如果找到则返回整数相应的位置。给定n个整数和查找值t，如果在查询中找到了对应的整数，则返回其相应的位置，否则返回-1。",
        "function_declaration": "int findIndex(int a[],int n, int t)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;  \n\nint a[510];\n\n// function start\n\n// function end\n\nint main() {\n    int n, m, t;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    while (m--) {\n        cin >> t;\n        // calling start\n        int index = findIndex(a, n, t);\n        // calling end\n        cout << index << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"8 3\\n1 3 5 7 8 9 10 15\\n9 2 5\", \"output\": \"5 -1 2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2202,
        "problem_description": "有两种命名变量的方法：驼峰命名法——每个单词都首字母大写，单词之间不加空格。比如MyFirstName，DataCenter等。蛇形命名法——每个单词的字母全部小写，单词之间用下划线_相连，比如my_first_name，data_center等。给定一个用驼峰法命名的名字，请将它转成蛇形命名法的形式。",
        "function_declaration": "string camelToSnake(string s)",
        "code_context": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to convert camel case to snake case\n//function start\n\n//function end\n\nint main() {\n    string s;\n    cin >> s;\n\n    // Calling the function to convert camel case to snake case\n    //calling start\n    string result = camelToSnake(s);\n    //calling end\n\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"HowAreYou\", \"output\": \"how_are_you\"}, {\"input\": \"Good\", \"output\": \"good\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1740,
        "problem_description": "在一张网格图上有两个棋子，并给出他们各自的移动步骤。每次你可以选择只拿一个棋子走一步，也可以选择两个都走一步，每步的代价是走完后，两棋子直线距离的平方，请你找出一种方案使得他们走完后代价最小，并输出该代价。输入两个整数n m (1 ≤ n m ≤ 1000)，分别表示两个棋子的移动步数。两个整数x1和y1，表示棋子1的起始位置坐标。两个整数x2和y2，表示棋子2的起始位置坐标。moves1包含n个整数，表示棋子1的移动路线。moves2包含m个整数，表示棋子2的移动路线。对于移动路线的描述是：1代表向上，2代表向下，3代表向左，4代表向右。坐标绝对值不超过1000。返回一个整数，表示最小的代价。",
        "function_declaration": "int calculateMinimumCost(int n, int m, int x1, int y1, int x2, int y2, vector<int>& moves1, vector<int>& moves2)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    // Reading input\n    int n, m;\n    cin >> n >> m;\n\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    vector<int> moves1(n);\n    vector<int> moves2(m);\n\n    for (int i = 0; i < n; ++i) {\n        cin >> moves1[i];\n    }\n\n    for (int i = 0; i < m; ++i) {\n        cin >> moves2[i];\n    }\n\n    //calling start\n    int minCost = calculateMinimumCost(n, m, x1, y1, x2, y2, moves1, moves2);\n    //calling end\n    cout << minCost << endl;\n\n    return 0;\n}\n",
        "example": "[{\"input\": \"2 3\\n0 0\\n1 0\\n3 3\\n4 4 4\", \"output\": \"56\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2049,
        "problem_description": "Hastin要和DarkSharpless进行激烈的决斗！他们选择的是最原始，最朴素的方式——石头剪刀布，而你则要作为裁判，判断他们是谁赢了。a,b 分别代表Hastin和DarkSharpless所出的招式，其中：0代表石头1代表剪刀2代表布，且规则就是传统的石头剪刀布规则，即石头赢剪刀，剪刀赢布，布赢石头。返回1表示Hastin获胜，返回0表示打平，返回-1表示DarkSharpless获胜。",
        "function_declaration": "int gameResult(int a, int b)",
        "code_context": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int a = 0, b = 0;\n    cin >> a >> b;\n    //calling start\n    int result = gameResult(a, b);\n    //calling end\n    if (result == 1) puts(\"Hastin\");\n    else if (result == 0) puts(\"draw\");\n    else puts(\"DarkSharpless\");\n    return 0;\n}",
        "example": "[{\"input\": \"1 0\", \"output\": \"DarkSharpless\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1594,
        "problem_description": "小明钱包里装着各种纸币。纸币有4种（纸币的类型有1元、3元、5元和10元），每一种分别有a、b、c、d张。现在小明要出门买东西，他需要支付N元，在不找零的情况下，请问能支付成功吗？如果能成功支付，那么请计算出有多少种支付方式；如果不能成功支付，返回0。",
        "function_declaration": "int calculatePaymentWays(int a, int b, int c, int d, int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int a, b, c, d, n;\n    cin >> a >> b >> c >> d >> n;\n\n    // calling start\n    int num = calculatePaymentWays(a, b, c, d, n);\n    // calling end\n\n    if (num)\n        cout << num << endl;\n    else\n        cout << \"no\" << endl;\n    \n    return 0;\n}",
        "example": "[{\"input\": \"1 1 1 1 1\", \"output\": \"1\"}, {\"input\": \"1 1 1 1 100\", \"output\": \"no\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2221,
        "problem_description": "某学校的某次考试成绩以等第形式出现的，每名学生的成绩都是ABCD 中的一个。学校有 $n$ 个班级，小爱想根据这次考试中A的比例，从高到低为这些班级排序；若出现两个班级A的比例相同，就按B的比例从高到低排序；若再相同，就按照C的比例；若再相同，就按照班级人数从大到小排序；若再相同，就按照班级编号从小到大排序。请帮助小爱完成这个任务。输入有n个字符串，表示第 $i$ 个班级的学生成绩，每个字符代表一个学生的成绩。",
        "function_declaration": "vector<int> sortClasses(int n, const vector<string>& grades)",
        "code_context": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<string> grades(n);\n    for (int i = 0; i < n; i++) {\n        cin >> grades[i];\n    }\n    //calling start\n    vector<int> sortedClasses = sortClasses(n, grades);\n    //calling end\n    for (int id : sortedClasses) {\n        cout << id << \" \";\n    }\n\n    return 0;\n}",
        "example": "[{\"input\": \"3\\nABAACAA\\nDDABBB\\nBABABA\", \"output\": \"1 3 2\"}, {\"input\": \"3\\nABCD\\nABCDABCD\\nAABBCCDD\", \"output\": \"2 3 1\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1596,
        "problem_description": "一个常量a的值为10，输入数字b，求出常量a与变量b的和，两个变量或常量求和时，可以用+连接二者，例如求变量a与常量2的和，则可写为a + 2。",
        "function_declaration": "int add(int a, int b)",
        "code_context": "#include <iostream>\nusing namespace std; \n\n// function start\n\n// function end\n\nint main() {\n    const int a = 10;\n    int b;\n    cin >> b;\n    // calling start\n    int result = add(a, b);\n    // calling end\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"5\", \"output\": \"15\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1782,
        "problem_description": "有$n$个小朋友，按照身高从矮到高排成一排。现在来了一个新的小朋友，身高为$k$，请问把他/她插入到队伍中，他/她应该排在第几个？",
        "function_declaration": "int findFirstHigher(double h[], int n, double k)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int n;\n    double k;\n    double h[100010];\n\n    cin >> n >> k;\n    for (int i = 0; i < n; ++i)\n        cin >> h[i];\n\n    // calling start\n    int result = findFirstHigher(h, n, k);\n    // calling end\n\n    cout << result;\n    return 0;\n}",
        "example": "[{\"input\": \"5 1.22\\n1.20 1.32 1.35 1.37 1.39 \", \"output\": \"2\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1992,
        "problem_description": "博小鱼遇到这样一个难题，他想请教你的帮助：输入一个6位数，请你将这个数反过来的结果输出。",
        "function_declaration": "void reversePrint(char a1, char a2, char a3, char a4, char a5, char a6)",
        "code_context": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n//function start\n\n//function end\n\nint main(){\n    //freopen(\"5.in\", \"r\", stdin);\n    //freopen(\"5.out\", \"w\", stdout);\n\n    char a1,a2,a3,a4,a5,a6;\n    scanf(\"%c%c%c%c%c.%c\", &a1, &a2, &a3, &a4, &a5, &a6);\n    //calling start\n    reversePrint(a1, a2, a3, a4, a5, a6);\n    //calling end\n    return 0;\n}",
        "example": "[{\"input\": \"12345.6\", \"output\": \"6.54321\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1924,
        "problem_description": "给定一个字符串 s，若 s 的任意一个长度大于或等于 2 的子串中，某一字符出现次数超过该子串长度的一半，则 s 是不够随机的。否则，我们称 s 是随机的。请判断 s 是否是一个随机的字符串。记 s 的长度为 |s|，对于 30% 的数据，1 ≤ ∣s∣ ≤ 1000；  对于 60% 的数据，1 ≤ ∣s∣ ≤ 10000； 对于 100% 的数据，1 ≤ ∣s∣ ≤ 100000。     保证 s 仅由英文小写字母组成。",
        "function_declaration": "bool isRandomString(string str)",
        "code_context": "#include <bits/stdc++.h>\nusing namespace std;\n\nint cnt[30];\n\n// function start\n\n// function end\n\nint main() {\n    string str;\n    cin >> str;\n    // calling start\n    bool result = isRandomString(str);\n    // calling end\n    if (result) {\n        cout << \"Random string\" << endl;\n    } else {\n        cout << \"Not a random string\" << endl;\n    }\n    return 0;\n}",
        "example": "[{\"input\": \"yacs\", \"output\": \"Random string\"}, {\"input\": \"iai\", \"output\": \"Not a random string\"}, {\"input\": \"happy\", \"output\": \"Not a random string\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1885,
        "problem_description": "美国人使用英制计量单位，他们习惯用几尺几寸（几英尺几英寸）来报自己的身高，请将几尺几寸转换为米的计量单位。",
        "function_declaration": "float calculateHeight(int feet, int inch)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int feet, inch; \n  float height;\n  cin >> feet >> inch;\n  // calling start\n  height = calculateHeight(feet, inch);\n  // calling end\n  cout << height;\n  return 0;\n}",
        "example": "[{\"input\": \"5 7\", \"output\": \"1.7018\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1974,
        "problem_description": "BMI 指数是国际上常用的衡量人体胖瘦程度的一个标准，其算法是 m÷(h×h) ，其中 m 是指体重（千克），h 是指身高（米）。请计算BMI 指数。",
        "function_declaration": "double calculateBMI(double m, double h)",
        "code_context": "#include <iostream>\n\nusing namespace std;\ndouble m, h, bmi;\n\n// function start\n\n// function end\n\nint main() {\n  cin >> m >> h;\n  // calling start\n  bmi = calculateBMI(m, h);\n  // calling end\n  // 开始比大小\n  if (bmi < 18.5) cout << \"Underweight\" << endl;\n  if (bmi >= 18.5 && bmi < 24) cout << \"Normal\";\n  if (bmi >= 24) cout << bmi << endl << \"Overweight\" << endl;\n  return 0;\n}",
        "example": "[{\"input\": \"70 1.72\\n\", \"output\": \"Normal\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1791,
        "problem_description": "编写一个程序，用动态分配空间的方法计算Fibonacci数列的前20项，并存储到动态分配的空间中。",
        "function_declaration": "void calculateFibonacci(int* p)",
        "code_context": "#include <iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int *p;\n    p = new int[20];\n    // calling start\n    calculateFibonacci(p);\n    // calling end\n    for (int i = 0; i < 20; i++)\n        cout << p[i] << \" \";\n    return 0;\n}",
        "example": "[{\"input\": \" \", \"output\": \"1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 306,
        "problem_description": "津津的零花钱一直都是自己管理。每个月的月初妈妈给津津300元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上20％还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于100元或恰好100元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。例如11月初津津手中还有83元，妈妈给了津津300元。津津预计11月的花销是180元，那么她就会在妈妈那里存200元，自己留下183元。到了11月月末，津津手中会剩下3元钱。津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。现在请你根据2004年1月到12月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到2004年年末，妈妈将津津平常存的钱加上20％还给津津之后，津津手中会有多少钱。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出-X，X表示出现这种情况的第一个月；否则返回到2004年年末津津手中会有多少钱。",
        "function_declaration": "int calculateSavings(int monthlyExpenses[12])",
        "code_context": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n    int x = 0;\n    int monthlyExpenses[12];\n    for (int i = 0; i < 12; ++i) {\n        cin >> x;\n        monthlyExpenses[i] = x;\n    }\n    // calling start\n    int result = calculateSavings(monthlyExpenses);\n    // calling end\n    cout << result << '\\n';\n    return 0;\n}",
        "example": "[{\"input\": \"290\\n230\\n280\\n200\\n300\\n170\\n340\\n50\\n90\\n80\\n200\\n60\\n\", \"output\": \"-7\\n\"}]",
        "time_limit": 1000,
        "memory_limit": 125
    },
    {
        "id": 1827,
        "problem_description": "在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转180度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。",
        "function_declaration": "long long bubbleSortAndCount(int n, int a[])",
        "code_context": "#include <cstdio> \n#include <cstring> \n#include <iostream> \n#include <algorithm> \n#define N 10005 \nusing namespace std; \n\nint n, a[N]; \n\n// function start\n\n// function end\n\nint main() { \n    scanf(\"%d\", &n); \n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]); \n\n    // calling start\n    long long sum = bubbleSortAndCount(n, a);\n    // calling end\n\n    printf(\"%lld\\n\", sum); \n    return 0; \n}",
        "example": "[{\"input\": \"4\\n4 3 2 1 \", \"output\": \"6\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2153,
        "problem_description": "给定一个正整数$n$，请判定它是否是一个回文数，所谓回文数，就是将这个数的所有数字倒序排列后这个数的大小保持不变，比如101与6886都是回文数，而100不是回文数。如果输入是一个回文数，返回1；否则，返回0.",
        "function_declaration": "int reverseAndCheck(int n)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n\tint n;\n\tcin >> n;\n\t// calling start\n\tint result = reverseAndCheck(n);\n\t// calling end\n\tif (result == 1)\n\t\tcout << \"Palindromic Number\";\n\telse \n\t    cout << \"Non-Palindromic Number\";\n}",
        "example": "[{\"input\": \"1001\", \"output\": \"Palindromic Number\"}, {\"input\": \"8848\", \"output\": \"Non-Palindromic Number\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1888,
        "problem_description": "给定一个整数a，判断其正负。如果a>0，返回positive；如果a=0，返回zero；如果a<0,返回negative。",
        "function_declaration": "string checkNumber(int a)",
        "code_context": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main() {\n  int a;\n  cin >> a;\n  // calling start\n  cout << checkNumber(a);\n  // calling end\n  return 0;\n}",
        "example": "[{\"input\": \"10\", \"output\": \"positive\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1621,
        "problem_description": "考虑到安全指数是一个较大范围内的整数、小菜很可能搞不清楚自己是否真的安全，顿顿决定设置一个阈值$\\theta$，以便将安全指数$y$转化为一个具体的预测结果——“会挂科”或“不会挂科”。因为安全指数越高表明小菜同学挂科的可能性越低，所以当$y\\geq \\theta$时，顿顿会预测小菜这学期很安全、不会挂科；反之若$y<\\theta$，顿顿就会劝诫小菜：“你期末要挂科了，勿谓言之不预也。”那么这个阈值该如何设定呢？顿顿准备从过往中寻找答案。具体来说，顿顿评估了$m$位同学上学期的安全指数，其中第$i(1\\leq i \\leq m)$位同学的安全指数为$y_i$，是一个$[0,10^8]$范围内的整数；同时，该同学上学期的挂科情况记作$result_i \\in {0,1}$，其中$0$表示挂科、$1$表示未挂科。相应地，顿顿用$predict_{\\theta}(y)$表示根据阈值$\\theta$将安全指数y转化为的具体预测结果。如果$predict_{\\theta}(y_j)$与$result_j$相同，则说明阈值为$\\theta$时顿顿对第$j$位同学是否挂科预测正确；不同则说明预测错误。如果$y< \\theta $，$predict_{\\theta}(y)=0$如果$y \\geq \\theta $，$predict_{\\theta}(y)=1$最后，顿顿设计了如下公式来计算最佳阈值$\\theta^*$：$\\theta^*=arg \\max_{\\theta\\in y_i}\\sum_{j=1}^m(predict_{\\theta}(y_j)==result_j)$该公式亦可等价地表述为如下规则：最佳阈值仅在$y_i$中选取，即与某位同学的安全指数相同；按照该阈值对这$m$位同学上学期的挂科情况进行预测，预测正确的次数最多（即准确率最高）；多个阈值均可以达到最高准确率时，选取其中最大的。输入包含一个正整数$m$及$m$对整数$y_i$和$result_i$，含义如上文所述。70%的测试数据保证$m\\leq 200$；全部的测试数据保证$2\\leq m \\leq 10^5$。返回一个整数，表示最佳阈值$\\theta^*$。",
        "function_declaration": "int calculateThreshold(int m, vector<int>& y, vector<int>& result)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n// function end\n\nint main(){\n    int m;\n    cin>>m;\n    vector<int> y(m);\n    vector<int> result(m);\n    for(int i=0; i<m; i++){\n        cin>>y[i]>>result[i];\n    }\n    // calling start\n    int threshold = calculateThreshold(m, y, result);\n    // calling end\n    cout<<threshold;\n}",
        "example": "[{\"input\": \"6\\n0 0\\n1 0\\n1 1\\n3 1\\n5 1\\n7 1\", \"output\": \"3\"}, {\"input\": \"8\\n5 1\\n5 0\\n5 0\\n2 1\\n3 0\\n4 0\\n100000000 1\\n1 0\", \"output\": \"100000000\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1599,
        "problem_description": "输入一个字符，返回其所对应的ASCII码。",
        "function_declaration": "int charToInt(char a)",
        "code_context": "#include <cstdio>\nusing namespace std; \n\n//function start\n\n//function end\n\nint main() {\n    char a;\n    scanf(\"%c\", &a);\n    //calling start\n    int result = charToInt(a);\n    //calling end\n    printf(\"%d\", result);\n    return 0;\n}",
        "example": "[{\"input\": \"a\", \"output\": \"97\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 1798,
        "problem_description": "在已按由小到大顺序存放的a数组中插入x，插入后数组中的数仍有序。数组a中一共有10个元素，分别是：1,3,5,7,9,11,13,15,17,19。输入x，输出插入后的数组的所有元素，用空格隔开。",
        "function_declaration": "void insertElement(int a[], int x)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int a[11] = {1,3,5,7,9,11,13,15,17,19};\n    int x;\n    cin>>x;\n    // calling start\n    insertElement(a, x);\n    // calling end\n}",
        "example": "[{\"input\": \"4\", \"output\": \"1 3 4 5 7 9 11 13 15 17 19\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2229,
        "problem_description": "给定一个正整数 n，输出 n 和 n+1 的最大公约数对 1000003 取模的值。",
        "function_declaration": "int gcdOfNAndNPlusOne(int n)",
        "code_context": "#include <iostream>\nusing namespace std;\n\nconst int MOD = 1000003;\n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    //calling start\n    int result = gcdOfNAndNPlusOne(n);\n    //calling end\n    cout << result << endl;\n\n    return 0;\n}",
        "example": "[{\"input\": \"2\", \"output\": \"1\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 1655,
        "problem_description": "把一堆苹果分给n个小朋友，要使每个人都能拿到苹果，而且每个人拿到的苹果数都不同的话，这堆苹果至少应该有多少个？",
        "function_declaration": "int calculateSum(int n)",
        "code_context": "#include <iostream>\n\nusing namespace std; \n\n//function start\n\n//function end\n\nint main() {\n    int n;\n    cin >> n;\n    //calling start\n    int result = calculateSum(n);\n    //calling end\n    cout << result << endl;\n    return 0;\n}",
        "example": "[{\"input\": \"8\", \"output\": \"36\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2372,
        "problem_description": "小奔的期末考试结束了。他的成绩不久之后就会发下来。给出一个考试成绩表格，学校的老师认为如果录入如此多的成绩不好算分，于是他想要一个的综合成绩评定。综合成绩评定指：(每一科的满分之和*3-每一科的实际得分之和*2)÷每科所扣除分数的和。小奔想请你给出他的综合成绩，你能做到吗？输入一个整数n，表示科目的总数。n个整数$a_i$,表示第i门课程的满分。n个整数$b_i$,表示第i门课程小奔的实际得分。返回一个小数，表示他的综合成绩。",
        "function_declaration": "double calculateAverage(int n, int a[], int b[])",
        "code_context": "#include <bits/stdc++.h> \n#define N 1000010\nusing namespace std; \n\nint n, a[N], b[N]; \n\n// function start\n\n// function end\n\nint main() { \n    scanf(\"%d\", &n); \n    for (int i = 0; i < n; ++i) { \n        scanf(\"%d\", &a[i]); \n    } \n    for (int i = 0; i < n; ++i) { \n        scanf(\"%d\", &b[i]); \n    } \n\n    // calling start\n    double ans = calculateAverage(n, a, b);\n    // calling end\n\n    printf(\"%.6f\", ans); \n      \n    return 0; \n}",
        "example": "[{\"input\": \"3\\n10 10 10\\n5 5 5\", \"output\": \"4.000000\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2231,
        "problem_description": "小A和小B正在玩一个猜数游戏。规则如下：小B先想一个正整数 n 并告诉小A，然后在心里想一个大小不超过 n 的正整数，小A每次可以猜一个数，如果这个数比小B想的数小，小B会回答“猜小了”；如果这个数比小B想的数大，小B会回答“猜大了”；如果这个数恰好就是小B想的数，小B会回答“猜对了”，游戏结束。现在小B已经将 n 告诉小A，小A想请你告诉他，他最少需要猜多少次才能保证，无论小B想的数是多少，最后他都能猜对。",
        "function_declaration": "int calculateLog(int n)",
        "code_context": "#include<bits/stdc++.h>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main(){\n    int t,n;\n    cin>>t;\n    // calling start\n    while(t--){\n        cin>>n;\n        cout<<calculateLog(n)<<endl;\n    }\n    // calling end\n}",
        "example": "[{\"input\": \"2\\n1\\n7\", \"output\": \"1\\n3\"}]",
        "time_limit": 1000,
        "memory_limit": 512
    },
    {
        "id": 2364,
        "problem_description": "结构体不仅仅是捆绑几个相关的量。很重要的一点是，这几个量在内存中的存储是连续的。比如以下代码struct A {\n    int a;\n    int b;\n    int c;\n};\nA x;\n对x和x.a取引用会得到相同的地址，而&x.b与&x.a的差恰好为int类型所占的字节数。由于这样的性质，当二进制操作时，我们也可以用结构体统一操作。这一点在文件读写时很有用。假如你现在有一个类struct Person {\n    char name[8];\n    int age;\n    int height;\n};\n你将会从cin读取到若干组二进制数据（小端序），你需要在cout上逐行输出该用户的信息，每行一个人，依次是人名、年龄、身高，用空格隔开。",
        "function_declaration": "void printPersonInfo(Person a)",
        "code_context": "#include <iostream>\nusing namespace std;\n\nstruct Person {\n\tchar name[8];\n\tint age;\n\tint height;\n};\n\n// function start\n\n// function end\n\nint main() {\n\tPerson a;\n\t// calling start\n\twhile (cin.read(reinterpret_cast<char *>(&a), sizeof(a))) {\n\t\tprintPersonInfo(a);\n\t}\n\t// calling end\n\treturn 0;\n}",
        "example": "[{\"input\": \"因为二进制无法直接显示，因此这里使用十六进制表示。\\n（提示：在vscode或其他文本编辑器中，通常有十六进制编辑器插件）\\n\\n\\n41 6c 69 63 65 00 00 00 12 00 00 00 b4 00 00 00\\n42 6f 62 00 00 00 00 00 12 00 00 00 aa 00 00 00\\n\", \"output\": \"Alice 18 180\\nBob 18 170\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    },
    {
        "id": 2079,
        "problem_description": "给你一个整数x，你需要判断，这个整数中是否出现过数字42或者能够被42整除。如果是，返回1，否则返回0即可。",
        "function_declaration": "int checkNumber(long long x)",
        "code_context": "#include<iostream>\nusing namespace std;\n\n// function start\n\n// function end\n\nint main()\n{\n\tlong long x;\n\tcin >> x;\n\t// calling start\n\tint flag = checkNumber(x);\n\t// calling end\n\tif (flag)\n\t\tprintf(\"Yes\\n\");\n\telse\n\t\tprintf(\"No\\n\");\n\t\n\treturn 0;\t\t\n}",
        "example": "[{\"input\": \"11424\", \"output\": \"Yes\"}, {\"input\": \"17682\", \"output\": \"Yes\"}, {\"input\": \"16124\", \"output\": \"No\"}, {\"input\": \"42\", \"output\": \"Yes\"}]",
        "time_limit": 1000,
        "memory_limit": 256
    }
]